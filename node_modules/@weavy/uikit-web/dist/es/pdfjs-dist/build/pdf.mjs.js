var gp = Object.defineProperty;
var mp = (f) => {
  throw TypeError(f);
};
var cm = (f, t, e) => t in f ? gp(f, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : f[t] = e;
var d = (f, t) => gp(f, "name", { value: t, configurable: !0 });
var U = (f, t, e) => cm(f, typeof t != "symbol" ? t + "" : t, e), Xl = (f, t, e) => t.has(f) || mp("Cannot " + e);
var r = (f, t, e) => (Xl(f, t, "read from private field"), e ? e.call(f) : t.get(f)), A = (f, t, e) => t.has(f) ? mp("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(f) : t.set(f, e), g = (f, t, e, s) => (Xl(f, t, "write to private field"), s ? s.call(f, e) : t.set(f, e), e), m = (f, t, e) => (Xl(f, t, "access private method"), e);
var se = (f, t, e, s) => ({
  set _(i) {
    g(f, t, i, e);
  },
  get _() {
    return r(f, t, s);
  }
});
var ta = {};
ta.d = (f, t) => {
  for (var e in t)
    ta.o(t, e) && !ta.o(f, e) && Object.defineProperty(f, e, { enumerable: !0, get: t[e] });
};
ta.o = (f, t) => Object.prototype.hasOwnProperty.call(f, t);
var B = globalThis.pdfjsLib = {};
ta.d(B, {
  AbortException: /* @__PURE__ */ d(() => (
    /* reexport */
    Bs
  ), "AbortException"),
  AnnotationEditorLayer: /* @__PURE__ */ d(() => (
    /* reexport */
    uu
  ), "AnnotationEditorLayer"),
  AnnotationEditorParamsType: /* @__PURE__ */ d(() => (
    /* reexport */
    N
  ), "AnnotationEditorParamsType"),
  AnnotationEditorType: /* @__PURE__ */ d(() => (
    /* reexport */
    G
  ), "AnnotationEditorType"),
  AnnotationEditorUIManager: /* @__PURE__ */ d(() => (
    /* reexport */
    Ln
  ), "AnnotationEditorUIManager"),
  AnnotationLayer: /* @__PURE__ */ d(() => (
    /* reexport */
    Wd
  ), "AnnotationLayer"),
  AnnotationMode: /* @__PURE__ */ d(() => (
    /* reexport */
    Ys
  ), "AnnotationMode"),
  CMapCompressionType: /* @__PURE__ */ d(() => (
    /* reexport */
    sc
  ), "CMapCompressionType"),
  ColorPicker: /* @__PURE__ */ d(() => (
    /* reexport */
    ul
  ), "ColorPicker"),
  DOMSVGFactory: /* @__PURE__ */ d(() => (
    /* reexport */
    la
  ), "DOMSVGFactory"),
  DrawLayer: /* @__PURE__ */ d(() => (
    /* reexport */
    mu
  ), "DrawLayer"),
  FeatureTest: /* @__PURE__ */ d(() => (
    /* reexport */
    jt
  ), "FeatureTest"),
  GlobalWorkerOptions: /* @__PURE__ */ d(() => (
    /* reexport */
    Ds
  ), "GlobalWorkerOptions"),
  ImageKind: /* @__PURE__ */ d(() => (
    /* reexport */
    lh
  ), "ImageKind"),
  InvalidPDFException: /* @__PURE__ */ d(() => (
    /* reexport */
    Fh
  ), "InvalidPDFException"),
  MissingPDFException: /* @__PURE__ */ d(() => (
    /* reexport */
    Hs
  ), "MissingPDFException"),
  OPS: /* @__PURE__ */ d(() => (
    /* reexport */
    Ee
  ), "OPS"),
  PDFDataRangeTransport: /* @__PURE__ */ d(() => (
    /* reexport */
    Zh
  ), "PDFDataRangeTransport"),
  PDFDateString: /* @__PURE__ */ d(() => (
    /* reexport */
    jh
  ), "PDFDateString"),
  PDFWorker: /* @__PURE__ */ d(() => (
    /* reexport */
    zn
  ), "PDFWorker"),
  PasswordResponses: /* @__PURE__ */ d(() => (
    /* reexport */
    pm
  ), "PasswordResponses"),
  PermissionFlag: /* @__PURE__ */ d(() => (
    /* reexport */
    fm
  ), "PermissionFlag"),
  PixelsPerInch: /* @__PURE__ */ d(() => (
    /* reexport */
    bi
  ), "PixelsPerInch"),
  RenderingCancelledException: /* @__PURE__ */ d(() => (
    /* reexport */
    da
  ), "RenderingCancelledException"),
  TextLayer: /* @__PURE__ */ d(() => (
    /* reexport */
    pa
  ), "TextLayer"),
  UnexpectedResponseException: /* @__PURE__ */ d(() => (
    /* reexport */
    Nr
  ), "UnexpectedResponseException"),
  Util: /* @__PURE__ */ d(() => (
    /* reexport */
    I
  ), "Util"),
  VerbosityLevel: /* @__PURE__ */ d(() => (
    /* reexport */
    zl
  ), "VerbosityLevel"),
  XfaLayer: /* @__PURE__ */ d(() => (
    /* reexport */
    sl
  ), "XfaLayer"),
  build: /* @__PURE__ */ d(() => (
    /* reexport */
    eb
  ), "build"),
  createValidAbsoluteUrl: /* @__PURE__ */ d(() => (
    /* reexport */
    Am
  ), "createValidAbsoluteUrl"),
  fetchData: /* @__PURE__ */ d(() => (
    /* reexport */
    Vl
  ), "fetchData"),
  getDocument: /* @__PURE__ */ d(() => (
    /* reexport */
    Qm
  ), "getDocument"),
  getFilenameFromUrl: /* @__PURE__ */ d(() => (
    /* reexport */
    Cm
  ), "getFilenameFromUrl"),
  getPdfFilenameFromUrl: /* @__PURE__ */ d(() => (
    /* reexport */
    xm
  ), "getPdfFilenameFromUrl"),
  getXfaPageViewport: /* @__PURE__ */ d(() => (
    /* reexport */
    Tm
  ), "getXfaPageViewport"),
  isDataScheme: /* @__PURE__ */ d(() => (
    /* reexport */
    Gl
  ), "isDataScheme"),
  isPdfFile: /* @__PURE__ */ d(() => (
    /* reexport */
    yu
  ), "isPdfFile"),
  noContextMenu: /* @__PURE__ */ d(() => (
    /* reexport */
    ee
  ), "noContextMenu"),
  normalizeUnicode: /* @__PURE__ */ d(() => (
    /* reexport */
    Em
  ), "normalizeUnicode"),
  setLayerDimensions: /* @__PURE__ */ d(() => (
    /* reexport */
    xn
  ), "setLayerDimensions"),
  shadow: /* @__PURE__ */ d(() => (
    /* reexport */
    X
  ), "shadow"),
  version: /* @__PURE__ */ d(() => (
    /* reexport */
    tb
  ), "version")
});
const $t = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser"), Ip = [1, 0, 0, 1, 0, 0], ec = [1e-3, 0, 0, 1e-3, 0, 0], dm = 1e7, Yl = 1.35, ue = {
  ANY: 1,
  DISPLAY: 2,
  PRINT: 4,
  SAVE: 8,
  ANNOTATIONS_FORMS: 16,
  ANNOTATIONS_STORAGE: 32,
  ANNOTATIONS_DISABLE: 64,
  IS_EDITING: 128,
  OPLIST: 256
}, Ys = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
}, um = "pdfjs_internal_editor_", G = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  HIGHLIGHT: 9,
  STAMP: 13,
  INK: 15
}, N = {
  RESIZE: 1,
  CREATE: 2,
  FREETEXT_SIZE: 11,
  FREETEXT_COLOR: 12,
  FREETEXT_OPACITY: 13,
  INK_COLOR: 21,
  INK_THICKNESS: 22,
  INK_OPACITY: 23,
  HIGHLIGHT_COLOR: 31,
  HIGHLIGHT_DEFAULT_COLOR: 32,
  HIGHLIGHT_THICKNESS: 33,
  HIGHLIGHT_FREE: 34,
  HIGHLIGHT_SHOW_ALL: 35
}, fm = {
  PRINT: 4,
  MODIFY_CONTENTS: 8,
  COPY: 16,
  MODIFY_ANNOTATIONS: 32,
  FILL_INTERACTIVE_FORMS: 256,
  COPY_FOR_ACCESSIBILITY: 512,
  ASSEMBLE: 1024,
  PRINT_HIGH_QUALITY: 2048
}, Nt = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
}, lh = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
}, bt = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
}, Or = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
}, zl = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
}, sc = {
  NONE: 0,
  BINARY: 1
}, Ee = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91,
  setStrokeTransparent: 92,
  setFillTransparent: 93
}, pm = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
let $l = zl.WARNINGS;
function gm(f) {
  Number.isInteger(f) && ($l = f);
}
d(gm, "setVerbosityLevel");
function mm() {
  return $l;
}
d(mm, "getVerbosityLevel");
function jl(f) {
  $l >= zl.INFOS && console.log(`Info: ${f}`);
}
d(jl, "info");
function $(f) {
  $l >= zl.WARNINGS && console.log(`Warning: ${f}`);
}
d($, "warn");
function et(f) {
  throw new Error(f);
}
d(et, "unreachable");
function _t(f, t) {
  f || et(t);
}
d(_t, "assert");
function bm(f) {
  switch (f == null ? void 0 : f.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return !0;
    default:
      return !1;
  }
}
d(bm, "_isValidProtocol");
function Am(f, t = null, e = null) {
  if (!f)
    return null;
  try {
    if (e && typeof f == "string") {
      if (e.addDefaultProtocol && f.startsWith("www.")) {
        const i = f.match(/\./g);
        (i == null ? void 0 : i.length) >= 2 && (f = `http://${f}`);
      }
      if (e.tryConvertEncoding)
        try {
          f = _m(f);
        } catch {
        }
    }
    const s = t ? new URL(f, t) : new URL(f);
    if (bm(s))
      return s;
  } catch {
  }
  return null;
}
d(Am, "createValidAbsoluteUrl");
function X(f, t, e, s = !1) {
  return Object.defineProperty(f, t, {
    value: e,
    enumerable: !s,
    configurable: !0,
    writable: !1
  }), e;
}
d(X, "shadow");
const yi = (/* @__PURE__ */ d(function() {
  function t(e, s) {
    this.constructor === t && et("Cannot initialize BaseException."), this.message = e, this.name = s;
  }
  return d(t, "BaseException"), t.prototype = new Error(), t.constructor = t, t;
}, "BaseExceptionClosure"))(), Su = class Su extends yi {
  constructor(t, e) {
    super(t, "PasswordException"), this.code = e;
  }
};
d(Su, "PasswordException");
let oa = Su;
const Cu = class Cu extends yi {
  constructor(t, e) {
    super(t, "UnknownErrorException"), this.details = e;
  }
};
d(Cu, "UnknownErrorException");
let ha = Cu;
const xu = class xu extends yi {
  constructor(t) {
    super(t, "InvalidPDFException");
  }
};
d(xu, "InvalidPDFException");
let Fh = xu;
const Tu = class Tu extends yi {
  constructor(t) {
    super(t, "MissingPDFException");
  }
};
d(Tu, "MissingPDFException");
let Hs = Tu;
const Lu = class Lu extends yi {
  constructor(t, e) {
    super(t, "UnexpectedResponseException"), this.status = e;
  }
};
d(Lu, "UnexpectedResponseException");
let Nr = Lu;
const Ru = class Ru extends yi {
  constructor(t) {
    super(t, "FormatError");
  }
};
d(Ru, "FormatError");
let ic = Ru;
const ku = class ku extends yi {
  constructor(t) {
    super(t, "AbortException");
  }
};
d(ku, "AbortException");
let Bs = ku;
function Pp(f) {
  (typeof f != "object" || (f == null ? void 0 : f.length) === void 0) && et("Invalid argument for bytesToString");
  const t = f.length, e = 8192;
  if (t < e)
    return String.fromCharCode.apply(null, f);
  const s = [];
  for (let i = 0; i < t; i += e) {
    const n = Math.min(i + e, t), a = f.subarray(i, n);
    s.push(String.fromCharCode.apply(null, a));
  }
  return s.join("");
}
d(Pp, "bytesToString");
function Wl(f) {
  typeof f != "string" && et("Invalid argument for stringToBytes");
  const t = f.length, e = new Uint8Array(t);
  for (let s = 0; s < t; ++s)
    e[s] = f.charCodeAt(s) & 255;
  return e;
}
d(Wl, "stringToBytes");
function vm(f) {
  return String.fromCharCode(f >> 24 & 255, f >> 16 & 255, f >> 8 & 255, f & 255);
}
d(vm, "string32");
function vu(f) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const [e, s] of f)
    t[e] = s;
  return t;
}
d(vu, "objectFromMap");
function ym() {
  const f = new Uint8Array(4);
  return f[0] = 1, new Uint32Array(f.buffer, 0, 1)[0] === 1;
}
d(ym, "isLittleEndian");
function wm() {
  try {
    return new Function(""), !0;
  } catch {
    return !1;
  }
}
d(wm, "isEvalSupported");
const Mu = class Mu {
  static get isLittleEndian() {
    return X(this, "isLittleEndian", ym());
  }
  static get isEvalSupported() {
    return X(this, "isEvalSupported", wm());
  }
  static get isOffscreenCanvasSupported() {
    return X(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
  }
  static get platform() {
    return typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.platform) == "string" ? X(this, "platform", {
      isMac: navigator.platform.includes("Mac")
    }) : X(this, "platform", {
      isMac: !1
    });
  }
  static get isCSSRoundSupported() {
    var t, e;
    return X(this, "isCSSRoundSupported", (e = (t = globalThis.CSS) == null ? void 0 : t.supports) == null ? void 0 : e.call(t, "width: round(1.5px, 1px)"));
  }
};
d(Mu, "util_FeatureTest");
let jt = Mu;
const Kl = Array.from(Array(256).keys(), (f) => f.toString(16).padStart(2, "0"));
var Ns, ch, nc;
const pl = class pl {
  static makeHexColor(t, e, s) {
    return `#${Kl[t]}${Kl[e]}${Kl[s]}`;
  }
  static scaleMinMax(t, e) {
    let s;
    t[0] ? (t[0] < 0 && (s = e[0], e[0] = e[2], e[2] = s), e[0] *= t[0], e[2] *= t[0], t[3] < 0 && (s = e[1], e[1] = e[3], e[3] = s), e[1] *= t[3], e[3] *= t[3]) : (s = e[0], e[0] = e[1], e[1] = s, s = e[2], e[2] = e[3], e[3] = s, t[1] < 0 && (s = e[1], e[1] = e[3], e[3] = s), e[1] *= t[1], e[3] *= t[1], t[2] < 0 && (s = e[0], e[0] = e[2], e[2] = s), e[0] *= t[2], e[2] *= t[2]), e[0] += t[4], e[1] += t[5], e[2] += t[4], e[3] += t[5];
  }
  static transform(t, e) {
    return [t[0] * e[0] + t[2] * e[1], t[1] * e[0] + t[3] * e[1], t[0] * e[2] + t[2] * e[3], t[1] * e[2] + t[3] * e[3], t[0] * e[4] + t[2] * e[5] + t[4], t[1] * e[4] + t[3] * e[5] + t[5]];
  }
  static applyTransform(t, e) {
    const s = t[0] * e[0] + t[1] * e[2] + e[4], i = t[0] * e[1] + t[1] * e[3] + e[5];
    return [s, i];
  }
  static applyInverseTransform(t, e) {
    const s = e[0] * e[3] - e[1] * e[2], i = (t[0] * e[3] - t[1] * e[2] + e[2] * e[5] - e[4] * e[3]) / s, n = (-t[0] * e[1] + t[1] * e[0] + e[4] * e[1] - e[5] * e[0]) / s;
    return [i, n];
  }
  static getAxialAlignedBoundingBox(t, e) {
    const s = this.applyTransform(t, e), i = this.applyTransform(t.slice(2, 4), e), n = this.applyTransform([t[0], t[3]], e), a = this.applyTransform([t[2], t[1]], e);
    return [Math.min(s[0], i[0], n[0], a[0]), Math.min(s[1], i[1], n[1], a[1]), Math.max(s[0], i[0], n[0], a[0]), Math.max(s[1], i[1], n[1], a[1])];
  }
  static inverseTransform(t) {
    const e = t[0] * t[3] - t[1] * t[2];
    return [t[3] / e, -t[1] / e, -t[2] / e, t[0] / e, (t[2] * t[5] - t[4] * t[3]) / e, (t[4] * t[1] - t[5] * t[0]) / e];
  }
  static singularValueDecompose2dScale(t) {
    const e = [t[0], t[2], t[1], t[3]], s = t[0] * e[0] + t[1] * e[2], i = t[0] * e[1] + t[1] * e[3], n = t[2] * e[0] + t[3] * e[2], a = t[2] * e[1] + t[3] * e[3], o = (s + a) / 2, h = Math.sqrt((s + a) ** 2 - 4 * (s * a - n * i)) / 2, l = o + h || 1, c = o - h || 1;
    return [Math.sqrt(l), Math.sqrt(c)];
  }
  static normalizeRect(t) {
    const e = t.slice(0);
    return t[0] > t[2] && (e[0] = t[2], e[2] = t[0]), t[1] > t[3] && (e[1] = t[3], e[3] = t[1]), e;
  }
  static intersect(t, e) {
    const s = Math.max(Math.min(t[0], t[2]), Math.min(e[0], e[2])), i = Math.min(Math.max(t[0], t[2]), Math.max(e[0], e[2]));
    if (s > i)
      return null;
    const n = Math.max(Math.min(t[1], t[3]), Math.min(e[1], e[3])), a = Math.min(Math.max(t[1], t[3]), Math.max(e[1], e[3]));
    return n > a ? null : [s, n, i, a];
  }
  static bezierBoundingBox(t, e, s, i, n, a, o, h, l) {
    return l ? (l[0] = Math.min(l[0], t, o), l[1] = Math.min(l[1], e, h), l[2] = Math.max(l[2], t, o), l[3] = Math.max(l[3], e, h)) : l = [Math.min(t, o), Math.min(e, h), Math.max(t, o), Math.max(e, h)], m(this, Ns, nc).call(this, t, s, n, o, e, i, a, h, 3 * (-t + 3 * (s - n) + o), 6 * (t - 2 * s + n), 3 * (s - t), l), m(this, Ns, nc).call(this, t, s, n, o, e, i, a, h, 3 * (-e + 3 * (i - a) + h), 6 * (e - 2 * i + a), 3 * (i - e), l), l;
  }
};
Ns = new WeakSet(), ch = /* @__PURE__ */ d(function(t, e, s, i, n, a, o, h, l, c) {
  if (l <= 0 || l >= 1)
    return;
  const u = 1 - l, p = l * l, b = p * l, v = u * (u * (u * t + 3 * l * e) + 3 * p * s) + b * i, y = u * (u * (u * n + 3 * l * a) + 3 * p * o) + b * h;
  c[0] = Math.min(c[0], v), c[1] = Math.min(c[1], y), c[2] = Math.max(c[2], v), c[3] = Math.max(c[3], y);
}, "#getExtremumOnCurve"), nc = /* @__PURE__ */ d(function(t, e, s, i, n, a, o, h, l, c, u, p) {
  if (Math.abs(l) < 1e-12) {
    Math.abs(c) >= 1e-12 && m(this, Ns, ch).call(this, t, e, s, i, n, a, o, h, -u / c, p);
    return;
  }
  const b = c ** 2 - 4 * u * l;
  if (b < 0)
    return;
  const v = Math.sqrt(b), y = 2 * l;
  m(this, Ns, ch).call(this, t, e, s, i, n, a, o, h, (-c + v) / y, p), m(this, Ns, ch).call(this, t, e, s, i, n, a, o, h, (-c - v) / y, p);
}, "#getExtremum"), A(pl, Ns), d(pl, "Util");
let I = pl;
function _m(f) {
  return decodeURIComponent(escape(f));
}
d(_m, "stringToUTF8String");
let Ql = null, bp = null;
function Em(f) {
  return Ql || (Ql = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, bp = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), f.replaceAll(Ql, (t, e, s) => e ? e.normalize("NFKC") : bp.get(s));
}
d(Em, "normalizeUnicode");
function Sm() {
  if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.randomUUID) == "function")
    return crypto.randomUUID();
  const f = new Uint8Array(32);
  if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.getRandomValues) == "function")
    crypto.getRandomValues(f);
  else
    for (let t = 0; t < 32; t++)
      f[t] = Math.floor(Math.random() * 255);
  return Pp(f);
}
d(Sm, "getUuid");
const Dp = "pdfjs_internal_id_", as = {
  BEZIER_CURVE_TO: 0,
  MOVE_TO: 1,
  LINE_TO: 2,
  QUADRATIC_CURVE_TO: 3,
  RESTORE: 4,
  SAVE: 5,
  SCALE: 6,
  TRANSFORM: 7,
  TRANSLATE: 8
}, gl = class gl {
  constructor() {
    this.constructor === gl && et("Cannot initialize BaseFilterFactory.");
  }
  addFilter(t) {
    return "none";
  }
  addHCMFilter(t, e) {
    return "none";
  }
  addAlphaFilter(t) {
    return "none";
  }
  addLuminosityFilter(t) {
    return "none";
  }
  addHighlightHCMFilter(t, e, s, i, n) {
    return "none";
  }
  destroy(t = !1) {
  }
};
d(gl, "BaseFilterFactory");
let Nh = gl;
var Aa;
const ml = class ml {
  constructor({
    enableHWA: t = !1
  } = {}) {
    A(this, Aa, !1);
    this.constructor === ml && et("Cannot initialize BaseCanvasFactory."), g(this, Aa, t);
  }
  create(t, e) {
    if (t <= 0 || e <= 0)
      throw new Error("Invalid canvas size");
    const s = this._createCanvas(t, e);
    return {
      canvas: s,
      context: s.getContext("2d", {
        willReadFrequently: !r(this, Aa)
      })
    };
  }
  reset(t, e, s) {
    if (!t.canvas)
      throw new Error("Canvas is not specified");
    if (e <= 0 || s <= 0)
      throw new Error("Invalid canvas size");
    t.canvas.width = e, t.canvas.height = s;
  }
  destroy(t) {
    if (!t.canvas)
      throw new Error("Canvas is not specified");
    t.canvas.width = 0, t.canvas.height = 0, t.canvas = null, t.context = null;
  }
  _createCanvas(t, e) {
    et("Abstract method `_createCanvas` called.");
  }
};
Aa = new WeakMap(), d(ml, "BaseCanvasFactory");
let Oh = ml;
const bl = class bl {
  constructor({
    baseUrl: t = null,
    isCompressed: e = !0
  }) {
    this.constructor === bl && et("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = t, this.isCompressed = e;
  }
  async fetch({
    name: t
  }) {
    if (!this.baseUrl)
      throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
    if (!t)
      throw new Error("CMap name must be specified.");
    const e = this.baseUrl + t + (this.isCompressed ? ".bcmap" : ""), s = this.isCompressed ? sc.BINARY : sc.NONE;
    return this._fetchData(e, s).catch((i) => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${e}`);
    });
  }
  _fetchData(t, e) {
    et("Abstract method `_fetchData` called.");
  }
};
d(bl, "BaseCMapReaderFactory");
let Hh = bl;
const Al = class Al {
  constructor({
    baseUrl: t = null
  }) {
    this.constructor === Al && et("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = t;
  }
  async fetch({
    filename: t
  }) {
    if (!this.baseUrl)
      throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
    if (!t)
      throw new Error("Font filename must be specified.");
    const e = `${this.baseUrl}${t}`;
    return this._fetchData(e).catch((s) => {
      throw new Error(`Unable to load font data at: ${e}`);
    });
  }
  _fetchData(t) {
    et("Abstract method `_fetchData` called.");
  }
};
d(Al, "BaseStandardFontDataFactory");
let Bh = Al;
const vl = class vl {
  constructor() {
    this.constructor === vl && et("Cannot initialize BaseSVGFactory.");
  }
  create(t, e, s = !1) {
    if (t <= 0 || e <= 0)
      throw new Error("Invalid SVG dimensions");
    const i = this._createSVG("svg:svg");
    return i.setAttribute("version", "1.1"), s || (i.setAttribute("width", `${t}px`), i.setAttribute("height", `${e}px`)), i.setAttribute("preserveAspectRatio", "none"), i.setAttribute("viewBox", `0 0 ${t} ${e}`), i;
  }
  createElement(t) {
    if (typeof t != "string")
      throw new Error("Invalid SVG element type");
    return this._createSVG(t);
  }
  _createSVG(t) {
    et("Abstract method `_createSVG` called.");
  }
};
d(vl, "BaseSVGFactory");
let rc = vl;
const hs = "http://www.w3.org/2000/svg", qs = class qs {
};
d(qs, "PixelsPerInch"), U(qs, "CSS", 96), U(qs, "PDF", 72), U(qs, "PDF_TO_CSS_UNITS", qs.CSS / qs.PDF);
let bi = qs;
var Ti, Li, ze, cs, Ht, yl, Ri, M, Ot, In, Pn, dh, Dn, Fp, oc, Fn, Ur, zr, hc, $r;
const Iu = class Iu extends Nh {
  constructor({
    docId: e,
    ownerDocument: s = globalThis.document
  } = {}) {
    super();
    A(this, M);
    A(this, Ti);
    A(this, Li);
    A(this, ze);
    A(this, cs);
    A(this, Ht);
    A(this, yl);
    A(this, Ri, 0);
    g(this, cs, e), g(this, Ht, s);
  }
  addFilter(e) {
    if (!e)
      return "none";
    let s = r(this, M, Ot).get(e);
    if (s)
      return s;
    const [i, n, a] = m(this, M, dh).call(this, e), o = e.length === 1 ? i : `${i}${n}${a}`;
    if (s = r(this, M, Ot).get(o), s)
      return r(this, M, Ot).set(e, s), s;
    const h = `g_${r(this, cs)}_transfer_map_${se(this, Ri)._++}`, l = m(this, M, Dn).call(this, h);
    r(this, M, Ot).set(e, l), r(this, M, Ot).set(o, l);
    const c = m(this, M, Fn).call(this, h);
    return m(this, M, zr).call(this, i, n, a, c), l;
  }
  addHCMFilter(e, s) {
    var v;
    const i = `${e}-${s}`, n = "base";
    let a = r(this, M, In).get(n);
    if ((a == null ? void 0 : a.key) === i || (a ? ((v = a.filter) == null || v.remove(), a.key = i, a.url = "none", a.filter = null) : (a = {
      key: i,
      url: "none",
      filter: null
    }, r(this, M, In).set(n, a)), !e || !s))
      return a.url;
    const o = m(this, M, $r).call(this, e);
    e = I.makeHexColor(...o);
    const h = m(this, M, $r).call(this, s);
    if (s = I.makeHexColor(...h), r(this, M, Pn).style.color = "", e === "#000000" && s === "#ffffff" || e === s)
      return a.url;
    const l = new Array(256);
    for (let y = 0; y <= 255; y++) {
      const _ = y / 255;
      l[y] = _ <= 0.03928 ? _ / 12.92 : ((_ + 0.055) / 1.055) ** 2.4;
    }
    const c = l.join(","), u = `g_${r(this, cs)}_hcm_filter`, p = a.filter = m(this, M, Fn).call(this, u);
    m(this, M, zr).call(this, c, c, c, p), m(this, M, oc).call(this, p);
    const b = /* @__PURE__ */ d((y, _) => {
      const w = o[y] / 255, E = h[y] / 255, S = new Array(_ + 1);
      for (let C = 0; C <= _; C++)
        S[C] = w + C / _ * (E - w);
      return S.join(",");
    }, "getSteps");
    return m(this, M, zr).call(this, b(0, 5), b(1, 5), b(2, 5), p), a.url = m(this, M, Dn).call(this, u), a.url;
  }
  addAlphaFilter(e) {
    let s = r(this, M, Ot).get(e);
    if (s)
      return s;
    const [i] = m(this, M, dh).call(this, [e]), n = `alpha_${i}`;
    if (s = r(this, M, Ot).get(n), s)
      return r(this, M, Ot).set(e, s), s;
    const a = `g_${r(this, cs)}_alpha_map_${se(this, Ri)._++}`, o = m(this, M, Dn).call(this, a);
    r(this, M, Ot).set(e, o), r(this, M, Ot).set(n, o);
    const h = m(this, M, Fn).call(this, a);
    return m(this, M, hc).call(this, i, h), o;
  }
  addLuminosityFilter(e) {
    let s = r(this, M, Ot).get(e || "luminosity");
    if (s)
      return s;
    let i, n;
    if (e ? ([i] = m(this, M, dh).call(this, [e]), n = `luminosity_${i}`) : n = "luminosity", s = r(this, M, Ot).get(n), s)
      return r(this, M, Ot).set(e, s), s;
    const a = `g_${r(this, cs)}_luminosity_map_${se(this, Ri)._++}`, o = m(this, M, Dn).call(this, a);
    r(this, M, Ot).set(e, o), r(this, M, Ot).set(n, o);
    const h = m(this, M, Fn).call(this, a);
    return m(this, M, Fp).call(this, h), e && m(this, M, hc).call(this, i, h), o;
  }
  addHighlightHCMFilter(e, s, i, n, a) {
    var E;
    const o = `${s}-${i}-${n}-${a}`;
    let h = r(this, M, In).get(e);
    if ((h == null ? void 0 : h.key) === o || (h ? ((E = h.filter) == null || E.remove(), h.key = o, h.url = "none", h.filter = null) : (h = {
      key: o,
      url: "none",
      filter: null
    }, r(this, M, In).set(e, h)), !s || !i))
      return h.url;
    const [l, c] = [s, i].map(m(this, M, $r).bind(this));
    let u = Math.round(0.2126 * l[0] + 0.7152 * l[1] + 0.0722 * l[2]), p = Math.round(0.2126 * c[0] + 0.7152 * c[1] + 0.0722 * c[2]), [b, v] = [n, a].map(m(this, M, $r).bind(this));
    p < u && ([u, p, b, v] = [p, u, v, b]), r(this, M, Pn).style.color = "";
    const y = /* @__PURE__ */ d((S, C, T) => {
      const x = new Array(256), k = (p - u) / T, P = S / 255, O = (C - S) / (255 * T);
      let q = 0;
      for (let F = 0; F <= T; F++) {
        const ht = Math.round(u + F * k), rt = P + F * O;
        for (let at = q; at <= ht; at++)
          x[at] = rt;
        q = ht + 1;
      }
      for (let F = q; F < 256; F++)
        x[F] = x[q - 1];
      return x.join(",");
    }, "getSteps"), _ = `g_${r(this, cs)}_hcm_${e}_filter`, w = h.filter = m(this, M, Fn).call(this, _);
    return m(this, M, oc).call(this, w), m(this, M, zr).call(this, y(b[0], v[0], 5), y(b[1], v[1], 5), y(b[2], v[2], 5), w), h.url = m(this, M, Dn).call(this, _), h.url;
  }
  destroy(e = !1) {
    e && r(this, M, In).size !== 0 || (r(this, ze) && (r(this, ze).parentNode.parentNode.remove(), g(this, ze, null)), r(this, Li) && (r(this, Li).clear(), g(this, Li, null)), g(this, Ri, 0));
  }
};
Ti = new WeakMap(), Li = new WeakMap(), ze = new WeakMap(), cs = new WeakMap(), Ht = new WeakMap(), yl = new WeakMap(), Ri = new WeakMap(), M = new WeakSet(), Ot = /* @__PURE__ */ d(function() {
  return r(this, Li) || g(this, Li, /* @__PURE__ */ new Map());
}, "#cache"), In = /* @__PURE__ */ d(function() {
  return r(this, yl) || g(this, yl, /* @__PURE__ */ new Map());
}, "#hcmCache"), Pn = /* @__PURE__ */ d(function() {
  if (!r(this, ze)) {
    const e = r(this, Ht).createElement("div"), {
      style: s
    } = e;
    s.visibility = "hidden", s.contain = "strict", s.width = s.height = 0, s.position = "absolute", s.top = s.left = 0, s.zIndex = -1;
    const i = r(this, Ht).createElementNS(hs, "svg");
    i.setAttribute("width", 0), i.setAttribute("height", 0), g(this, ze, r(this, Ht).createElementNS(hs, "defs")), e.append(i), i.append(r(this, ze)), r(this, Ht).body.append(e);
  }
  return r(this, ze);
}, "#defs"), dh = /* @__PURE__ */ d(function(e) {
  if (e.length === 1) {
    const l = e[0], c = new Array(256);
    for (let p = 0; p < 256; p++)
      c[p] = l[p] / 255;
    const u = c.join(",");
    return [u, u, u];
  }
  const [s, i, n] = e, a = new Array(256), o = new Array(256), h = new Array(256);
  for (let l = 0; l < 256; l++)
    a[l] = s[l] / 255, o[l] = i[l] / 255, h[l] = n[l] / 255;
  return [a.join(","), o.join(","), h.join(",")];
}, "#createTables"), Dn = /* @__PURE__ */ d(function(e) {
  if (r(this, Ti) === void 0) {
    g(this, Ti, "");
    const s = r(this, Ht).URL;
    s !== r(this, Ht).baseURI && (Gl(s) ? $('#createUrl: ignore "data:"-URL for performance reasons.') : g(this, Ti, s.split("#", 1)[0]));
  }
  return `url(${r(this, Ti)}#${e})`;
}, "#createUrl"), Fp = /* @__PURE__ */ d(function(e) {
  const s = r(this, Ht).createElementNS(hs, "feColorMatrix");
  s.setAttribute("type", "matrix"), s.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0"), e.append(s);
}, "#addLuminosityConversion"), oc = /* @__PURE__ */ d(function(e) {
  const s = r(this, Ht).createElementNS(hs, "feColorMatrix");
  s.setAttribute("type", "matrix"), s.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), e.append(s);
}, "#addGrayConversion"), Fn = /* @__PURE__ */ d(function(e) {
  const s = r(this, Ht).createElementNS(hs, "filter");
  return s.setAttribute("color-interpolation-filters", "sRGB"), s.setAttribute("id", e), r(this, M, Pn).append(s), s;
}, "#createFilter"), Ur = /* @__PURE__ */ d(function(e, s, i) {
  const n = r(this, Ht).createElementNS(hs, s);
  n.setAttribute("type", "discrete"), n.setAttribute("tableValues", i), e.append(n);
}, "#appendFeFunc"), zr = /* @__PURE__ */ d(function(e, s, i, n) {
  const a = r(this, Ht).createElementNS(hs, "feComponentTransfer");
  n.append(a), m(this, M, Ur).call(this, a, "feFuncR", e), m(this, M, Ur).call(this, a, "feFuncG", s), m(this, M, Ur).call(this, a, "feFuncB", i);
}, "#addTransferMapConversion"), hc = /* @__PURE__ */ d(function(e, s) {
  const i = r(this, Ht).createElementNS(hs, "feComponentTransfer");
  s.append(i), m(this, M, Ur).call(this, i, "feFuncA", e);
}, "#addTransferMapAlphaConversion"), $r = /* @__PURE__ */ d(function(e) {
  return r(this, M, Pn).style.color = e, wu(getComputedStyle(r(this, M, Pn)).getPropertyValue("color"));
}, "#getRGB"), d(Iu, "DOMFilterFactory");
let ac = Iu;
const Pu = class Pu extends Oh {
  constructor({
    ownerDocument: t = globalThis.document,
    enableHWA: e = !1
  } = {}) {
    super({
      enableHWA: e
    }), this._document = t;
  }
  _createCanvas(t, e) {
    const s = this._document.createElement("canvas");
    return s.width = t, s.height = e, s;
  }
};
d(Pu, "DOMCanvasFactory");
let lc = Pu;
async function Vl(f, t = "text") {
  if (jr(f, document.baseURI)) {
    const e = await fetch(f);
    if (!e.ok)
      throw new Error(e.statusText);
    switch (t) {
      case "arraybuffer":
        return e.arrayBuffer();
      case "blob":
        return e.blob();
      case "json":
        return e.json();
    }
    return e.text();
  }
  return new Promise((e, s) => {
    const i = new XMLHttpRequest();
    i.open("GET", f, !0), i.responseType = t, i.onreadystatechange = () => {
      if (i.readyState === XMLHttpRequest.DONE) {
        if (i.status === 200 || i.status === 0) {
          switch (t) {
            case "arraybuffer":
            case "blob":
            case "json":
              e(i.response);
              return;
          }
          e(i.responseText);
          return;
        }
        s(new Error(i.statusText));
      }
    }, i.send(null);
  });
}
d(Vl, "fetchData");
const Du = class Du extends Hh {
  _fetchData(t, e) {
    return Vl(t, this.isCompressed ? "arraybuffer" : "text").then((s) => ({
      cMapData: s instanceof ArrayBuffer ? new Uint8Array(s) : Wl(s),
      compressionType: e
    }));
  }
};
d(Du, "DOMCMapReaderFactory");
let Uh = Du;
const Fu = class Fu extends Bh {
  _fetchData(t) {
    return Vl(t, "arraybuffer").then((e) => new Uint8Array(e));
  }
};
d(Fu, "DOMStandardFontDataFactory");
let zh = Fu;
const Nu = class Nu extends rc {
  _createSVG(t) {
    return document.createElementNS(hs, t);
  }
};
d(Nu, "DOMSVGFactory");
let la = Nu;
const wl = class wl {
  constructor({
    viewBox: t,
    scale: e,
    rotation: s,
    offsetX: i = 0,
    offsetY: n = 0,
    dontFlip: a = !1
  }) {
    this.viewBox = t, this.scale = e, this.rotation = s, this.offsetX = i, this.offsetY = n;
    const o = (t[2] + t[0]) / 2, h = (t[3] + t[1]) / 2;
    let l, c, u, p;
    switch (s %= 360, s < 0 && (s += 360), s) {
      case 180:
        l = -1, c = 0, u = 0, p = 1;
        break;
      case 90:
        l = 0, c = 1, u = 1, p = 0;
        break;
      case 270:
        l = 0, c = -1, u = -1, p = 0;
        break;
      case 0:
        l = 1, c = 0, u = 0, p = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    a && (u = -u, p = -p);
    let b, v, y, _;
    l === 0 ? (b = Math.abs(h - t[1]) * e + i, v = Math.abs(o - t[0]) * e + n, y = (t[3] - t[1]) * e, _ = (t[2] - t[0]) * e) : (b = Math.abs(o - t[0]) * e + i, v = Math.abs(h - t[1]) * e + n, y = (t[2] - t[0]) * e, _ = (t[3] - t[1]) * e), this.transform = [l * e, c * e, u * e, p * e, b - l * e * o - u * e * h, v - c * e * o - p * e * h], this.width = y, this.height = _;
  }
  get rawDims() {
    const {
      viewBox: t
    } = this;
    return X(this, "rawDims", {
      pageWidth: t[2] - t[0],
      pageHeight: t[3] - t[1],
      pageX: t[0],
      pageY: t[1]
    });
  }
  clone({
    scale: t = this.scale,
    rotation: e = this.rotation,
    offsetX: s = this.offsetX,
    offsetY: i = this.offsetY,
    dontFlip: n = !1
  } = {}) {
    return new wl({
      viewBox: this.viewBox.slice(),
      scale: t,
      rotation: e,
      offsetX: s,
      offsetY: i,
      dontFlip: n
    });
  }
  convertToViewportPoint(t, e) {
    return I.applyTransform([t, e], this.transform);
  }
  convertToViewportRectangle(t) {
    const e = I.applyTransform([t[0], t[1]], this.transform), s = I.applyTransform([t[2], t[3]], this.transform);
    return [e[0], e[1], s[0], s[1]];
  }
  convertToPdfPoint(t, e) {
    return I.applyInverseTransform([t, e], this.transform);
  }
};
d(wl, "PageViewport");
let ca = wl;
const Ou = class Ou extends yi {
  constructor(t, e = 0) {
    super(t, "RenderingCancelledException"), this.extraDelay = e;
  }
};
d(Ou, "RenderingCancelledException");
let da = Ou;
function Gl(f) {
  const t = f.length;
  let e = 0;
  for (; e < t && f[e].trim() === ""; )
    e++;
  return f.substring(e, e + 5).toLowerCase() === "data:";
}
d(Gl, "isDataScheme");
function yu(f) {
  return typeof f == "string" && /\.pdf$/i.test(f);
}
d(yu, "isPdfFile");
function Cm(f) {
  return [f] = f.split(/[#?]/, 1), f.substring(f.lastIndexOf("/") + 1);
}
d(Cm, "getFilenameFromUrl");
function xm(f, t = "document.pdf") {
  if (typeof f != "string")
    return t;
  if (Gl(f))
    return $('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), t;
  const e = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, s = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, i = e.exec(f);
  let n = s.exec(i[1]) || s.exec(i[2]) || s.exec(i[3]);
  if (n && (n = n[0], n.includes("%")))
    try {
      n = s.exec(decodeURIComponent(n))[0];
    } catch {
    }
  return n || t;
}
d(xm, "getPdfFilenameFromUrl");
const Hu = class Hu {
  constructor() {
    U(this, "started", /* @__PURE__ */ Object.create(null));
    U(this, "times", []);
  }
  time(t) {
    t in this.started && $(`Timer is already running for ${t}`), this.started[t] = Date.now();
  }
  timeEnd(t) {
    t in this.started || $(`Timer has not been started for ${t}`), this.times.push({
      name: t,
      start: this.started[t],
      end: Date.now()
    }), delete this.started[t];
  }
  toString() {
    const t = [];
    let e = 0;
    for (const {
      name: s
    } of this.times)
      e = Math.max(s.length, e);
    for (const {
      name: s,
      start: i,
      end: n
    } of this.times)
      t.push(`${s.padEnd(e)} ${n - i}ms
`);
    return t.join("");
  }
};
d(Hu, "StatTimer");
let $h = Hu;
function jr(f, t) {
  try {
    const {
      protocol: e
    } = t ? new URL(f, t) : new URL(f);
    return e === "http:" || e === "https:";
  } catch {
    return !1;
  }
}
d(jr, "isValidFetchUrl");
function ee(f) {
  f.preventDefault();
}
d(ee, "noContextMenu");
let Ap;
const Bu = class Bu {
  static toDateObject(t) {
    if (!t || typeof t != "string")
      return null;
    Ap || (Ap = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
    const e = Ap.exec(t);
    if (!e)
      return null;
    const s = parseInt(e[1], 10);
    let i = parseInt(e[2], 10);
    i = i >= 1 && i <= 12 ? i - 1 : 0;
    let n = parseInt(e[3], 10);
    n = n >= 1 && n <= 31 ? n : 1;
    let a = parseInt(e[4], 10);
    a = a >= 0 && a <= 23 ? a : 0;
    let o = parseInt(e[5], 10);
    o = o >= 0 && o <= 59 ? o : 0;
    let h = parseInt(e[6], 10);
    h = h >= 0 && h <= 59 ? h : 0;
    const l = e[7] || "Z";
    let c = parseInt(e[8], 10);
    c = c >= 0 && c <= 23 ? c : 0;
    let u = parseInt(e[9], 10) || 0;
    return u = u >= 0 && u <= 59 ? u : 0, l === "-" ? (a += c, o += u) : l === "+" && (a -= c, o -= u), new Date(Date.UTC(s, i, n, a, o, h));
  }
};
d(Bu, "PDFDateString");
let jh = Bu;
function Tm(f, {
  scale: t = 1,
  rotation: e = 0
}) {
  const {
    width: s,
    height: i
  } = f.attributes.style, n = [0, 0, parseInt(s), parseInt(i)];
  return new ca({
    viewBox: n,
    scale: t,
    rotation: e
  });
}
d(Tm, "getXfaPageViewport");
function wu(f) {
  if (f.startsWith("#")) {
    const t = parseInt(f.slice(1), 16);
    return [(t & 16711680) >> 16, (t & 65280) >> 8, t & 255];
  }
  return f.startsWith("rgb(") ? f.slice(4, -1).split(",").map((t) => parseInt(t)) : f.startsWith("rgba(") ? f.slice(5, -1).split(",").map((t) => parseInt(t)).slice(0, 3) : ($(`Not a valid color format: "${f}"`), [0, 0, 0]);
}
d(wu, "getRGB");
function Lm(f) {
  const t = document.createElement("span");
  t.style.visibility = "hidden", document.body.append(t);
  for (const e of f.keys()) {
    t.style.color = e;
    const s = window.getComputedStyle(t).color;
    f.set(e, wu(s));
  }
  t.remove();
}
d(Lm, "getColorValues");
function ct(f) {
  const {
    a: t,
    b: e,
    c: s,
    d: i,
    e: n,
    f: a
  } = f.getTransform();
  return [t, e, s, i, n, a];
}
d(ct, "getCurrentTransform");
function os(f) {
  const {
    a: t,
    b: e,
    c: s,
    d: i,
    e: n,
    f: a
  } = f.getTransform().invertSelf();
  return [t, e, s, i, n, a];
}
d(os, "getCurrentTransformInverse");
function xn(f, t, e = !1, s = !0) {
  if (t instanceof ca) {
    const {
      pageWidth: i,
      pageHeight: n
    } = t.rawDims, {
      style: a
    } = f, o = jt.isCSSRoundSupported, h = `var(--scale-factor) * ${i}px`, l = `var(--scale-factor) * ${n}px`, c = o ? `round(${h}, 1px)` : `calc(${h})`, u = o ? `round(${l}, 1px)` : `calc(${l})`;
    !e || t.rotation % 180 === 0 ? (a.width = c, a.height = u) : (a.width = u, a.height = c);
  }
  s && f.setAttribute("data-main-rotation", t.rotation);
}
d(xn, "setLayerDimensions");
var ki, Mi, ne, Ii, _l, Np, Xt, Op, Hp, uh, Bp, dc;
const sa = class sa {
  constructor(t) {
    A(this, Xt);
    A(this, ki, null);
    A(this, Mi, null);
    A(this, ne);
    A(this, Ii, null);
    g(this, ne, t);
  }
  render() {
    const t = g(this, ki, document.createElement("div"));
    t.className = "editToolbar", t.setAttribute("role", "toolbar");
    const e = r(this, ne)._uiManager._signal;
    t.addEventListener("contextmenu", ee, {
      signal: e
    }), t.addEventListener("pointerdown", m(sa, _l, Np), {
      signal: e
    });
    const s = g(this, Ii, document.createElement("div"));
    s.className = "buttons", t.append(s);
    const i = r(this, ne).toolbarPosition;
    if (i) {
      const {
        style: n
      } = t, a = r(this, ne)._uiManager.direction === "ltr" ? 1 - i[0] : i[0];
      n.insetInlineEnd = `${100 * a}%`, n.top = `calc(${100 * i[1]}% + var(--editor-toolbar-vert-offset))`;
    }
    return m(this, Xt, Bp).call(this), t;
  }
  hide() {
    var t;
    r(this, ki).classList.add("hidden"), (t = r(this, Mi)) == null || t.hideDropdown();
  }
  show() {
    r(this, ki).classList.remove("hidden");
  }
  addAltTextButton(t) {
    m(this, Xt, uh).call(this, t), r(this, Ii).prepend(t, r(this, Xt, dc));
  }
  addColorPicker(t) {
    g(this, Mi, t);
    const e = t.renderButton();
    m(this, Xt, uh).call(this, e), r(this, Ii).prepend(e, r(this, Xt, dc));
  }
  remove() {
    var t;
    r(this, ki).remove(), (t = r(this, Mi)) == null || t.destroy(), g(this, Mi, null);
  }
};
ki = new WeakMap(), Mi = new WeakMap(), ne = new WeakMap(), Ii = new WeakMap(), _l = new WeakSet(), Np = /* @__PURE__ */ d(function(t) {
  t.stopPropagation();
}, "#pointerDown"), Xt = new WeakSet(), Op = /* @__PURE__ */ d(function(t) {
  r(this, ne)._focusEventsAllowed = !1, t.preventDefault(), t.stopPropagation();
}, "#focusIn"), Hp = /* @__PURE__ */ d(function(t) {
  r(this, ne)._focusEventsAllowed = !0, t.preventDefault(), t.stopPropagation();
}, "#focusOut"), uh = /* @__PURE__ */ d(function(t) {
  const e = r(this, ne)._uiManager._signal;
  t.addEventListener("focusin", m(this, Xt, Op).bind(this), {
    capture: !0,
    signal: e
  }), t.addEventListener("focusout", m(this, Xt, Hp).bind(this), {
    capture: !0,
    signal: e
  }), t.addEventListener("contextmenu", ee, {
    signal: e
  });
}, "#addListenersToElement"), Bp = /* @__PURE__ */ d(function() {
  const t = document.createElement("button");
  t.className = "delete", t.tabIndex = 0, t.setAttribute("data-l10n-id", `pdfjs-editor-remove-${r(this, ne).editorType}-button`), m(this, Xt, uh).call(this, t), t.addEventListener("click", (e) => {
    r(this, ne)._uiManager.delete();
  }, {
    signal: r(this, ne)._uiManager._signal
  }), r(this, Ii).append(t);
}, "#addDeleteButton"), dc = /* @__PURE__ */ d(function() {
  const t = document.createElement("div");
  return t.className = "divider", t;
}, "#divider"), A(sa, _l), d(sa, "EditorToolbar");
let cc = sa;
var va, Pi, Di, Ai, Up, zp, $p;
const Uu = class Uu {
  constructor(t) {
    A(this, Ai);
    A(this, va, null);
    A(this, Pi, null);
    A(this, Di);
    g(this, Di, t);
  }
  show(t, e, s) {
    const [i, n] = m(this, Ai, zp).call(this, e, s), {
      style: a
    } = r(this, Pi) || g(this, Pi, m(this, Ai, Up).call(this));
    t.append(r(this, Pi)), a.insetInlineEnd = `${100 * i}%`, a.top = `calc(${100 * n}% + var(--editor-toolbar-vert-offset))`;
  }
  hide() {
    r(this, Pi).remove();
  }
};
va = new WeakMap(), Pi = new WeakMap(), Di = new WeakMap(), Ai = new WeakSet(), Up = /* @__PURE__ */ d(function() {
  const t = g(this, Pi, document.createElement("div"));
  t.className = "editToolbar", t.setAttribute("role", "toolbar"), t.addEventListener("contextmenu", ee, {
    signal: r(this, Di)._signal
  });
  const e = g(this, va, document.createElement("div"));
  return e.className = "buttons", t.append(e), m(this, Ai, $p).call(this), t;
}, "#render"), zp = /* @__PURE__ */ d(function(t, e) {
  let s = 0, i = 0;
  for (const n of t) {
    const a = n.y + n.height;
    if (a < s)
      continue;
    const o = n.x + (e ? n.width : 0);
    if (a > s) {
      i = o, s = a;
      continue;
    }
    e ? o > i && (i = o) : o < i && (i = o);
  }
  return [e ? 1 - i : i, s];
}, "#getLastPoint"), $p = /* @__PURE__ */ d(function() {
  const t = document.createElement("button");
  t.className = "highlightButton", t.tabIndex = 0, t.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button1");
  const e = document.createElement("span");
  t.append(e), e.className = "visuallyHidden", e.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label");
  const s = r(this, Di)._signal;
  t.addEventListener("contextmenu", ee, {
    signal: s
  }), t.addEventListener("click", () => {
    r(this, Di).highlightSelection("floating_button");
  }, {
    signal: s
  }), r(this, va).append(t);
}, "#addHighlightButton"), d(Uu, "HighlightToolbar");
let uc = Uu;
function Wh(f, t, e) {
  for (const s of e)
    t.addEventListener(s, f[s].bind(f));
}
d(Wh, "bindEvents");
function Rm(f) {
  return Math.round(Math.min(255, Math.max(1, 255 * f))).toString(16).padStart(2, "0");
}
d(Rm, "opacityToHex");
var El;
const zu = class zu {
  constructor() {
    A(this, El, 0);
  }
  get id() {
    return `${um}${se(this, El)._++}`;
  }
};
El = new WeakMap(), d(zu, "IdManager");
let fc = zu;
var ya, Sl, me, wa, gc;
const Cl = class Cl {
  constructor() {
    A(this, wa);
    A(this, ya, Sm());
    A(this, Sl, 0);
    A(this, me, null);
  }
  static get _isSVGFittingCanvas() {
    const t = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', s = new OffscreenCanvas(1, 3).getContext("2d", {
      willReadFrequently: !0
    }), i = new Image();
    i.src = t;
    const n = i.decode().then(() => (s.drawImage(i, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(s.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
    return X(this, "_isSVGFittingCanvas", n);
  }
  async getFromFile(t) {
    const {
      lastModified: e,
      name: s,
      size: i,
      type: n
    } = t;
    return m(this, wa, gc).call(this, `${e}_${s}_${i}_${n}`, t);
  }
  async getFromUrl(t) {
    return m(this, wa, gc).call(this, t, t);
  }
  async getFromId(t) {
    r(this, me) || g(this, me, /* @__PURE__ */ new Map());
    const e = r(this, me).get(t);
    return e ? e.bitmap ? (e.refCounter += 1, e) : e.file ? this.getFromFile(e.file) : this.getFromUrl(e.url) : null;
  }
  getSvgUrl(t) {
    const e = r(this, me).get(t);
    return e != null && e.isSvg ? e.svgUrl : null;
  }
  deleteId(t) {
    r(this, me) || g(this, me, /* @__PURE__ */ new Map());
    const e = r(this, me).get(t);
    e && (e.refCounter -= 1, e.refCounter === 0 && (e.bitmap = null));
  }
  isValidId(t) {
    return t.startsWith(`image_${r(this, ya)}_`);
  }
};
ya = new WeakMap(), Sl = new WeakMap(), me = new WeakMap(), wa = new WeakSet(), gc = /* @__PURE__ */ d(async function(t, e) {
  r(this, me) || g(this, me, /* @__PURE__ */ new Map());
  let s = r(this, me).get(t);
  if (s === null)
    return null;
  if (s != null && s.bitmap)
    return s.refCounter += 1, s;
  try {
    s || (s = {
      bitmap: null,
      id: `image_${r(this, ya)}_${se(this, Sl)._++}`,
      refCounter: 0,
      isSvg: !1
    });
    let i;
    if (typeof e == "string" ? (s.url = e, i = await Vl(e, "blob")) : i = s.file = e, i.type === "image/svg+xml") {
      const n = Cl._isSVGFittingCanvas, a = new FileReader(), o = new Image(), h = new Promise((l, c) => {
        o.onload = () => {
          s.bitmap = o, s.isSvg = !0, l();
        }, a.onload = async () => {
          const u = s.svgUrl = a.result;
          o.src = await n ? `${u}#svgView(preserveAspectRatio(none))` : u;
        }, o.onerror = a.onerror = c;
      });
      a.readAsDataURL(i), await h;
    } else
      s.bitmap = await createImageBitmap(i);
    s.refCounter = 1;
  } catch (i) {
    console.error(i), s = null;
  }
  return r(this, me).set(t, s), s && r(this, me).set(s.id, s), s;
}, "#get"), d(Cl, "ImageManager");
let pc = Cl;
var St, Ks, _a, Ct;
const $u = class $u {
  constructor(t = 128) {
    A(this, St, []);
    A(this, Ks, !1);
    A(this, _a);
    A(this, Ct, -1);
    g(this, _a, t);
  }
  add({
    cmd: t,
    undo: e,
    post: s,
    mustExec: i,
    type: n = NaN,
    overwriteIfSameType: a = !1,
    keepUndo: o = !1
  }) {
    if (i && t(), r(this, Ks))
      return;
    const h = {
      cmd: t,
      undo: e,
      post: s,
      type: n
    };
    if (r(this, Ct) === -1) {
      r(this, St).length > 0 && (r(this, St).length = 0), g(this, Ct, 0), r(this, St).push(h);
      return;
    }
    if (a && r(this, St)[r(this, Ct)].type === n) {
      o && (h.undo = r(this, St)[r(this, Ct)].undo), r(this, St)[r(this, Ct)] = h;
      return;
    }
    const l = r(this, Ct) + 1;
    l === r(this, _a) ? r(this, St).splice(0, 1) : (g(this, Ct, l), l < r(this, St).length && r(this, St).splice(l)), r(this, St).push(h);
  }
  undo() {
    if (r(this, Ct) === -1)
      return;
    g(this, Ks, !0);
    const {
      undo: t,
      post: e
    } = r(this, St)[r(this, Ct)];
    t(), e == null || e(), g(this, Ks, !1), g(this, Ct, r(this, Ct) - 1);
  }
  redo() {
    if (r(this, Ct) < r(this, St).length - 1) {
      g(this, Ct, r(this, Ct) + 1), g(this, Ks, !0);
      const {
        cmd: t,
        post: e
      } = r(this, St)[r(this, Ct)];
      t(), e == null || e(), g(this, Ks, !1);
    }
  }
  hasSomethingToUndo() {
    return r(this, Ct) !== -1;
  }
  hasSomethingToRedo() {
    return r(this, Ct) < r(this, St).length - 1;
  }
  destroy() {
    g(this, St, null);
  }
};
St = new WeakMap(), Ks = new WeakMap(), _a = new WeakMap(), Ct = new WeakMap(), d($u, "CommandManager");
let mc = $u;
var xl, jp;
const ju = class ju {
  constructor(t) {
    A(this, xl);
    this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
    const {
      isMac: e
    } = jt.platform;
    for (const [s, i, n = {}] of t)
      for (const a of s) {
        const o = a.startsWith("mac+");
        e && o ? (this.callbacks.set(a.slice(4), {
          callback: i,
          options: n
        }), this.allKeys.add(a.split("+").at(-1))) : !e && !o && (this.callbacks.set(a, {
          callback: i,
          options: n
        }), this.allKeys.add(a.split("+").at(-1)));
      }
  }
  exec(t, e) {
    if (!this.allKeys.has(e.key))
      return;
    const s = this.callbacks.get(m(this, xl, jp).call(this, e));
    if (!s)
      return;
    const {
      callback: i,
      options: {
        bubbles: n = !1,
        args: a = [],
        checker: o = null
      }
    } = s;
    o && !o(t, e) || (i.bind(t, ...a, e)(), n || (e.stopPropagation(), e.preventDefault()));
  }
};
xl = new WeakSet(), jp = /* @__PURE__ */ d(function(t) {
  t.altKey && this.buffer.push("alt"), t.ctrlKey && this.buffer.push("ctrl"), t.metaKey && this.buffer.push("meta"), t.shiftKey && this.buffer.push("shift"), this.buffer.push(t.key);
  const e = this.buffer.join("+");
  return this.buffer.length = 0, e;
}, "#serialize"), d(ju, "KeyboardManager");
let Tn = ju;
const ia = class ia {
  get _colors() {
    const t = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
    return Lm(t), X(this, "_colors", t);
  }
  convert(t) {
    const e = wu(t);
    if (!window.matchMedia("(forced-colors: active)").matches)
      return e;
    for (const [s, i] of this._colors)
      if (i.every((n, a) => n === e[a]))
        return ia._colorsMapping.get(s);
    return e;
  }
  getHexCode(t) {
    const e = this._colors.get(t);
    return e ? I.makeHexColor(...e) : t;
  }
};
d(ia, "ColorManager"), U(ia, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
let bc = ia;
var $n, re, At, kt, jn, ds, Wn, Se, Vn, Fi, $e, Ce, Ni, Ea, Sa, Ca, je, Gn, Qs, We, Tl, Js, xa, Oi, Ta, qn, xt, J, us, Hi, La, Ra, ka, Ma, Ia, Pa, Da, Fa, Na, Oa, Ha, Ba, Ua, Zs, Ve, fs, za, L, fh, Ac, Wp, Vp, ph, Gp, qp, Xp, vc, Yp, yc, wc, Kp, Vt, Ws, Qp, Jp, _c, Zp, Wr, Ec;
const Ci = class Ci {
  constructor(t, e, s, i, n, a, o, h, l, c) {
    A(this, L);
    A(this, $n, new AbortController());
    A(this, re, null);
    A(this, At, /* @__PURE__ */ new Map());
    A(this, kt, /* @__PURE__ */ new Map());
    A(this, jn, null);
    A(this, ds, null);
    A(this, Wn, null);
    A(this, Se, new mc());
    A(this, Vn, 0);
    A(this, Fi, /* @__PURE__ */ new Set());
    A(this, $e, null);
    A(this, Ce, null);
    A(this, Ni, /* @__PURE__ */ new Set());
    A(this, Ea, !1);
    A(this, Sa, !1);
    A(this, Ca, null);
    A(this, je, null);
    A(this, Gn, null);
    A(this, Qs, !1);
    A(this, We, null);
    A(this, Tl, new fc());
    A(this, Js, !1);
    A(this, xa, !1);
    A(this, Oi, null);
    A(this, Ta, null);
    A(this, qn, null);
    A(this, xt, G.NONE);
    A(this, J, /* @__PURE__ */ new Set());
    A(this, us, null);
    A(this, Hi, null);
    A(this, La, null);
    A(this, Ra, this.blur.bind(this));
    A(this, ka, this.focus.bind(this));
    A(this, Ma, this.copy.bind(this));
    A(this, Ia, this.cut.bind(this));
    A(this, Pa, this.paste.bind(this));
    A(this, Da, this.keydown.bind(this));
    A(this, Fa, this.keyup.bind(this));
    A(this, Na, this.onEditingAction.bind(this));
    A(this, Oa, this.onPageChanging.bind(this));
    A(this, Ha, this.onScaleChanging.bind(this));
    A(this, Ba, this.onRotationChanging.bind(this));
    A(this, Ua, {
      isEditing: !1,
      isEmpty: !0,
      hasSomethingToUndo: !1,
      hasSomethingToRedo: !1,
      hasSelectedEditor: !1,
      hasSelectedText: !1
    });
    A(this, Zs, [0, 0]);
    A(this, Ve, null);
    A(this, fs, null);
    A(this, za, null);
    this._signal = r(this, $n).signal, g(this, fs, t), g(this, za, e), g(this, jn, s), this._eventBus = i, this._eventBus._on("editingaction", r(this, Na)), this._eventBus._on("pagechanging", r(this, Oa)), this._eventBus._on("scalechanging", r(this, Ha)), this._eventBus._on("rotationchanging", r(this, Ba)), m(this, L, Gp).call(this), m(this, L, Kp).call(this), m(this, L, vc).call(this), g(this, ds, n.annotationStorage), g(this, Ca, n.filterFactory), g(this, Hi, a), g(this, Gn, o || null), g(this, Ea, h), g(this, Sa, l), g(this, qn, c || null), this.viewParameters = {
      realScale: bi.PDF_TO_CSS_UNITS,
      rotation: 0
    }, this.isShiftKeyDown = !1;
  }
  static get _keyboardManager() {
    const t = Ci.prototype, e = /* @__PURE__ */ d((a) => r(a, fs).contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && a.hasSomethingToControl(), "arrowChecker"), s = /* @__PURE__ */ d((a, {
      target: o
    }) => {
      if (o instanceof HTMLInputElement) {
        const {
          type: h
        } = o;
        return h !== "text" && h !== "number";
      }
      return !0;
    }, "textInputChecker"), i = this.TRANSLATE_SMALL, n = this.TRANSLATE_BIG;
    return X(this, "_keyboardManager", new Tn([[["ctrl+a", "mac+meta+a"], t.selectAll, {
      checker: s
    }], [["ctrl+z", "mac+meta+z"], t.undo, {
      checker: s
    }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], t.redo, {
      checker: s
    }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], t.delete, {
      checker: s
    }], [["Enter", "mac+Enter"], t.addNewEditorFromKeyboard, {
      checker: /* @__PURE__ */ d((a, {
        target: o
      }) => !(o instanceof HTMLButtonElement) && r(a, fs).contains(o) && !a.isEnterHandled, "checker")
    }], [[" ", "mac+ "], t.addNewEditorFromKeyboard, {
      checker: /* @__PURE__ */ d((a, {
        target: o
      }) => !(o instanceof HTMLButtonElement) && r(a, fs).contains(document.activeElement), "checker")
    }], [["Escape", "mac+Escape"], t.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], t.translateSelectedEditors, {
      args: [-i, 0],
      checker: e
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t.translateSelectedEditors, {
      args: [-n, 0],
      checker: e
    }], [["ArrowRight", "mac+ArrowRight"], t.translateSelectedEditors, {
      args: [i, 0],
      checker: e
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t.translateSelectedEditors, {
      args: [n, 0],
      checker: e
    }], [["ArrowUp", "mac+ArrowUp"], t.translateSelectedEditors, {
      args: [0, -i],
      checker: e
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t.translateSelectedEditors, {
      args: [0, -n],
      checker: e
    }], [["ArrowDown", "mac+ArrowDown"], t.translateSelectedEditors, {
      args: [0, i],
      checker: e
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t.translateSelectedEditors, {
      args: [0, n],
      checker: e
    }]]));
  }
  destroy() {
    var t, e, s;
    (t = r(this, $n)) == null || t.abort(), g(this, $n, null), this._signal = null, this._eventBus._off("editingaction", r(this, Na)), this._eventBus._off("pagechanging", r(this, Oa)), this._eventBus._off("scalechanging", r(this, Ha)), this._eventBus._off("rotationchanging", r(this, Ba));
    for (const i of r(this, kt).values())
      i.destroy();
    r(this, kt).clear(), r(this, At).clear(), r(this, Ni).clear(), g(this, re, null), r(this, J).clear(), r(this, Se).destroy(), (e = r(this, jn)) == null || e.destroy(), (s = r(this, We)) == null || s.hide(), g(this, We, null), r(this, je) && (clearTimeout(r(this, je)), g(this, je, null)), r(this, Ve) && (clearTimeout(r(this, Ve)), g(this, Ve, null));
  }
  async mlGuess(t) {
    var e;
    return ((e = r(this, qn)) == null ? void 0 : e.guess(t)) || null;
  }
  async isMLEnabledFor(t) {
    var e;
    return !!await ((e = r(this, qn)) == null ? void 0 : e.isEnabledFor(t));
  }
  get useNewAltTextFlow() {
    return r(this, Sa);
  }
  get hcmFilter() {
    return X(this, "hcmFilter", r(this, Hi) ? r(this, Ca).addHCMFilter(r(this, Hi).foreground, r(this, Hi).background) : "none");
  }
  get direction() {
    return X(this, "direction", getComputedStyle(r(this, fs)).direction);
  }
  get highlightColors() {
    return X(this, "highlightColors", r(this, Gn) ? new Map(r(this, Gn).split(",").map((t) => t.split("=").map((e) => e.trim()))) : null);
  }
  get highlightColorNames() {
    return X(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (t) => t.reverse())) : null);
  }
  setMainHighlightColorPicker(t) {
    g(this, Ta, t);
  }
  editAltText(t) {
    var e;
    (e = r(this, jn)) == null || e.editAltText(this, t);
  }
  switchToMode(t, e) {
    this._eventBus.on("annotationeditormodechanged", e, {
      once: !0,
      signal: this._signal
    }), this._eventBus.dispatch("showannotationeditorui", {
      source: this,
      mode: t
    });
  }
  setPreference(t, e) {
    this._eventBus.dispatch("setpreference", {
      source: this,
      name: t,
      value: e
    });
  }
  onPageChanging({
    pageNumber: t
  }) {
    g(this, Vn, t - 1);
  }
  focusMainContainer() {
    r(this, fs).focus();
  }
  findParent(t, e) {
    for (const s of r(this, kt).values()) {
      const {
        x: i,
        y: n,
        width: a,
        height: o
      } = s.div.getBoundingClientRect();
      if (t >= i && t <= i + a && e >= n && e <= n + o)
        return s;
    }
    return null;
  }
  disableUserSelect(t = !1) {
    r(this, za).classList.toggle("noUserSelect", t);
  }
  addShouldRescale(t) {
    r(this, Ni).add(t);
  }
  removeShouldRescale(t) {
    r(this, Ni).delete(t);
  }
  onScaleChanging({
    scale: t
  }) {
    this.commitOrRemove(), this.viewParameters.realScale = t * bi.PDF_TO_CSS_UNITS;
    for (const e of r(this, Ni))
      e.onScaleChanging();
  }
  onRotationChanging({
    pagesRotation: t
  }) {
    this.commitOrRemove(), this.viewParameters.rotation = t;
  }
  highlightSelection(t = "") {
    const e = document.getSelection();
    if (!e || e.isCollapsed)
      return;
    const {
      anchorNode: s,
      anchorOffset: i,
      focusNode: n,
      focusOffset: a
    } = e, o = e.toString(), l = m(this, L, fh).call(this, e).closest(".textLayer"), c = this.getSelectionBoxes(l);
    if (!c)
      return;
    e.empty();
    const u = m(this, L, Ac).call(this, l), p = r(this, xt) === G.NONE, b = /* @__PURE__ */ d(() => {
      u == null || u.createAndAddNewEditor({
        x: 0,
        y: 0
      }, !1, {
        methodOfCreation: t,
        boxes: c,
        anchorNode: s,
        anchorOffset: i,
        focusNode: n,
        focusOffset: a,
        text: o
      }), p && this.showAllEditors("highlight", !0, !0);
    }, "callback");
    if (p) {
      this.switchToMode(G.HIGHLIGHT, b);
      return;
    }
    b();
  }
  addToAnnotationStorage(t) {
    !t.isEmpty() && r(this, ds) && !r(this, ds).has(t.id) && r(this, ds).setValue(t.id, t);
  }
  blur() {
    if (this.isShiftKeyDown = !1, r(this, Qs) && (g(this, Qs, !1), m(this, L, ph).call(this, "main_toolbar")), !this.hasSelection)
      return;
    const {
      activeElement: t
    } = document;
    for (const e of r(this, J))
      if (e.div.contains(t)) {
        g(this, Oi, [e, t]), e._focusEventsAllowed = !1;
        break;
      }
  }
  focus() {
    if (!r(this, Oi))
      return;
    const [t, e] = r(this, Oi);
    g(this, Oi, null), e.addEventListener("focusin", () => {
      t._focusEventsAllowed = !0;
    }, {
      once: !0,
      signal: this._signal
    }), e.focus();
  }
  addEditListeners() {
    m(this, L, vc).call(this), m(this, L, yc).call(this);
  }
  removeEditListeners() {
    m(this, L, Yp).call(this), m(this, L, wc).call(this);
  }
  dragOver(t) {
    for (const {
      type: e
    } of t.dataTransfer.items)
      for (const s of r(this, Ce))
        if (s.isHandlingMimeForPasting(e)) {
          t.dataTransfer.dropEffect = "copy", t.preventDefault();
          return;
        }
  }
  drop(t) {
    for (const e of t.dataTransfer.items)
      for (const s of r(this, Ce))
        if (s.isHandlingMimeForPasting(e.type)) {
          s.paste(e, this.currentLayer), t.preventDefault();
          return;
        }
  }
  copy(t) {
    var s;
    if (t.preventDefault(), (s = r(this, re)) == null || s.commitOrRemove(), !this.hasSelection)
      return;
    const e = [];
    for (const i of r(this, J)) {
      const n = i.serialize(!0);
      n && e.push(n);
    }
    e.length !== 0 && t.clipboardData.setData("application/pdfjs", JSON.stringify(e));
  }
  cut(t) {
    this.copy(t), this.delete();
  }
  paste(t) {
    t.preventDefault();
    const {
      clipboardData: e
    } = t;
    for (const n of e.items)
      for (const a of r(this, Ce))
        if (a.isHandlingMimeForPasting(n.type)) {
          a.paste(n, this.currentLayer);
          return;
        }
    let s = e.getData("application/pdfjs");
    if (!s)
      return;
    try {
      s = JSON.parse(s);
    } catch (n) {
      $(`paste: "${n.message}".`);
      return;
    }
    if (!Array.isArray(s))
      return;
    this.unselectAll();
    const i = this.currentLayer;
    try {
      const n = [];
      for (const h of s) {
        const l = i.deserialize(h);
        if (!l)
          return;
        n.push(l);
      }
      const a = /* @__PURE__ */ d(() => {
        for (const h of n)
          m(this, L, _c).call(this, h);
        m(this, L, Ec).call(this, n);
      }, "cmd"), o = /* @__PURE__ */ d(() => {
        for (const h of n)
          h.remove();
      }, "undo");
      this.addCommands({
        cmd: a,
        undo: o,
        mustExec: !0
      });
    } catch (n) {
      $(`paste: "${n.message}".`);
    }
  }
  keydown(t) {
    !this.isShiftKeyDown && t.key === "Shift" && (this.isShiftKeyDown = !0), r(this, xt) !== G.NONE && !this.isEditorHandlingKeyboard && Ci._keyboardManager.exec(this, t);
  }
  keyup(t) {
    this.isShiftKeyDown && t.key === "Shift" && (this.isShiftKeyDown = !1, r(this, Qs) && (g(this, Qs, !1), m(this, L, ph).call(this, "main_toolbar")));
  }
  onEditingAction({
    name: t
  }) {
    switch (t) {
      case "undo":
      case "redo":
      case "delete":
      case "selectAll":
        this[t]();
        break;
      case "highlightSelection":
        this.highlightSelection("context_menu");
        break;
    }
  }
  setEditingState(t) {
    t ? (m(this, L, qp).call(this), m(this, L, yc).call(this), m(this, L, Vt).call(this, {
      isEditing: r(this, xt) !== G.NONE,
      isEmpty: m(this, L, Wr).call(this),
      hasSomethingToUndo: r(this, Se).hasSomethingToUndo(),
      hasSomethingToRedo: r(this, Se).hasSomethingToRedo(),
      hasSelectedEditor: !1
    })) : (m(this, L, Xp).call(this), m(this, L, wc).call(this), m(this, L, Vt).call(this, {
      isEditing: !1
    }), this.disableUserSelect(!1));
  }
  registerEditorTypes(t) {
    if (!r(this, Ce)) {
      g(this, Ce, t);
      for (const e of r(this, Ce))
        m(this, L, Ws).call(this, e.defaultPropertiesToUpdate);
    }
  }
  getId() {
    return r(this, Tl).id;
  }
  get currentLayer() {
    return r(this, kt).get(r(this, Vn));
  }
  getLayer(t) {
    return r(this, kt).get(t);
  }
  get currentPageIndex() {
    return r(this, Vn);
  }
  addLayer(t) {
    r(this, kt).set(t.pageIndex, t), r(this, Js) ? t.enable() : t.disable();
  }
  removeLayer(t) {
    r(this, kt).delete(t.pageIndex);
  }
  updateMode(t, e = null, s = !1) {
    if (r(this, xt) !== t) {
      if (g(this, xt, t), t === G.NONE) {
        this.setEditingState(!1), m(this, L, Jp).call(this);
        return;
      }
      this.setEditingState(!0), m(this, L, Qp).call(this), this.unselectAll();
      for (const i of r(this, kt).values())
        i.updateMode(t);
      if (!e && s) {
        this.addNewEditorFromKeyboard();
        return;
      }
      if (e) {
        for (const i of r(this, At).values())
          if (i.annotationElementId === e) {
            this.setSelected(i), i.enterInEditMode();
            break;
          }
      }
    }
  }
  addNewEditorFromKeyboard() {
    this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
  }
  updateToolbar(t) {
    t !== r(this, xt) && this._eventBus.dispatch("switchannotationeditormode", {
      source: this,
      mode: t
    });
  }
  updateParams(t, e) {
    var s;
    if (r(this, Ce)) {
      switch (t) {
        case N.CREATE:
          this.currentLayer.addNewEditor();
          return;
        case N.HIGHLIGHT_DEFAULT_COLOR:
          (s = r(this, Ta)) == null || s.updateColor(e);
          break;
        case N.HIGHLIGHT_SHOW_ALL:
          this._eventBus.dispatch("reporttelemetry", {
            source: this,
            details: {
              type: "editing",
              data: {
                type: "highlight",
                action: "toggle_visibility"
              }
            }
          }), (r(this, La) || g(this, La, /* @__PURE__ */ new Map())).set(t, e), this.showAllEditors("highlight", e);
          break;
      }
      for (const i of r(this, J))
        i.updateParams(t, e);
      for (const i of r(this, Ce))
        i.updateDefaultParams(t, e);
    }
  }
  showAllEditors(t, e, s = !1) {
    var n;
    for (const a of r(this, At).values())
      a.editorType === t && a.show(e);
    (((n = r(this, La)) == null ? void 0 : n.get(N.HIGHLIGHT_SHOW_ALL)) ?? !0) !== e && m(this, L, Ws).call(this, [[N.HIGHLIGHT_SHOW_ALL, e]]);
  }
  enableWaiting(t = !1) {
    if (r(this, xa) !== t) {
      g(this, xa, t);
      for (const e of r(this, kt).values())
        t ? e.disableClick() : e.enableClick(), e.div.classList.toggle("waiting", t);
    }
  }
  getEditors(t) {
    const e = [];
    for (const s of r(this, At).values())
      s.pageIndex === t && e.push(s);
    return e;
  }
  getEditor(t) {
    return r(this, At).get(t);
  }
  addEditor(t) {
    r(this, At).set(t.id, t);
  }
  removeEditor(t) {
    var e;
    t.div.contains(document.activeElement) && (r(this, je) && clearTimeout(r(this, je)), g(this, je, setTimeout(() => {
      this.focusMainContainer(), g(this, je, null);
    }, 0))), r(this, At).delete(t.id), this.unselect(t), (!t.annotationElementId || !r(this, Fi).has(t.annotationElementId)) && ((e = r(this, ds)) == null || e.remove(t.id));
  }
  addDeletedAnnotationElement(t) {
    r(this, Fi).add(t.annotationElementId), this.addChangedExistingAnnotation(t), t.deleted = !0;
  }
  isDeletedAnnotationElement(t) {
    return r(this, Fi).has(t);
  }
  removeDeletedAnnotationElement(t) {
    r(this, Fi).delete(t.annotationElementId), this.removeChangedExistingAnnotation(t), t.deleted = !1;
  }
  setActiveEditor(t) {
    r(this, re) !== t && (g(this, re, t), t && m(this, L, Ws).call(this, t.propertiesToUpdate));
  }
  updateUI(t) {
    r(this, L, Zp) === t && m(this, L, Ws).call(this, t.propertiesToUpdate);
  }
  toggleSelected(t) {
    if (r(this, J).has(t)) {
      r(this, J).delete(t), t.unselect(), m(this, L, Vt).call(this, {
        hasSelectedEditor: this.hasSelection
      });
      return;
    }
    r(this, J).add(t), t.select(), m(this, L, Ws).call(this, t.propertiesToUpdate), m(this, L, Vt).call(this, {
      hasSelectedEditor: !0
    });
  }
  setSelected(t) {
    for (const e of r(this, J))
      e !== t && e.unselect();
    r(this, J).clear(), r(this, J).add(t), t.select(), m(this, L, Ws).call(this, t.propertiesToUpdate), m(this, L, Vt).call(this, {
      hasSelectedEditor: !0
    });
  }
  isSelected(t) {
    return r(this, J).has(t);
  }
  get firstSelectedEditor() {
    return r(this, J).values().next().value;
  }
  unselect(t) {
    t.unselect(), r(this, J).delete(t), m(this, L, Vt).call(this, {
      hasSelectedEditor: this.hasSelection
    });
  }
  get hasSelection() {
    return r(this, J).size !== 0;
  }
  get isEnterHandled() {
    return r(this, J).size === 1 && this.firstSelectedEditor.isEnterHandled;
  }
  undo() {
    r(this, Se).undo(), m(this, L, Vt).call(this, {
      hasSomethingToUndo: r(this, Se).hasSomethingToUndo(),
      hasSomethingToRedo: !0,
      isEmpty: m(this, L, Wr).call(this)
    });
  }
  redo() {
    r(this, Se).redo(), m(this, L, Vt).call(this, {
      hasSomethingToUndo: !0,
      hasSomethingToRedo: r(this, Se).hasSomethingToRedo(),
      isEmpty: m(this, L, Wr).call(this)
    });
  }
  addCommands(t) {
    r(this, Se).add(t), m(this, L, Vt).call(this, {
      hasSomethingToUndo: !0,
      hasSomethingToRedo: !1,
      isEmpty: m(this, L, Wr).call(this)
    });
  }
  delete() {
    if (this.commitOrRemove(), !this.hasSelection)
      return;
    const t = [...r(this, J)], e = /* @__PURE__ */ d(() => {
      for (const i of t)
        i.remove();
    }, "cmd"), s = /* @__PURE__ */ d(() => {
      for (const i of t)
        m(this, L, _c).call(this, i);
    }, "undo");
    this.addCommands({
      cmd: e,
      undo: s,
      mustExec: !0
    });
  }
  commitOrRemove() {
    var t;
    (t = r(this, re)) == null || t.commitOrRemove();
  }
  hasSomethingToControl() {
    return r(this, re) || this.hasSelection;
  }
  selectAll() {
    for (const t of r(this, J))
      t.commit();
    m(this, L, Ec).call(this, r(this, At).values());
  }
  unselectAll() {
    if (!(r(this, re) && (r(this, re).commitOrRemove(), r(this, xt) !== G.NONE)) && this.hasSelection) {
      for (const t of r(this, J))
        t.unselect();
      r(this, J).clear(), m(this, L, Vt).call(this, {
        hasSelectedEditor: !1
      });
    }
  }
  translateSelectedEditors(t, e, s = !1) {
    if (s || this.commitOrRemove(), !this.hasSelection)
      return;
    r(this, Zs)[0] += t, r(this, Zs)[1] += e;
    const [i, n] = r(this, Zs), a = [...r(this, J)], o = 1e3;
    r(this, Ve) && clearTimeout(r(this, Ve)), g(this, Ve, setTimeout(() => {
      g(this, Ve, null), r(this, Zs)[0] = r(this, Zs)[1] = 0, this.addCommands({
        cmd: /* @__PURE__ */ d(() => {
          for (const h of a)
            r(this, At).has(h.id) && h.translateInPage(i, n);
        }, "cmd"),
        undo: /* @__PURE__ */ d(() => {
          for (const h of a)
            r(this, At).has(h.id) && h.translateInPage(-i, -n);
        }, "undo"),
        mustExec: !1
      });
    }, o));
    for (const h of a)
      h.translateInPage(t, e);
  }
  setUpDragSession() {
    if (this.hasSelection) {
      this.disableUserSelect(!0), g(this, $e, /* @__PURE__ */ new Map());
      for (const t of r(this, J))
        r(this, $e).set(t, {
          savedX: t.x,
          savedY: t.y,
          savedPageIndex: t.pageIndex,
          newX: 0,
          newY: 0,
          newPageIndex: -1
        });
    }
  }
  endDragSession() {
    if (!r(this, $e))
      return !1;
    this.disableUserSelect(!1);
    const t = r(this, $e);
    g(this, $e, null);
    let e = !1;
    for (const [{
      x: i,
      y: n,
      pageIndex: a
    }, o] of t)
      o.newX = i, o.newY = n, o.newPageIndex = a, e || (e = i !== o.savedX || n !== o.savedY || a !== o.savedPageIndex);
    if (!e)
      return !1;
    const s = /* @__PURE__ */ d((i, n, a, o) => {
      if (r(this, At).has(i.id)) {
        const h = r(this, kt).get(o);
        h ? i._setParentAndPosition(h, n, a) : (i.pageIndex = o, i.x = n, i.y = a);
      }
    }, "move");
    return this.addCommands({
      cmd: /* @__PURE__ */ d(() => {
        for (const [i, {
          newX: n,
          newY: a,
          newPageIndex: o
        }] of t)
          s(i, n, a, o);
      }, "cmd"),
      undo: /* @__PURE__ */ d(() => {
        for (const [i, {
          savedX: n,
          savedY: a,
          savedPageIndex: o
        }] of t)
          s(i, n, a, o);
      }, "undo"),
      mustExec: !0
    }), !0;
  }
  dragSelectedEditors(t, e) {
    if (r(this, $e))
      for (const s of r(this, $e).keys())
        s.drag(t, e);
  }
  rebuild(t) {
    if (t.parent === null) {
      const e = this.getLayer(t.pageIndex);
      e ? (e.changeParent(t), e.addOrRebuild(t)) : (this.addEditor(t), this.addToAnnotationStorage(t), t.rebuild());
    } else
      t.parent.addOrRebuild(t);
  }
  get isEditorHandlingKeyboard() {
    var t;
    return ((t = this.getActive()) == null ? void 0 : t.shouldGetKeyboardEvents()) || r(this, J).size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
  }
  isActive(t) {
    return r(this, re) === t;
  }
  getActive() {
    return r(this, re);
  }
  getMode() {
    return r(this, xt);
  }
  get imageManager() {
    return X(this, "imageManager", new pc());
  }
  getSelectionBoxes(t) {
    if (!t)
      return null;
    const e = document.getSelection();
    for (let l = 0, c = e.rangeCount; l < c; l++)
      if (!t.contains(e.getRangeAt(l).commonAncestorContainer))
        return null;
    const {
      x: s,
      y: i,
      width: n,
      height: a
    } = t.getBoundingClientRect();
    let o;
    switch (t.getAttribute("data-main-rotation")) {
      case "90":
        o = /* @__PURE__ */ d((l, c, u, p) => ({
          x: (c - i) / a,
          y: 1 - (l + u - s) / n,
          width: p / a,
          height: u / n
        }), "rotator");
        break;
      case "180":
        o = /* @__PURE__ */ d((l, c, u, p) => ({
          x: 1 - (l + u - s) / n,
          y: 1 - (c + p - i) / a,
          width: u / n,
          height: p / a
        }), "rotator");
        break;
      case "270":
        o = /* @__PURE__ */ d((l, c, u, p) => ({
          x: 1 - (c + p - i) / a,
          y: (l - s) / n,
          width: p / a,
          height: u / n
        }), "rotator");
        break;
      default:
        o = /* @__PURE__ */ d((l, c, u, p) => ({
          x: (l - s) / n,
          y: (c - i) / a,
          width: u / n,
          height: p / a
        }), "rotator");
        break;
    }
    const h = [];
    for (let l = 0, c = e.rangeCount; l < c; l++) {
      const u = e.getRangeAt(l);
      if (!u.collapsed)
        for (const {
          x: p,
          y: b,
          width: v,
          height: y
        } of u.getClientRects())
          v === 0 || y === 0 || h.push(o(p, b, v, y));
    }
    return h.length === 0 ? null : h;
  }
  addChangedExistingAnnotation({
    annotationElementId: t,
    id: e
  }) {
    (r(this, Wn) || g(this, Wn, /* @__PURE__ */ new Map())).set(t, e);
  }
  removeChangedExistingAnnotation({
    annotationElementId: t
  }) {
    var e;
    (e = r(this, Wn)) == null || e.delete(t);
  }
  renderAnnotationElement(t) {
    var i;
    const e = (i = r(this, Wn)) == null ? void 0 : i.get(t.data.id);
    if (!e)
      return;
    const s = r(this, ds).getRawValue(e);
    s && (r(this, xt) === G.NONE && !s.hasBeenModified || s.renderAnnotationElement(t));
  }
};
$n = new WeakMap(), re = new WeakMap(), At = new WeakMap(), kt = new WeakMap(), jn = new WeakMap(), ds = new WeakMap(), Wn = new WeakMap(), Se = new WeakMap(), Vn = new WeakMap(), Fi = new WeakMap(), $e = new WeakMap(), Ce = new WeakMap(), Ni = new WeakMap(), Ea = new WeakMap(), Sa = new WeakMap(), Ca = new WeakMap(), je = new WeakMap(), Gn = new WeakMap(), Qs = new WeakMap(), We = new WeakMap(), Tl = new WeakMap(), Js = new WeakMap(), xa = new WeakMap(), Oi = new WeakMap(), Ta = new WeakMap(), qn = new WeakMap(), xt = new WeakMap(), J = new WeakMap(), us = new WeakMap(), Hi = new WeakMap(), La = new WeakMap(), Ra = new WeakMap(), ka = new WeakMap(), Ma = new WeakMap(), Ia = new WeakMap(), Pa = new WeakMap(), Da = new WeakMap(), Fa = new WeakMap(), Na = new WeakMap(), Oa = new WeakMap(), Ha = new WeakMap(), Ba = new WeakMap(), Ua = new WeakMap(), Zs = new WeakMap(), Ve = new WeakMap(), fs = new WeakMap(), za = new WeakMap(), L = new WeakSet(), fh = /* @__PURE__ */ d(function({
  anchorNode: t
}) {
  return t.nodeType === Node.TEXT_NODE ? t.parentElement : t;
}, "#getAnchorElementForSelection"), Ac = /* @__PURE__ */ d(function(t) {
  const {
    currentLayer: e
  } = this;
  if (e.hasTextLayer(t))
    return e;
  for (const s of r(this, kt).values())
    if (s.hasTextLayer(t))
      return s;
  return null;
}, "#getLayerForTextLayer"), Wp = /* @__PURE__ */ d(function() {
  const t = document.getSelection();
  if (!t || t.isCollapsed)
    return;
  const s = m(this, L, fh).call(this, t).closest(".textLayer"), i = this.getSelectionBoxes(s);
  i && (r(this, We) || g(this, We, new uc(this)), r(this, We).show(s, i, this.direction === "ltr"));
}, "#displayHighlightToolbar"), Vp = /* @__PURE__ */ d(function() {
  var n, a, o;
  const t = document.getSelection();
  if (!t || t.isCollapsed) {
    r(this, us) && ((n = r(this, We)) == null || n.hide(), g(this, us, null), m(this, L, Vt).call(this, {
      hasSelectedText: !1
    }));
    return;
  }
  const {
    anchorNode: e
  } = t;
  if (e === r(this, us))
    return;
  const i = m(this, L, fh).call(this, t).closest(".textLayer");
  if (!i) {
    r(this, us) && ((a = r(this, We)) == null || a.hide(), g(this, us, null), m(this, L, Vt).call(this, {
      hasSelectedText: !1
    }));
    return;
  }
  if ((o = r(this, We)) == null || o.hide(), g(this, us, e), m(this, L, Vt).call(this, {
    hasSelectedText: !0
  }), !(r(this, xt) !== G.HIGHLIGHT && r(this, xt) !== G.NONE) && (r(this, xt) === G.HIGHLIGHT && this.showAllEditors("highlight", !0, !0), g(this, Qs, this.isShiftKeyDown), !this.isShiftKeyDown)) {
    const h = r(this, xt) === G.HIGHLIGHT ? m(this, L, Ac).call(this, i) : null;
    h == null || h.toggleDrawing();
    const l = this._signal, c = /* @__PURE__ */ d((u) => {
      u.type === "pointerup" && u.button !== 0 || (h == null || h.toggleDrawing(!0), window.removeEventListener("pointerup", c), window.removeEventListener("blur", c), u.type === "pointerup" && m(this, L, ph).call(this, "main_toolbar"));
    }, "pointerup");
    window.addEventListener("pointerup", c, {
      signal: l
    }), window.addEventListener("blur", c, {
      signal: l
    });
  }
}, "#selectionChange"), ph = /* @__PURE__ */ d(function(t = "") {
  r(this, xt) === G.HIGHLIGHT ? this.highlightSelection(t) : r(this, Ea) && m(this, L, Wp).call(this);
}, "#onSelectEnd"), Gp = /* @__PURE__ */ d(function() {
  document.addEventListener("selectionchange", m(this, L, Vp).bind(this), {
    signal: this._signal
  });
}, "#addSelectionListener"), qp = /* @__PURE__ */ d(function() {
  const t = this._signal;
  window.addEventListener("focus", r(this, ka), {
    signal: t
  }), window.addEventListener("blur", r(this, Ra), {
    signal: t
  });
}, "#addFocusManager"), Xp = /* @__PURE__ */ d(function() {
  window.removeEventListener("focus", r(this, ka)), window.removeEventListener("blur", r(this, Ra));
}, "#removeFocusManager"), vc = /* @__PURE__ */ d(function() {
  const t = this._signal;
  window.addEventListener("keydown", r(this, Da), {
    signal: t
  }), window.addEventListener("keyup", r(this, Fa), {
    signal: t
  });
}, "#addKeyboardManager"), Yp = /* @__PURE__ */ d(function() {
  window.removeEventListener("keydown", r(this, Da)), window.removeEventListener("keyup", r(this, Fa));
}, "#removeKeyboardManager"), yc = /* @__PURE__ */ d(function() {
  const t = this._signal;
  document.addEventListener("copy", r(this, Ma), {
    signal: t
  }), document.addEventListener("cut", r(this, Ia), {
    signal: t
  }), document.addEventListener("paste", r(this, Pa), {
    signal: t
  });
}, "#addCopyPasteListeners"), wc = /* @__PURE__ */ d(function() {
  document.removeEventListener("copy", r(this, Ma)), document.removeEventListener("cut", r(this, Ia)), document.removeEventListener("paste", r(this, Pa));
}, "#removeCopyPasteListeners"), Kp = /* @__PURE__ */ d(function() {
  const t = this._signal;
  document.addEventListener("dragover", this.dragOver.bind(this), {
    signal: t
  }), document.addEventListener("drop", this.drop.bind(this), {
    signal: t
  });
}, "#addDragAndDropListeners"), Vt = /* @__PURE__ */ d(function(t) {
  Object.entries(t).some(([s, i]) => r(this, Ua)[s] !== i) && (this._eventBus.dispatch("annotationeditorstateschanged", {
    source: this,
    details: Object.assign(r(this, Ua), t)
  }), r(this, xt) === G.HIGHLIGHT && t.hasSelectedEditor === !1 && m(this, L, Ws).call(this, [[N.HIGHLIGHT_FREE, !0]]));
}, "#dispatchUpdateStates"), Ws = /* @__PURE__ */ d(function(t) {
  this._eventBus.dispatch("annotationeditorparamschanged", {
    source: this,
    details: t
  });
}, "#dispatchUpdateUI"), Qp = /* @__PURE__ */ d(function() {
  if (!r(this, Js)) {
    g(this, Js, !0);
    for (const t of r(this, kt).values())
      t.enable();
    for (const t of r(this, At).values())
      t.enable();
  }
}, "#enableAll"), Jp = /* @__PURE__ */ d(function() {
  if (this.unselectAll(), r(this, Js)) {
    g(this, Js, !1);
    for (const t of r(this, kt).values())
      t.disable();
    for (const t of r(this, At).values())
      t.disable();
  }
}, "#disableAll"), _c = /* @__PURE__ */ d(function(t) {
  const e = r(this, kt).get(t.pageIndex);
  e ? e.addOrRebuild(t) : (this.addEditor(t), this.addToAnnotationStorage(t));
}, "#addEditorToLayer"), Zp = /* @__PURE__ */ d(function() {
  let t = null;
  for (t of r(this, J))
    ;
  return t;
}, "#lastSelectedEditor"), Wr = /* @__PURE__ */ d(function() {
  if (r(this, At).size === 0)
    return !0;
  if (r(this, At).size === 1)
    for (const t of r(this, At).values())
      return t.isEmpty();
  return !1;
}, "#isEmpty"), Ec = /* @__PURE__ */ d(function(t) {
  for (const e of r(this, J))
    e.unselect();
  r(this, J).clear();
  for (const e of t)
    e.isEmpty() || (r(this, J).add(e), e.select());
  m(this, L, Vt).call(this, {
    hasSelectedEditor: this.hasSelection
  });
}, "#selectEditors"), d(Ci, "AnnotationEditorUIManager"), U(Ci, "TRANSLATE_SMALL", 1), U(Ci, "TRANSLATE_BIG", 10);
let Ln = Ci;
var ps, gs, xe, ms, ae, Xn, Te, $a, Sc;
const He = class He {
  constructor(t) {
    A(this, $a);
    A(this, ps, "");
    A(this, gs, !1);
    A(this, xe, null);
    A(this, ms, null);
    A(this, ae, null);
    A(this, Xn, !1);
    A(this, Te, null);
    g(this, Te, t);
  }
  static initialize(t) {
    He._l10nPromise || (He._l10nPromise = t);
  }
  async render() {
    const t = g(this, xe, document.createElement("button"));
    t.className = "altText";
    const e = await He._l10nPromise.get("pdfjs-editor-alt-text-button-label");
    t.textContent = e, t.setAttribute("aria-label", e), t.tabIndex = "0";
    const s = r(this, Te)._uiManager._signal;
    t.addEventListener("contextmenu", ee, {
      signal: s
    }), t.addEventListener("pointerdown", (n) => n.stopPropagation(), {
      signal: s
    });
    const i = /* @__PURE__ */ d((n) => {
      n.preventDefault(), r(this, Te)._uiManager.editAltText(r(this, Te));
    }, "onClick");
    return t.addEventListener("click", i, {
      capture: !0,
      signal: s
    }), t.addEventListener("keydown", (n) => {
      n.target === t && n.key === "Enter" && (g(this, Xn, !0), i(n));
    }, {
      signal: s
    }), await m(this, $a, Sc).call(this), t;
  }
  finish() {
    r(this, xe) && (r(this, xe).focus({
      focusVisible: r(this, Xn)
    }), g(this, Xn, !1));
  }
  isEmpty() {
    return !r(this, ps) && !r(this, gs);
  }
  get data() {
    return {
      altText: r(this, ps),
      decorative: r(this, gs)
    };
  }
  set data({
    altText: t,
    decorative: e
  }) {
    r(this, ps) === t && r(this, gs) === e || (g(this, ps, t), g(this, gs, e), m(this, $a, Sc).call(this));
  }
  toggle(t = !1) {
    r(this, xe) && (!t && r(this, ae) && (clearTimeout(r(this, ae)), g(this, ae, null)), r(this, xe).disabled = !t);
  }
  destroy() {
    var t;
    (t = r(this, xe)) == null || t.remove(), g(this, xe, null), g(this, ms, null);
  }
};
ps = new WeakMap(), gs = new WeakMap(), xe = new WeakMap(), ms = new WeakMap(), ae = new WeakMap(), Xn = new WeakMap(), Te = new WeakMap(), $a = new WeakSet(), Sc = /* @__PURE__ */ d(async function() {
  var i;
  const t = r(this, xe);
  if (!t)
    return;
  if (!r(this, ps) && !r(this, gs)) {
    t.classList.remove("done"), (i = r(this, ms)) == null || i.remove();
    return;
  }
  t.classList.add("done"), He._l10nPromise.get("pdfjs-editor-alt-text-edit-button-label").then((n) => {
    t.setAttribute("aria-label", n);
  });
  let e = r(this, ms);
  if (!e) {
    g(this, ms, e = document.createElement("span")), e.className = "tooltip", e.setAttribute("role", "tooltip");
    const n = e.id = `alt-text-tooltip-${r(this, Te).id}`;
    t.setAttribute("aria-describedby", n);
    const a = 100, o = r(this, Te)._uiManager._signal;
    o.addEventListener("abort", () => {
      clearTimeout(r(this, ae)), g(this, ae, null);
    }, {
      once: !0
    }), t.addEventListener("mouseenter", () => {
      g(this, ae, setTimeout(() => {
        g(this, ae, null), r(this, ms).classList.add("show"), r(this, Te)._reportTelemetry({
          action: "alt_text_tooltip"
        });
      }, a));
    }, {
      signal: o
    }), t.addEventListener("mouseleave", () => {
      var h;
      r(this, ae) && (clearTimeout(r(this, ae)), g(this, ae, null)), (h = r(this, ms)) == null || h.classList.remove("show");
    }, {
      signal: o
    });
  }
  e.innerText = r(this, gs) ? await He._l10nPromise.get("pdfjs-editor-alt-text-decorative-tooltip") : r(this, ps), e.parentNode || t.append(e);
  const s = r(this, Te).getImageForAltText();
  s == null || s.setAttribute("aria-describedby", e.id);
}, "#setState"), d(He, "AltText"), U(He, "_l10nPromise", null);
let Vh = He;
var Bi, Le, Bt, Yn, Ui, Mt, zi, Kn, Qn, Ut, ja, $i, ti, Wa, ji, bs, Ge, Jn, Zn, be, Va, Ll, j, Cc, Ga, xc, Tc, tg, eg, Lc, Rc, kc, sg, ig, ng, rg, Mc, Vr;
const Z = class Z {
  constructor(t) {
    A(this, j);
    A(this, Bi, null);
    A(this, Le, null);
    A(this, Bt, null);
    A(this, Yn, !1);
    A(this, Ui, !1);
    A(this, Mt, null);
    A(this, zi, null);
    A(this, Kn, this.focusin.bind(this));
    A(this, Qn, this.focusout.bind(this));
    A(this, Ut, null);
    A(this, ja, "");
    A(this, $i, !1);
    A(this, ti, null);
    A(this, Wa, !1);
    A(this, ji, !1);
    A(this, bs, !1);
    A(this, Ge, null);
    A(this, Jn, 0);
    A(this, Zn, 0);
    A(this, be, null);
    U(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
    U(this, "_isVisible", !0);
    U(this, "_uiManager", null);
    U(this, "_focusEventsAllowed", !0);
    U(this, "_l10nPromise", null);
    A(this, Va, !1);
    A(this, Ll, Z._zIndex++);
    this.constructor === Z && et("Cannot initialize AnnotationEditor."), this.parent = t.parent, this.id = t.id, this.width = this.height = null, this.pageIndex = t.parent.pageIndex, this.name = t.name, this.div = null, this._uiManager = t.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = t.isCentered, this._structTreeParentId = null;
    const {
      rotation: e,
      rawDims: {
        pageWidth: s,
        pageHeight: i,
        pageX: n,
        pageY: a
      }
    } = this.parent.viewport;
    this.rotation = e, this.pageRotation = (360 + e - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [s, i], this.pageTranslation = [n, a];
    const [o, h] = this.parentDimensions;
    this.x = t.x / o, this.y = t.y / h, this.isAttachedToDOM = !1, this.deleted = !1;
  }
  static get _resizerKeyboardManager() {
    const t = Z.prototype._resizeWithKeyboard, e = Ln.TRANSLATE_SMALL, s = Ln.TRANSLATE_BIG;
    return X(this, "_resizerKeyboardManager", new Tn([[["ArrowLeft", "mac+ArrowLeft"], t, {
      args: [-e, 0]
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t, {
      args: [-s, 0]
    }], [["ArrowRight", "mac+ArrowRight"], t, {
      args: [e, 0]
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t, {
      args: [s, 0]
    }], [["ArrowUp", "mac+ArrowUp"], t, {
      args: [0, -e]
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t, {
      args: [0, -s]
    }], [["ArrowDown", "mac+ArrowDown"], t, {
      args: [0, e]
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t, {
      args: [0, s]
    }], [["Escape", "mac+Escape"], Z.prototype._stopResizingWithKeyboard]]));
  }
  get editorType() {
    return Object.getPrototypeOf(this).constructor._type;
  }
  static get _defaultLineColor() {
    return X(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }
  static deleteAnnotationElement(t) {
    const e = new Ic({
      id: t.parent.getNextId(),
      parent: t.parent,
      uiManager: t._uiManager
    });
    e.annotationElementId = t.annotationElementId, e.deleted = !0, e._uiManager.addToAnnotationStorage(e);
  }
  static initialize(t, e, s) {
    if (Z._l10nPromise || (Z._l10nPromise = new Map(["pdfjs-editor-alt-text-button-label", "pdfjs-editor-alt-text-edit-button-label", "pdfjs-editor-alt-text-decorative-tooltip", "pdfjs-editor-resizer-label-topLeft", "pdfjs-editor-resizer-label-topMiddle", "pdfjs-editor-resizer-label-topRight", "pdfjs-editor-resizer-label-middleRight", "pdfjs-editor-resizer-label-bottomRight", "pdfjs-editor-resizer-label-bottomMiddle", "pdfjs-editor-resizer-label-bottomLeft", "pdfjs-editor-resizer-label-middleLeft"].map((n) => [n, t.get(n.replaceAll(/([A-Z])/g, (a) => `-${a.toLowerCase()}`))]))), s != null && s.strings)
      for (const n of s.strings)
        Z._l10nPromise.set(n, t.get(n));
    if (Z._borderLineWidth !== -1)
      return;
    const i = getComputedStyle(document.documentElement);
    Z._borderLineWidth = parseFloat(i.getPropertyValue("--outline-width")) || 0;
  }
  static updateDefaultParams(t, e) {
  }
  static get defaultPropertiesToUpdate() {
    return [];
  }
  static isHandlingMimeForPasting(t) {
    return !1;
  }
  static paste(t, e) {
    et("Not implemented");
  }
  get propertiesToUpdate() {
    return [];
  }
  get _isDraggable() {
    return r(this, Va);
  }
  set _isDraggable(t) {
    var e;
    g(this, Va, t), (e = this.div) == null || e.classList.toggle("draggable", t);
  }
  get isEnterHandled() {
    return !0;
  }
  center() {
    const [t, e] = this.pageDimensions;
    switch (this.parentRotation) {
      case 90:
        this.x -= this.height * e / (t * 2), this.y += this.width * t / (e * 2);
        break;
      case 180:
        this.x += this.width / 2, this.y += this.height / 2;
        break;
      case 270:
        this.x += this.height * e / (t * 2), this.y -= this.width * t / (e * 2);
        break;
      default:
        this.x -= this.width / 2, this.y -= this.height / 2;
        break;
    }
    this.fixAndSetPosition();
  }
  addCommands(t) {
    this._uiManager.addCommands(t);
  }
  get currentLayer() {
    return this._uiManager.currentLayer;
  }
  setInBackground() {
    this.div.style.zIndex = 0;
  }
  setInForeground() {
    this.div.style.zIndex = r(this, Ll);
  }
  setParent(t) {
    t !== null ? (this.pageIndex = t.pageIndex, this.pageDimensions = t.pageDimensions) : m(this, j, Vr).call(this), this.parent = t;
  }
  focusin(t) {
    this._focusEventsAllowed && (r(this, $i) ? g(this, $i, !1) : this.parent.setSelected(this));
  }
  focusout(t) {
    var s;
    if (!this._focusEventsAllowed || !this.isAttachedToDOM)
      return;
    const e = t.relatedTarget;
    e != null && e.closest(`#${this.id}`) || (t.preventDefault(), (s = this.parent) != null && s.isMultipleSelection || this.commitOrRemove());
  }
  commitOrRemove() {
    this.isEmpty() ? this.remove() : this.commit();
  }
  commit() {
    this.addToAnnotationStorage();
  }
  addToAnnotationStorage() {
    this._uiManager.addToAnnotationStorage(this);
  }
  setAt(t, e, s, i) {
    const [n, a] = this.parentDimensions;
    [s, i] = this.screenToPageTranslation(s, i), this.x = (t + s) / n, this.y = (e + i) / a, this.fixAndSetPosition();
  }
  translate(t, e) {
    m(this, j, Cc).call(this, this.parentDimensions, t, e);
  }
  translateInPage(t, e) {
    r(this, ti) || g(this, ti, [this.x, this.y]), m(this, j, Cc).call(this, this.pageDimensions, t, e), this.div.scrollIntoView({
      block: "nearest"
    });
  }
  drag(t, e) {
    r(this, ti) || g(this, ti, [this.x, this.y]);
    const [s, i] = this.parentDimensions;
    if (this.x += t / s, this.y += e / i, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
      const {
        x: l,
        y: c
      } = this.div.getBoundingClientRect();
      this.parent.findNewParent(this, l, c) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
    }
    let {
      x: n,
      y: a
    } = this;
    const [o, h] = this.getBaseTranslation();
    n += o, a += h, this.div.style.left = `${(100 * n).toFixed(2)}%`, this.div.style.top = `${(100 * a).toFixed(2)}%`, this.div.scrollIntoView({
      block: "nearest"
    });
  }
  get _hasBeenMoved() {
    return !!r(this, ti) && (r(this, ti)[0] !== this.x || r(this, ti)[1] !== this.y);
  }
  getBaseTranslation() {
    const [t, e] = this.parentDimensions, {
      _borderLineWidth: s
    } = Z, i = s / t, n = s / e;
    switch (this.rotation) {
      case 90:
        return [-i, n];
      case 180:
        return [i, n];
      case 270:
        return [i, -n];
      default:
        return [-i, -n];
    }
  }
  get _mustFixPosition() {
    return !0;
  }
  fixAndSetPosition(t = this.rotation) {
    const [e, s] = this.pageDimensions;
    let {
      x: i,
      y: n,
      width: a,
      height: o
    } = this;
    if (a *= e, o *= s, i *= e, n *= s, this._mustFixPosition)
      switch (t) {
        case 0:
          i = Math.max(0, Math.min(e - a, i)), n = Math.max(0, Math.min(s - o, n));
          break;
        case 90:
          i = Math.max(0, Math.min(e - o, i)), n = Math.min(s, Math.max(a, n));
          break;
        case 180:
          i = Math.min(e, Math.max(a, i)), n = Math.min(s, Math.max(o, n));
          break;
        case 270:
          i = Math.min(e, Math.max(o, i)), n = Math.max(0, Math.min(s - a, n));
          break;
      }
    this.x = i /= e, this.y = n /= s;
    const [h, l] = this.getBaseTranslation();
    i += h, n += l;
    const {
      style: c
    } = this.div;
    c.left = `${(100 * i).toFixed(2)}%`, c.top = `${(100 * n).toFixed(2)}%`, this.moveInDOM();
  }
  screenToPageTranslation(t, e) {
    var s;
    return m(s = Z, Ga, xc).call(s, t, e, this.parentRotation);
  }
  pageTranslationToScreen(t, e) {
    var s;
    return m(s = Z, Ga, xc).call(s, t, e, 360 - this.parentRotation);
  }
  get parentScale() {
    return this._uiManager.viewParameters.realScale;
  }
  get parentRotation() {
    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
  }
  get parentDimensions() {
    const {
      parentScale: t,
      pageDimensions: [e, s]
    } = this, i = e * t, n = s * t;
    return jt.isCSSRoundSupported ? [Math.round(i), Math.round(n)] : [i, n];
  }
  setDims(t, e) {
    const [s, i] = this.parentDimensions;
    this.div.style.width = `${(100 * t / s).toFixed(2)}%`, r(this, Ui) || (this.div.style.height = `${(100 * e / i).toFixed(2)}%`);
  }
  fixDims() {
    const {
      style: t
    } = this.div, {
      height: e,
      width: s
    } = t, i = s.endsWith("%"), n = !r(this, Ui) && e.endsWith("%");
    if (i && n)
      return;
    const [a, o] = this.parentDimensions;
    i || (t.width = `${(100 * parseFloat(s) / a).toFixed(2)}%`), !r(this, Ui) && !n && (t.height = `${(100 * parseFloat(e) / o).toFixed(2)}%`);
  }
  getInitialTranslation() {
    return [0, 0];
  }
  altTextFinish() {
    var t;
    (t = r(this, Bt)) == null || t.finish();
  }
  async addEditToolbar() {
    return r(this, Ut) || r(this, ji) ? r(this, Ut) : (g(this, Ut, new cc(this)), this.div.append(r(this, Ut).render()), r(this, Bt) && r(this, Ut).addAltTextButton(await r(this, Bt).render()), r(this, Ut));
  }
  removeEditToolbar() {
    var t;
    r(this, Ut) && (r(this, Ut).remove(), g(this, Ut, null), (t = r(this, Bt)) == null || t.destroy());
  }
  getClientDimensions() {
    return this.div.getBoundingClientRect();
  }
  async addAltTextButton() {
    r(this, Bt) || (Vh.initialize(Z._l10nPromise), g(this, Bt, new Vh(this)), r(this, Bi) && (r(this, Bt).data = r(this, Bi), g(this, Bi, null)), await this.addEditToolbar());
  }
  get altTextData() {
    var t;
    return (t = r(this, Bt)) == null ? void 0 : t.data;
  }
  set altTextData(t) {
    r(this, Bt) && (r(this, Bt).data = t);
  }
  hasAltText() {
    var t;
    return !((t = r(this, Bt)) != null && t.isEmpty());
  }
  render() {
    this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.tabIndex = r(this, Yn) ? -1 : 0, this._isVisible || this.div.classList.add("hidden"), this.setInForeground();
    const t = this._uiManager._signal;
    this.div.addEventListener("focusin", r(this, Kn), {
      signal: t
    }), this.div.addEventListener("focusout", r(this, Qn), {
      signal: t
    });
    const [e, s] = this.parentDimensions;
    this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * s / e).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * e / s).toFixed(2)}%`);
    const [i, n] = this.getInitialTranslation();
    return this.translate(i, n), Wh(this, this.div, ["pointerdown"]), this.div;
  }
  pointerdown(t) {
    const {
      isMac: e
    } = jt.platform;
    if (t.button !== 0 || t.ctrlKey && e) {
      t.preventDefault();
      return;
    }
    if (g(this, $i, !0), this._isDraggable) {
      m(this, j, sg).call(this, t);
      return;
    }
    m(this, j, kc).call(this, t);
  }
  moveInDOM() {
    r(this, Ge) && clearTimeout(r(this, Ge)), g(this, Ge, setTimeout(() => {
      var t;
      g(this, Ge, null), (t = this.parent) == null || t.moveEditorInDOM(this);
    }, 0));
  }
  _setParentAndPosition(t, e, s) {
    t.changeParent(this), this.x = e, this.y = s, this.fixAndSetPosition();
  }
  getRect(t, e, s = this.rotation) {
    const i = this.parentScale, [n, a] = this.pageDimensions, [o, h] = this.pageTranslation, l = t / i, c = e / i, u = this.x * n, p = this.y * a, b = this.width * n, v = this.height * a;
    switch (s) {
      case 0:
        return [u + l + o, a - p - c - v + h, u + l + b + o, a - p - c + h];
      case 90:
        return [u + c + o, a - p + l + h, u + c + v + o, a - p + l + b + h];
      case 180:
        return [u - l - b + o, a - p + c + h, u - l + o, a - p + c + v + h];
      case 270:
        return [u - c - v + o, a - p - l - b + h, u - c + o, a - p - l + h];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getRectInCurrentCoords(t, e) {
    const [s, i, n, a] = t, o = n - s, h = a - i;
    switch (this.rotation) {
      case 0:
        return [s, e - a, o, h];
      case 90:
        return [s, e - i, h, o];
      case 180:
        return [n, e - i, o, h];
      case 270:
        return [n, e - a, h, o];
      default:
        throw new Error("Invalid rotation");
    }
  }
  onceAdded() {
  }
  isEmpty() {
    return !1;
  }
  enableEditMode() {
    g(this, ji, !0);
  }
  disableEditMode() {
    g(this, ji, !1);
  }
  isInEditMode() {
    return r(this, ji);
  }
  shouldGetKeyboardEvents() {
    return r(this, bs);
  }
  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }
  rebuild() {
    var e, s;
    const t = this._uiManager._signal;
    (e = this.div) == null || e.addEventListener("focusin", r(this, Kn), {
      signal: t
    }), (s = this.div) == null || s.addEventListener("focusout", r(this, Qn), {
      signal: t
    });
  }
  rotate(t) {
  }
  serialize(t = !1, e = null) {
    et("An editor must be serializable");
  }
  static deserialize(t, e, s) {
    const i = new this.prototype.constructor({
      parent: e,
      id: e.getNextId(),
      uiManager: s
    });
    i.rotation = t.rotation, g(i, Bi, t.accessibilityData);
    const [n, a] = i.pageDimensions, [o, h, l, c] = i.getRectInCurrentCoords(t.rect, a);
    return i.x = o / n, i.y = h / a, i.width = l / n, i.height = c / a, i;
  }
  get hasBeenModified() {
    return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
  }
  remove() {
    if (this.div.removeEventListener("focusin", r(this, Kn)), this.div.removeEventListener("focusout", r(this, Qn)), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), r(this, Ge) && (clearTimeout(r(this, Ge)), g(this, Ge, null)), m(this, j, Vr).call(this), this.removeEditToolbar(), r(this, be)) {
      for (const t of r(this, be).values())
        clearTimeout(t);
      g(this, be, null);
    }
    this.parent = null;
  }
  get isResizable() {
    return !1;
  }
  makeResizable() {
    this.isResizable && (m(this, j, tg).call(this), r(this, Mt).classList.remove("hidden"), Wh(this, this.div, ["keydown"]));
  }
  get toolbarPosition() {
    return null;
  }
  keydown(t) {
    if (!this.isResizable || t.target !== this.div || t.key !== "Enter")
      return;
    this._uiManager.setSelected(this), g(this, zi, {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    });
    const e = r(this, Mt).children;
    if (!r(this, Le)) {
      g(this, Le, Array.from(e));
      const a = m(this, j, ig).bind(this), o = m(this, j, ng).bind(this), h = this._uiManager._signal;
      for (const l of r(this, Le)) {
        const c = l.getAttribute("data-resizer-name");
        l.setAttribute("role", "spinbutton"), l.addEventListener("keydown", a, {
          signal: h
        }), l.addEventListener("blur", o, {
          signal: h
        }), l.addEventListener("focus", m(this, j, rg).bind(this, c), {
          signal: h
        }), Z._l10nPromise.get(`pdfjs-editor-resizer-label-${c}`).then((u) => l.setAttribute("aria-label", u));
      }
    }
    const s = r(this, Le)[0];
    let i = 0;
    for (const a of e) {
      if (a === s)
        break;
      i++;
    }
    const n = (360 - this.rotation + this.parentRotation) % 360 / 90 * (r(this, Le).length / 4);
    if (n !== i) {
      if (n < i)
        for (let o = 0; o < i - n; o++)
          r(this, Mt).append(r(this, Mt).firstChild);
      else if (n > i)
        for (let o = 0; o < n - i; o++)
          r(this, Mt).firstChild.before(r(this, Mt).lastChild);
      let a = 0;
      for (const o of e) {
        const l = r(this, Le)[a++].getAttribute("data-resizer-name");
        Z._l10nPromise.get(`pdfjs-editor-resizer-label-${l}`).then((c) => o.setAttribute("aria-label", c));
      }
    }
    m(this, j, Mc).call(this, 0), g(this, bs, !0), r(this, Mt).firstChild.focus({
      focusVisible: !0
    }), t.preventDefault(), t.stopImmediatePropagation();
  }
  _resizeWithKeyboard(t, e) {
    r(this, bs) && m(this, j, Rc).call(this, r(this, ja), {
      movementX: t,
      movementY: e
    });
  }
  _stopResizingWithKeyboard() {
    m(this, j, Vr).call(this), this.div.focus();
  }
  select() {
    var t, e;
    if (this.makeResizable(), (t = this.div) == null || t.classList.add("selectedEditor"), !r(this, Ut)) {
      this.addEditToolbar().then(() => {
        var s, i;
        (s = this.div) != null && s.classList.contains("selectedEditor") && ((i = r(this, Ut)) == null || i.show());
      });
      return;
    }
    (e = r(this, Ut)) == null || e.show();
  }
  unselect() {
    var t, e, s, i;
    (t = r(this, Mt)) == null || t.classList.add("hidden"), (e = this.div) == null || e.classList.remove("selectedEditor"), (s = this.div) != null && s.contains(document.activeElement) && this._uiManager.currentLayer.div.focus({
      preventScroll: !0
    }), (i = r(this, Ut)) == null || i.hide();
  }
  updateParams(t, e) {
  }
  disableEditing() {
  }
  enableEditing() {
  }
  enterInEditMode() {
  }
  getImageForAltText() {
    return null;
  }
  get contentDiv() {
    return this.div;
  }
  get isEditing() {
    return r(this, Wa);
  }
  set isEditing(t) {
    g(this, Wa, t), this.parent && (t ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
  }
  setAspectRatio(t, e) {
    g(this, Ui, !0);
    const s = t / e, {
      style: i
    } = this.div;
    i.aspectRatio = s, i.height = "auto";
  }
  static get MIN_SIZE() {
    return 16;
  }
  static canCreateNewEmptyEditor() {
    return !0;
  }
  get telemetryInitialData() {
    return {
      action: "added"
    };
  }
  get telemetryFinalData() {
    return null;
  }
  _reportTelemetry(t, e = !1) {
    if (e) {
      r(this, be) || g(this, be, /* @__PURE__ */ new Map());
      const {
        action: s
      } = t;
      let i = r(this, be).get(s);
      i && clearTimeout(i), i = setTimeout(() => {
        this._reportTelemetry(t), r(this, be).delete(s), r(this, be).size === 0 && g(this, be, null);
      }, Z._telemetryTimeout), r(this, be).set(s, i);
      return;
    }
    t.type || (t.type = this.editorType), this._uiManager._eventBus.dispatch("reporttelemetry", {
      source: this,
      details: {
        type: "editing",
        data: t
      }
    });
  }
  show(t = this._isVisible) {
    this.div.classList.toggle("hidden", !t), this._isVisible = t;
  }
  enable() {
    this.div && (this.div.tabIndex = 0), g(this, Yn, !1);
  }
  disable() {
    this.div && (this.div.tabIndex = -1), g(this, Yn, !0);
  }
  renderAnnotationElement(t) {
    let e = t.container.querySelector(".annotationContent");
    if (!e)
      e = document.createElement("div"), e.classList.add("annotationContent", this.editorType), t.container.prepend(e);
    else if (e.nodeName === "CANVAS") {
      const s = e;
      e = document.createElement("div"), e.classList.add("annotationContent", this.editorType), s.before(e);
    }
    return e;
  }
  resetAnnotationElement(t) {
    const {
      firstChild: e
    } = t.container;
    e.nodeName === "DIV" && e.classList.contains("annotationContent") && e.remove();
  }
};
Bi = new WeakMap(), Le = new WeakMap(), Bt = new WeakMap(), Yn = new WeakMap(), Ui = new WeakMap(), Mt = new WeakMap(), zi = new WeakMap(), Kn = new WeakMap(), Qn = new WeakMap(), Ut = new WeakMap(), ja = new WeakMap(), $i = new WeakMap(), ti = new WeakMap(), Wa = new WeakMap(), ji = new WeakMap(), bs = new WeakMap(), Ge = new WeakMap(), Jn = new WeakMap(), Zn = new WeakMap(), be = new WeakMap(), Va = new WeakMap(), Ll = new WeakMap(), j = new WeakSet(), Cc = /* @__PURE__ */ d(function([t, e], s, i) {
  [s, i] = this.screenToPageTranslation(s, i), this.x += s / t, this.y += i / e, this.fixAndSetPosition();
}, "#translate"), Ga = new WeakSet(), xc = /* @__PURE__ */ d(function(t, e, s) {
  switch (s) {
    case 90:
      return [e, -t];
    case 180:
      return [-t, -e];
    case 270:
      return [-e, t];
    default:
      return [t, e];
  }
}, "#rotatePoint"), Tc = /* @__PURE__ */ d(function(t) {
  switch (t) {
    case 90: {
      const [e, s] = this.pageDimensions;
      return [0, -e / s, s / e, 0];
    }
    case 180:
      return [-1, 0, 0, -1];
    case 270: {
      const [e, s] = this.pageDimensions;
      return [0, e / s, -s / e, 0];
    }
    default:
      return [1, 0, 0, 1];
  }
}, "#getRotationMatrix"), tg = /* @__PURE__ */ d(function() {
  if (r(this, Mt))
    return;
  g(this, Mt, document.createElement("div")), r(this, Mt).classList.add("resizers");
  const t = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"], e = this._uiManager._signal;
  for (const s of t) {
    const i = document.createElement("div");
    r(this, Mt).append(i), i.classList.add("resizer", s), i.setAttribute("data-resizer-name", s), i.addEventListener("pointerdown", m(this, j, eg).bind(this, s), {
      signal: e
    }), i.addEventListener("contextmenu", ee, {
      signal: e
    }), i.tabIndex = -1;
  }
  this.div.prepend(r(this, Mt));
}, "#createResizers"), eg = /* @__PURE__ */ d(function(t, e) {
  var y;
  e.preventDefault();
  const {
    isMac: s
  } = jt.platform;
  if (e.button !== 0 || e.ctrlKey && s)
    return;
  (y = r(this, Bt)) == null || y.toggle(!1);
  const i = m(this, j, Rc).bind(this, t), n = this._isDraggable;
  this._isDraggable = !1;
  const a = this._uiManager._signal, o = {
    passive: !0,
    capture: !0,
    signal: a
  };
  this.parent.togglePointerEvents(!1), window.addEventListener("pointermove", i, o), window.addEventListener("contextmenu", ee, {
    signal: a
  });
  const h = this.x, l = this.y, c = this.width, u = this.height, p = this.parent.div.style.cursor, b = this.div.style.cursor;
  this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(e.target).cursor;
  const v = /* @__PURE__ */ d(() => {
    var _;
    this.parent.togglePointerEvents(!0), (_ = r(this, Bt)) == null || _.toggle(!0), this._isDraggable = n, window.removeEventListener("pointerup", v), window.removeEventListener("blur", v), window.removeEventListener("pointermove", i, o), window.removeEventListener("contextmenu", ee), this.parent.div.style.cursor = p, this.div.style.cursor = b, m(this, j, Lc).call(this, h, l, c, u);
  }, "pointerUpCallback");
  window.addEventListener("pointerup", v, {
    signal: a
  }), window.addEventListener("blur", v, {
    signal: a
  });
}, "#resizerPointerdown"), Lc = /* @__PURE__ */ d(function(t, e, s, i) {
  const n = this.x, a = this.y, o = this.width, h = this.height;
  n === t && a === e && o === s && h === i || this.addCommands({
    cmd: /* @__PURE__ */ d(() => {
      this.width = o, this.height = h, this.x = n, this.y = a;
      const [l, c] = this.parentDimensions;
      this.setDims(l * o, c * h), this.fixAndSetPosition();
    }, "cmd"),
    undo: /* @__PURE__ */ d(() => {
      this.width = s, this.height = i, this.x = t, this.y = e;
      const [l, c] = this.parentDimensions;
      this.setDims(l * s, c * i), this.fixAndSetPosition();
    }, "undo"),
    mustExec: !0
  });
}, "#addResizeToUndoStack"), Rc = /* @__PURE__ */ d(function(t, e) {
  const [s, i] = this.parentDimensions, n = this.x, a = this.y, o = this.width, h = this.height, l = Z.MIN_SIZE / s, c = Z.MIN_SIZE / i, u = /* @__PURE__ */ d((H) => Math.round(H * 1e4) / 1e4, "round"), p = m(this, j, Tc).call(this, this.rotation), b = /* @__PURE__ */ d((H, z) => [p[0] * H + p[2] * z, p[1] * H + p[3] * z], "transf"), v = m(this, j, Tc).call(this, 360 - this.rotation), y = /* @__PURE__ */ d((H, z) => [v[0] * H + v[2] * z, v[1] * H + v[3] * z], "invTransf");
  let _, w, E = !1, S = !1;
  switch (t) {
    case "topLeft":
      E = !0, _ = /* @__PURE__ */ d((H, z) => [0, 0], "getPoint"), w = /* @__PURE__ */ d((H, z) => [H, z], "getOpposite");
      break;
    case "topMiddle":
      _ = /* @__PURE__ */ d((H, z) => [H / 2, 0], "getPoint"), w = /* @__PURE__ */ d((H, z) => [H / 2, z], "getOpposite");
      break;
    case "topRight":
      E = !0, _ = /* @__PURE__ */ d((H, z) => [H, 0], "getPoint"), w = /* @__PURE__ */ d((H, z) => [0, z], "getOpposite");
      break;
    case "middleRight":
      S = !0, _ = /* @__PURE__ */ d((H, z) => [H, z / 2], "getPoint"), w = /* @__PURE__ */ d((H, z) => [0, z / 2], "getOpposite");
      break;
    case "bottomRight":
      E = !0, _ = /* @__PURE__ */ d((H, z) => [H, z], "getPoint"), w = /* @__PURE__ */ d((H, z) => [0, 0], "getOpposite");
      break;
    case "bottomMiddle":
      _ = /* @__PURE__ */ d((H, z) => [H / 2, z], "getPoint"), w = /* @__PURE__ */ d((H, z) => [H / 2, 0], "getOpposite");
      break;
    case "bottomLeft":
      E = !0, _ = /* @__PURE__ */ d((H, z) => [0, z], "getPoint"), w = /* @__PURE__ */ d((H, z) => [H, 0], "getOpposite");
      break;
    case "middleLeft":
      S = !0, _ = /* @__PURE__ */ d((H, z) => [0, z / 2], "getPoint"), w = /* @__PURE__ */ d((H, z) => [H, z / 2], "getOpposite");
      break;
  }
  const C = _(o, h), T = w(o, h);
  let x = b(...T);
  const k = u(n + x[0]), P = u(a + x[1]);
  let O = 1, q = 1, [F, ht] = this.screenToPageTranslation(e.movementX, e.movementY);
  if ([F, ht] = y(F / s, ht / i), E) {
    const H = Math.hypot(o, h);
    O = q = Math.max(Math.min(Math.hypot(T[0] - C[0] - F, T[1] - C[1] - ht) / H, 1 / o, 1 / h), l / o, c / h);
  } else S ? O = Math.max(l, Math.min(1, Math.abs(T[0] - C[0] - F))) / o : q = Math.max(c, Math.min(1, Math.abs(T[1] - C[1] - ht))) / h;
  const rt = u(o * O), at = u(h * q);
  x = b(...w(rt, at));
  const lt = k - x[0], Ft = P - x[1];
  this.width = rt, this.height = at, this.x = lt, this.y = Ft, this.setDims(s * rt, i * at), this.fixAndSetPosition();
}, "#resizerPointermove"), kc = /* @__PURE__ */ d(function(t) {
  const {
    isMac: e
  } = jt.platform;
  t.ctrlKey && !e || t.shiftKey || t.metaKey && e ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
}, "#selectOnPointerEvent"), sg = /* @__PURE__ */ d(function(t) {
  const e = this._uiManager.isSelected(this);
  this._uiManager.setUpDragSession();
  let s, i;
  const n = this._uiManager._signal;
  e && (this.div.classList.add("moving"), s = {
    passive: !0,
    capture: !0,
    signal: n
  }, g(this, Jn, t.clientX), g(this, Zn, t.clientY), i = /* @__PURE__ */ d((o) => {
    const {
      clientX: h,
      clientY: l
    } = o, [c, u] = this.screenToPageTranslation(h - r(this, Jn), l - r(this, Zn));
    g(this, Jn, h), g(this, Zn, l), this._uiManager.dragSelectedEditors(c, u);
  }, "pointerMoveCallback"), window.addEventListener("pointermove", i, s));
  const a = /* @__PURE__ */ d(() => {
    window.removeEventListener("pointerup", a), window.removeEventListener("blur", a), e && (this.div.classList.remove("moving"), window.removeEventListener("pointermove", i, s)), g(this, $i, !1), this._uiManager.endDragSession() || m(this, j, kc).call(this, t);
  }, "pointerUpCallback");
  window.addEventListener("pointerup", a, {
    signal: n
  }), window.addEventListener("blur", a, {
    signal: n
  });
}, "#setUpDragSession"), ig = /* @__PURE__ */ d(function(t) {
  Z._resizerKeyboardManager.exec(this, t);
}, "#resizerKeydown"), ng = /* @__PURE__ */ d(function(t) {
  var e;
  r(this, bs) && ((e = t.relatedTarget) == null ? void 0 : e.parentNode) !== r(this, Mt) && m(this, j, Vr).call(this);
}, "#resizerBlur"), rg = /* @__PURE__ */ d(function(t) {
  g(this, ja, r(this, bs) ? t : "");
}, "#resizerFocus"), Mc = /* @__PURE__ */ d(function(t) {
  if (r(this, Le))
    for (const e of r(this, Le))
      e.tabIndex = t;
}, "#setResizerTabIndex"), Vr = /* @__PURE__ */ d(function() {
  if (g(this, bs, !1), m(this, j, Mc).call(this, -1), r(this, zi)) {
    const {
      savedX: t,
      savedY: e,
      savedWidth: s,
      savedHeight: i
    } = r(this, zi);
    m(this, j, Lc).call(this, t, e, s, i), g(this, zi, null);
  }
}, "#stopResizing"), A(Z, Ga), d(Z, "AnnotationEditor"), U(Z, "_borderLineWidth", -1), U(Z, "_colorManager", new bc()), U(Z, "_zIndex", 1), U(Z, "_telemetryTimeout", 1e3);
let Q = Z;
const Wu = class Wu extends Q {
  constructor(t) {
    super(t), this.annotationElementId = t.annotationElementId, this.deleted = !0;
  }
  serialize() {
    return {
      id: this.annotationElementId,
      deleted: !0,
      pageIndex: this.pageIndex
    };
  }
};
d(Wu, "FakeEditor");
let Ic = Wu;
const vp = 3285377520, pe = 4294901760, Oe = 65535, Vu = class Vu {
  constructor(t) {
    this.h1 = t ? t & 4294967295 : vp, this.h2 = t ? t & 4294967295 : vp;
  }
  update(t) {
    let e, s;
    if (typeof t == "string") {
      e = new Uint8Array(t.length * 2), s = 0;
      for (let y = 0, _ = t.length; y < _; y++) {
        const w = t.charCodeAt(y);
        w <= 255 ? e[s++] = w : (e[s++] = w >>> 8, e[s++] = w & 255);
      }
    } else if (ArrayBuffer.isView(t))
      e = t.slice(), s = e.byteLength;
    else
      throw new Error("Invalid data format, must be a string or TypedArray.");
    const i = s >> 2, n = s - i * 4, a = new Uint32Array(e.buffer, 0, i);
    let o = 0, h = 0, l = this.h1, c = this.h2;
    const u = 3432918353, p = 461845907, b = u & Oe, v = p & Oe;
    for (let y = 0; y < i; y++)
      y & 1 ? (o = a[y], o = o * u & pe | o * b & Oe, o = o << 15 | o >>> 17, o = o * p & pe | o * v & Oe, l ^= o, l = l << 13 | l >>> 19, l = l * 5 + 3864292196) : (h = a[y], h = h * u & pe | h * b & Oe, h = h << 15 | h >>> 17, h = h * p & pe | h * v & Oe, c ^= h, c = c << 13 | c >>> 19, c = c * 5 + 3864292196);
    switch (o = 0, n) {
      case 3:
        o ^= e[i * 4 + 2] << 16;
      case 2:
        o ^= e[i * 4 + 1] << 8;
      case 1:
        o ^= e[i * 4], o = o * u & pe | o * b & Oe, o = o << 15 | o >>> 17, o = o * p & pe | o * v & Oe, i & 1 ? l ^= o : c ^= o;
    }
    this.h1 = l, this.h2 = c;
  }
  hexdigest() {
    let t = this.h1, e = this.h2;
    return t ^= e >>> 1, t = t * 3981806797 & pe | t * 36045 & Oe, e = e * 4283543511 & pe | ((e << 16 | t >>> 16) * 2950163797 & pe) >>> 16, t ^= e >>> 1, t = t * 444984403 & pe | t * 60499 & Oe, e = e * 3301882366 & pe | ((e << 16 | t >>> 16) * 3120437893 & pe) >>> 16, t ^= e >>> 1, (t >>> 0).toString(16).padStart(8, "0") + (e >>> 0).toString(16).padStart(8, "0");
  }
};
d(Vu, "MurmurHash3_64");
let Gh = Vu;
const Pc = Object.freeze({
  map: null,
  hash: "",
  transfer: void 0
});
var Wi, Vi, Tt, Rl, ag;
const Gu = class Gu {
  constructor() {
    A(this, Rl);
    A(this, Wi, !1);
    A(this, Vi, null);
    A(this, Tt, /* @__PURE__ */ new Map());
    this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
  }
  getValue(t, e) {
    const s = r(this, Tt).get(t);
    return s === void 0 ? e : Object.assign(e, s);
  }
  getRawValue(t) {
    return r(this, Tt).get(t);
  }
  remove(t) {
    if (r(this, Tt).delete(t), r(this, Tt).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
      for (const e of r(this, Tt).values())
        if (e instanceof Q)
          return;
      this.onAnnotationEditor(null);
    }
  }
  setValue(t, e) {
    const s = r(this, Tt).get(t);
    let i = !1;
    if (s !== void 0)
      for (const [n, a] of Object.entries(e))
        s[n] !== a && (i = !0, s[n] = a);
    else
      i = !0, r(this, Tt).set(t, e);
    i && m(this, Rl, ag).call(this), e instanceof Q && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(e.constructor._type);
  }
  has(t) {
    return r(this, Tt).has(t);
  }
  getAll() {
    return r(this, Tt).size > 0 ? vu(r(this, Tt)) : null;
  }
  setAll(t) {
    for (const [e, s] of Object.entries(t))
      this.setValue(e, s);
  }
  get size() {
    return r(this, Tt).size;
  }
  resetModified() {
    r(this, Wi) && (g(this, Wi, !1), typeof this.onResetModified == "function" && this.onResetModified());
  }
  get print() {
    return new qh(this);
  }
  get serializable() {
    if (r(this, Tt).size === 0)
      return Pc;
    const t = /* @__PURE__ */ new Map(), e = new Gh(), s = [], i = /* @__PURE__ */ Object.create(null);
    let n = !1;
    for (const [a, o] of r(this, Tt)) {
      const h = o instanceof Q ? o.serialize(!1, i) : o;
      h && (t.set(a, h), e.update(`${a}:${JSON.stringify(h)}`), n || (n = !!h.bitmap));
    }
    if (n)
      for (const a of t.values())
        a.bitmap && s.push(a.bitmap);
    return t.size > 0 ? {
      map: t,
      hash: e.hexdigest(),
      transfer: s
    } : Pc;
  }
  get editorStats() {
    let t = null;
    const e = /* @__PURE__ */ new Map();
    for (const s of r(this, Tt).values()) {
      if (!(s instanceof Q))
        continue;
      const i = s.telemetryFinalData;
      if (!i)
        continue;
      const {
        type: n
      } = i;
      e.has(n) || e.set(n, Object.getPrototypeOf(s).constructor), t || (t = /* @__PURE__ */ Object.create(null));
      const a = t[n] || (t[n] = /* @__PURE__ */ new Map());
      for (const [o, h] of Object.entries(i)) {
        if (o === "type")
          continue;
        let l = a.get(o);
        l || (l = /* @__PURE__ */ new Map(), a.set(o, l));
        const c = l.get(h) ?? 0;
        l.set(h, c + 1);
      }
    }
    for (const [s, i] of e)
      t[s] = i.computeTelemetryFinalData(t[s]);
    return t;
  }
  resetModifiedIds() {
    g(this, Vi, null);
  }
  get modifiedIds() {
    if (r(this, Vi))
      return r(this, Vi);
    const t = [];
    for (const e of r(this, Tt).values())
      !(e instanceof Q) || !e.annotationElementId || !e.serialize() || t.push(e.annotationElementId);
    return g(this, Vi, {
      ids: new Set(t),
      hash: t.join(",")
    });
  }
};
Wi = new WeakMap(), Vi = new WeakMap(), Tt = new WeakMap(), Rl = new WeakSet(), ag = /* @__PURE__ */ d(function() {
  r(this, Wi) || (g(this, Wi, !0), typeof this.onSetModified == "function" && this.onSetModified());
}, "#setModified"), d(Gu, "AnnotationStorage");
let ua = Gu;
var qa;
const qu = class qu extends ua {
  constructor(e) {
    super();
    A(this, qa);
    const {
      map: s,
      hash: i,
      transfer: n
    } = e.serializable, a = structuredClone(s, n ? {
      transfer: n
    } : null);
    g(this, qa, {
      map: a,
      hash: i,
      transfer: n
    });
  }
  get print() {
    et("Should not call PrintAnnotationStorage.print");
  }
  get serializable() {
    return r(this, qa);
  }
  get modifiedIds() {
    return X(this, "modifiedIds", {
      ids: /* @__PURE__ */ new Set(),
      hash: ""
    });
  }
};
qa = new WeakMap(), d(qu, "PrintAnnotationStorage");
let qh = qu;
var tr;
const Xu = class Xu {
  constructor({
    ownerDocument: t = globalThis.document,
    styleElement: e = null
  }) {
    A(this, tr, /* @__PURE__ */ new Set());
    this._document = t, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
  }
  addNativeFontFace(t) {
    this.nativeFontFaces.add(t), this._document.fonts.add(t);
  }
  removeNativeFontFace(t) {
    this.nativeFontFaces.delete(t), this._document.fonts.delete(t);
  }
  insertRule(t) {
    this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
    const e = this.styleElement.sheet;
    e.insertRule(t, e.cssRules.length);
  }
  clear() {
    for (const t of this.nativeFontFaces)
      this._document.fonts.delete(t);
    this.nativeFontFaces.clear(), r(this, tr).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
  }
  async loadSystemFont({
    systemFontInfo: t,
    _inspectFont: e
  }) {
    if (!(!t || r(this, tr).has(t.loadedName))) {
      if (_t(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
        const {
          loadedName: s,
          src: i,
          style: n
        } = t, a = new FontFace(s, i, n);
        this.addNativeFontFace(a);
        try {
          await a.load(), r(this, tr).add(s), e == null || e(t);
        } catch {
          $(`Cannot load system font: ${t.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(a);
        }
        return;
      }
      et("Not implemented: loadSystemFont without the Font Loading API.");
    }
  }
  async bind(t) {
    if (t.attached || t.missingFile && !t.systemFontInfo)
      return;
    if (t.attached = !0, t.systemFontInfo) {
      await this.loadSystemFont(t);
      return;
    }
    if (this.isFontLoadingAPISupported) {
      const s = t.createNativeFontFace();
      if (s) {
        this.addNativeFontFace(s);
        try {
          await s.loaded;
        } catch (i) {
          throw $(`Failed to load font '${s.family}': '${i}'.`), t.disableFontFace = !0, i;
        }
      }
      return;
    }
    const e = t.createFontFaceRule();
    if (e) {
      if (this.insertRule(e), this.isSyncFontLoadingSupported)
        return;
      await new Promise((s) => {
        const i = this._queueLoadingCallback(s);
        this._prepareFontLoadEvent(t, i);
      });
    }
  }
  get isFontLoadingAPISupported() {
    var e;
    const t = !!((e = this._document) != null && e.fonts);
    return X(this, "isFontLoadingAPISupported", t);
  }
  get isSyncFontLoadingSupported() {
    let t = !1;
    return ($t || typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.userAgent) == "string" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (t = !0), X(this, "isSyncFontLoadingSupported", t);
  }
  _queueLoadingCallback(t) {
    function e() {
      for (_t(!i.done, "completeRequest() cannot be called twice."), i.done = !0; s.length > 0 && s[0].done; ) {
        const n = s.shift();
        setTimeout(n.callback, 0);
      }
    }
    d(e, "completeRequest");
    const {
      loadingRequests: s
    } = this, i = {
      done: !1,
      complete: e,
      callback: t
    };
    return s.push(i), i;
  }
  get _loadTestFont() {
    const t = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
    return X(this, "_loadTestFont", t);
  }
  _prepareFontLoadEvent(t, e) {
    function s(C, T) {
      return C.charCodeAt(T) << 24 | C.charCodeAt(T + 1) << 16 | C.charCodeAt(T + 2) << 8 | C.charCodeAt(T + 3) & 255;
    }
    d(s, "int32");
    function i(C, T, x, k) {
      const P = C.substring(0, T), O = C.substring(T + x);
      return P + k + O;
    }
    d(i, "spliceString");
    let n, a;
    const o = this._document.createElement("canvas");
    o.width = 1, o.height = 1;
    const h = o.getContext("2d");
    let l = 0;
    function c(C, T) {
      if (++l > 30) {
        $("Load test font never loaded."), T();
        return;
      }
      if (h.font = "30px " + C, h.fillText(".", 0, 20), h.getImageData(0, 0, 1, 1).data[3] > 0) {
        T();
        return;
      }
      setTimeout(c.bind(null, C, T));
    }
    d(c, "isFontReady");
    const u = `lt${Date.now()}${this.loadTestFontId++}`;
    let p = this._loadTestFont;
    p = i(p, 976, u.length, u);
    const v = 16, y = 1482184792;
    let _ = s(p, v);
    for (n = 0, a = u.length - 3; n < a; n += 4)
      _ = _ - y + s(u, n) | 0;
    n < u.length && (_ = _ - y + s(u + "XXX", n) | 0), p = i(p, v, 4, vm(_));
    const w = `url(data:font/opentype;base64,${btoa(p)});`, E = `@font-face {font-family:"${u}";src:${w}}`;
    this.insertRule(E);
    const S = this._document.createElement("div");
    S.style.visibility = "hidden", S.style.width = S.style.height = "10px", S.style.position = "absolute", S.style.top = S.style.left = "0px";
    for (const C of [t.loadedName, u]) {
      const T = this._document.createElement("span");
      T.textContent = "Hi", T.style.fontFamily = C, S.append(T);
    }
    this._document.body.append(S), c(u, () => {
      S.remove(), e.complete();
    });
  }
};
tr = new WeakMap(), d(Xu, "FontLoader");
let Dc = Xu;
const Yu = class Yu {
  constructor(t, {
    disableFontFace: e = !1,
    inspectFont: s = null
  }) {
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
    for (const i in t)
      this[i] = t[i];
    this.disableFontFace = e === !0, this._inspectFont = s;
  }
  createNativeFontFace() {
    var e;
    if (!this.data || this.disableFontFace)
      return null;
    let t;
    if (!this.cssFontInfo)
      t = new FontFace(this.loadedName, this.data, {});
    else {
      const s = {
        weight: this.cssFontInfo.fontWeight
      };
      this.cssFontInfo.italicAngle && (s.style = `oblique ${this.cssFontInfo.italicAngle}deg`), t = new FontFace(this.cssFontInfo.fontFamily, this.data, s);
    }
    return (e = this._inspectFont) == null || e.call(this, this), t;
  }
  createFontFaceRule() {
    var i;
    if (!this.data || this.disableFontFace)
      return null;
    const t = Pp(this.data), e = `url(data:${this.mimetype};base64,${btoa(t)});`;
    let s;
    if (!this.cssFontInfo)
      s = `@font-face {font-family:"${this.loadedName}";src:${e}}`;
    else {
      let n = `font-weight: ${this.cssFontInfo.fontWeight};`;
      this.cssFontInfo.italicAngle && (n += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), s = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${n}src:${e}}`;
    }
    return (i = this._inspectFont) == null || i.call(this, this, e), s;
  }
  getPathGenerator(t, e) {
    if (this.compiledGlyphs[e] !== void 0)
      return this.compiledGlyphs[e];
    let s;
    try {
      s = t.get(this.loadedName + "_path_" + e);
    } catch (n) {
      $(`getPathGenerator - ignoring character: "${n}".`);
    }
    if (!Array.isArray(s) || s.length === 0)
      return this.compiledGlyphs[e] = function(n, a) {
      };
    const i = [];
    for (let n = 0, a = s.length; n < a; )
      switch (s[n++]) {
        case as.BEZIER_CURVE_TO:
          {
            const [o, h, l, c, u, p] = s.slice(n, n + 6);
            i.push((b) => b.bezierCurveTo(o, h, l, c, u, p)), n += 6;
          }
          break;
        case as.MOVE_TO:
          {
            const [o, h] = s.slice(n, n + 2);
            i.push((l) => l.moveTo(o, h)), n += 2;
          }
          break;
        case as.LINE_TO:
          {
            const [o, h] = s.slice(n, n + 2);
            i.push((l) => l.lineTo(o, h)), n += 2;
          }
          break;
        case as.QUADRATIC_CURVE_TO:
          {
            const [o, h, l, c] = s.slice(n, n + 4);
            i.push((u) => u.quadraticCurveTo(o, h, l, c)), n += 4;
          }
          break;
        case as.RESTORE:
          i.push((o) => o.restore());
          break;
        case as.SAVE:
          i.push((o) => o.save());
          break;
        case as.SCALE:
          _t(i.length === 2, "Scale command is only valid at the third position.");
          break;
        case as.TRANSFORM:
          {
            const [o, h, l, c, u, p] = s.slice(n, n + 6);
            i.push((b) => b.transform(o, h, l, c, u, p)), n += 6;
          }
          break;
        case as.TRANSLATE:
          {
            const [o, h] = s.slice(n, n + 2);
            i.push((l) => l.translate(o, h)), n += 2;
          }
          break;
      }
    return this.compiledGlyphs[e] = /* @__PURE__ */ d(function(a, o) {
      i[0](a), i[1](a), a.scale(o, -o);
      for (let h = 2, l = i.length; h < l; h++)
        i[h](a);
    }, "glyphDrawer");
  }
};
d(Yu, "FontFaceObject");
let Fc = Yu;
if ($t) {
  var Nc = Promise.withResolvers(), ea = null;
  (/* @__PURE__ */ d(async () => {
    const t = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL(
        /*webpackIgnore: true*/
        "../../undefined.js",
        typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url
      ).href
    ), e = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL(
        /*webpackIgnore: true*/
        "../../undefined.js",
        typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url
      ).href
    ), s = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL(
        /*webpackIgnore: true*/
        "../../undefined.js",
        typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url
      ).href
    ), i = await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL(
        /*webpackIgnore: true*/
        "../../undefined.js",
        typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url
      ).href
    );
    let n, a;
    return new Map(Object.entries({
      fs: t,
      http: e,
      https: s,
      url: i,
      canvas: n,
      path2d: a
    }));
  }, "loadPackages"))().then((t) => {
    ea = t, Nc.resolve();
  }, (t) => {
    $(`loadPackages: ${t}`), ea = /* @__PURE__ */ new Map(), Nc.resolve();
  });
}
const Ku = class Ku {
  static get promise() {
    return Nc.promise;
  }
  static get(t) {
    return ea == null ? void 0 : ea.get(t);
  }
};
d(Ku, "NodePackages");
let _e = Ku;
const og = /* @__PURE__ */ d(function(f) {
  return _e.get("fs").promises.readFile(f).then((e) => new Uint8Array(e));
}, "node_utils_fetchData"), Qu = class Qu extends Nh {
};
d(Qu, "NodeFilterFactory");
let Oc = Qu;
const Ju = class Ju extends Oh {
  _createCanvas(t, e) {
    return _e.get("canvas").createCanvas(t, e);
  }
};
d(Ju, "NodeCanvasFactory");
let Hc = Ju;
const Zu = class Zu extends Hh {
  _fetchData(t, e) {
    return og(t).then((s) => ({
      cMapData: s,
      compressionType: e
    }));
  }
};
d(Zu, "NodeCMapReaderFactory");
let Bc = Zu;
const tf = class tf extends Bh {
  _fetchData(t) {
    return og(t);
  }
};
d(tf, "NodeStandardFontDataFactory");
let Uc = tf;
const qt = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
function zc(f, t) {
  if (!t)
    return;
  const e = t[2] - t[0], s = t[3] - t[1], i = new Path2D();
  i.rect(t[0], t[1], e, s), f.clip(i);
}
d(zc, "applyBoundingBox");
const kl = class kl {
  constructor() {
    this.constructor === kl && et("Cannot initialize BaseShadingPattern.");
  }
  getPattern() {
    et("Abstract method `getPattern` called.");
  }
};
d(kl, "BaseShadingPattern");
let fa = kl;
const ef = class ef extends fa {
  constructor(t) {
    super(), this._type = t[1], this._bbox = t[2], this._colorStops = t[3], this._p0 = t[4], this._p1 = t[5], this._r0 = t[6], this._r1 = t[7], this.matrix = null;
  }
  _createGradient(t) {
    let e;
    this._type === "axial" ? e = t.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (e = t.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
    for (const s of this._colorStops)
      e.addColorStop(s[0], s[1]);
    return e;
  }
  getPattern(t, e, s, i) {
    let n;
    if (i === qt.STROKE || i === qt.FILL) {
      const a = e.current.getClippedPathBoundingBox(i, ct(t)) || [0, 0, 0, 0], o = Math.ceil(a[2] - a[0]) || 1, h = Math.ceil(a[3] - a[1]) || 1, l = e.cachedCanvases.getCanvas("pattern", o, h, !0), c = l.context;
      c.clearRect(0, 0, c.canvas.width, c.canvas.height), c.beginPath(), c.rect(0, 0, c.canvas.width, c.canvas.height), c.translate(-a[0], -a[1]), s = I.transform(s, [1, 0, 0, 1, a[0], a[1]]), c.transform(...e.baseTransform), this.matrix && c.transform(...this.matrix), zc(c, this._bbox), c.fillStyle = this._createGradient(c), c.fill(), n = t.createPattern(l.canvas, "no-repeat");
      const u = new DOMMatrix(s);
      n.setTransform(u);
    } else
      zc(t, this._bbox), n = this._createGradient(t);
    return n;
  }
};
d(ef, "RadialAxialShadingPattern");
let $c = ef;
function Jl(f, t, e, s, i, n, a, o) {
  const h = t.coords, l = t.colors, c = f.data, u = f.width * 4;
  let p;
  h[e + 1] > h[s + 1] && (p = e, e = s, s = p, p = n, n = a, a = p), h[s + 1] > h[i + 1] && (p = s, s = i, i = p, p = a, a = o, o = p), h[e + 1] > h[s + 1] && (p = e, e = s, s = p, p = n, n = a, a = p);
  const b = (h[e] + t.offsetX) * t.scaleX, v = (h[e + 1] + t.offsetY) * t.scaleY, y = (h[s] + t.offsetX) * t.scaleX, _ = (h[s + 1] + t.offsetY) * t.scaleY, w = (h[i] + t.offsetX) * t.scaleX, E = (h[i + 1] + t.offsetY) * t.scaleY;
  if (v >= E)
    return;
  const S = l[n], C = l[n + 1], T = l[n + 2], x = l[a], k = l[a + 1], P = l[a + 2], O = l[o], q = l[o + 1], F = l[o + 2], ht = Math.round(v), rt = Math.round(E);
  let at, lt, Ft, H, z, th, eh, sh;
  for (let Wt = ht; Wt <= rt; Wt++) {
    if (Wt < _) {
      const mt = Wt < v ? 0 : (v - Wt) / (v - _);
      at = b - (b - y) * mt, lt = S - (S - x) * mt, Ft = C - (C - k) * mt, H = T - (T - P) * mt;
    } else {
      let mt;
      Wt > E ? mt = 1 : _ === E ? mt = 0 : mt = (_ - Wt) / (_ - E), at = y - (y - w) * mt, lt = x - (x - O) * mt, Ft = k - (k - q) * mt, H = P - (P - F) * mt;
    }
    let Lt;
    Wt < v ? Lt = 0 : Wt > E ? Lt = 1 : Lt = (v - Wt) / (v - E), z = b - (b - w) * Lt, th = S - (S - O) * Lt, eh = C - (C - q) * Lt, sh = T - (T - F) * Lt;
    const ih = Math.round(Math.min(at, z)), wi = Math.round(Math.max(at, z));
    let js = u * Wt + ih * 4;
    for (let mt = ih; mt <= wi; mt++)
      Lt = (at - mt) / (at - z), Lt < 0 ? Lt = 0 : Lt > 1 && (Lt = 1), c[js++] = lt - (lt - th) * Lt | 0, c[js++] = Ft - (Ft - eh) * Lt | 0, c[js++] = H - (H - sh) * Lt | 0, c[js++] = 255;
  }
}
d(Jl, "drawTriangle");
function km(f, t, e) {
  const s = t.coords, i = t.colors;
  let n, a;
  switch (t.type) {
    case "lattice":
      const o = t.verticesPerRow, h = Math.floor(s.length / o) - 1, l = o - 1;
      for (n = 0; n < h; n++) {
        let c = n * o;
        for (let u = 0; u < l; u++, c++)
          Jl(f, e, s[c], s[c + 1], s[c + o], i[c], i[c + 1], i[c + o]), Jl(f, e, s[c + o + 1], s[c + 1], s[c + o], i[c + o + 1], i[c + 1], i[c + o]);
      }
      break;
    case "triangles":
      for (n = 0, a = s.length; n < a; n += 3)
        Jl(f, e, s[n], s[n + 1], s[n + 2], i[n], i[n + 1], i[n + 2]);
      break;
    default:
      throw new Error("illegal figure");
  }
}
d(km, "drawFigure");
const sf = class sf extends fa {
  constructor(t) {
    super(), this._coords = t[2], this._colors = t[3], this._figures = t[4], this._bounds = t[5], this._bbox = t[7], this._background = t[8], this.matrix = null;
  }
  _createMeshCanvas(t, e, s) {
    const o = Math.floor(this._bounds[0]), h = Math.floor(this._bounds[1]), l = Math.ceil(this._bounds[2]) - o, c = Math.ceil(this._bounds[3]) - h, u = Math.min(Math.ceil(Math.abs(l * t[0] * 1.1)), 3e3), p = Math.min(Math.ceil(Math.abs(c * t[1] * 1.1)), 3e3), b = l / u, v = c / p, y = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -o,
      offsetY: -h,
      scaleX: 1 / b,
      scaleY: 1 / v
    }, _ = u + 2 * 2, w = p + 2 * 2, E = s.getCanvas("mesh", _, w, !1), S = E.context, C = S.createImageData(u, p);
    if (e) {
      const x = C.data;
      for (let k = 0, P = x.length; k < P; k += 4)
        x[k] = e[0], x[k + 1] = e[1], x[k + 2] = e[2], x[k + 3] = 255;
    }
    for (const x of this._figures)
      km(C, x, y);
    return S.putImageData(C, 2, 2), {
      canvas: E.canvas,
      offsetX: o - 2 * b,
      offsetY: h - 2 * v,
      scaleX: b,
      scaleY: v
    };
  }
  getPattern(t, e, s, i) {
    zc(t, this._bbox);
    let n;
    if (i === qt.SHADING)
      n = I.singularValueDecompose2dScale(ct(t));
    else if (n = I.singularValueDecompose2dScale(e.baseTransform), this.matrix) {
      const o = I.singularValueDecompose2dScale(this.matrix);
      n = [n[0] * o[0], n[1] * o[1]];
    }
    const a = this._createMeshCanvas(n, i === qt.SHADING ? null : this._background, e.cachedCanvases);
    return i !== qt.SHADING && (t.setTransform(...e.baseTransform), this.matrix && t.transform(...this.matrix)), t.translate(a.offsetX, a.offsetY), t.scale(a.scaleX, a.scaleY), t.createPattern(a.canvas, "no-repeat");
  }
};
d(sf, "MeshShadingPattern");
let jc = sf;
const nf = class nf extends fa {
  getPattern() {
    return "hotpink";
  }
};
d(nf, "DummyShadingPattern");
let Wc = nf;
function Mm(f) {
  switch (f[0]) {
    case "RadialAxial":
      return new $c(f);
    case "Mesh":
      return new jc(f);
    case "Dummy":
      return new Wc();
  }
  throw new Error(`Unknown IR type: ${f[0]}`);
}
d(Mm, "getShadingPattern");
const yp = {
  COLORED: 1,
  UNCOLORED: 2
}, na = class na {
  constructor(t, e, s, i, n) {
    this.operatorList = t[2], this.matrix = t[3], this.bbox = t[4], this.xstep = t[5], this.ystep = t[6], this.paintType = t[7], this.tilingType = t[8], this.color = e, this.ctx = s, this.canvasGraphicsFactory = i, this.baseTransform = n;
  }
  createPatternCanvas(t) {
    const e = this.operatorList, s = this.bbox, i = this.xstep, n = this.ystep, a = this.paintType, o = this.tilingType, h = this.color, l = this.canvasGraphicsFactory;
    jl("TilingType: " + o);
    const c = s[0], u = s[1], p = s[2], b = s[3], v = I.singularValueDecompose2dScale(this.matrix), y = I.singularValueDecompose2dScale(this.baseTransform), _ = [v[0] * y[0], v[1] * y[1]], w = this.getSizeAndScale(i, this.ctx.canvas.width, _[0]), E = this.getSizeAndScale(n, this.ctx.canvas.height, _[1]), S = t.cachedCanvases.getCanvas("pattern", w.size, E.size, !0), C = S.context, T = l.createCanvasGraphics(C);
    T.groupLevel = t.groupLevel, this.setFillAndStrokeStyleToContext(T, a, h);
    let x = c, k = u, P = p, O = b;
    return c < 0 && (x = 0, P += Math.abs(c)), u < 0 && (k = 0, O += Math.abs(u)), C.translate(-(w.scale * x), -(E.scale * k)), T.transform(w.scale, 0, 0, E.scale, 0, 0), C.save(), this.clipBbox(T, x, k, P, O), T.baseTransform = ct(T.ctx), T.executeOperatorList(e), T.endDrawing(), {
      canvas: S.canvas,
      scaleX: w.scale,
      scaleY: E.scale,
      offsetX: x,
      offsetY: k
    };
  }
  getSizeAndScale(t, e, s) {
    t = Math.abs(t);
    const i = Math.max(na.MAX_PATTERN_SIZE, e);
    let n = Math.ceil(t * s);
    return n >= i ? n = i : s = n / t, {
      scale: s,
      size: n
    };
  }
  clipBbox(t, e, s, i, n) {
    const a = i - e, o = n - s;
    t.ctx.rect(e, s, a, o), t.current.updateRectMinMax(ct(t.ctx), [e, s, i, n]), t.clip(), t.endPath();
  }
  setFillAndStrokeStyleToContext(t, e, s) {
    const i = t.ctx, n = t.current;
    switch (e) {
      case yp.COLORED:
        const a = this.ctx;
        i.fillStyle = a.fillStyle, i.strokeStyle = a.strokeStyle, n.fillColor = a.fillStyle, n.strokeColor = a.strokeStyle;
        break;
      case yp.UNCOLORED:
        const o = I.makeHexColor(s[0], s[1], s[2]);
        i.fillStyle = o, i.strokeStyle = o, n.fillColor = o, n.strokeColor = o;
        break;
      default:
        throw new ic(`Unsupported paint type: ${e}`);
    }
  }
  getPattern(t, e, s, i) {
    let n = s;
    i !== qt.SHADING && (n = I.transform(n, e.baseTransform), this.matrix && (n = I.transform(n, this.matrix)));
    const a = this.createPatternCanvas(e);
    let o = new DOMMatrix(n);
    o = o.translate(a.offsetX, a.offsetY), o = o.scale(1 / a.scaleX, 1 / a.scaleY);
    const h = t.createPattern(a.canvas, "repeat");
    return h.setTransform(o), h;
  }
};
d(na, "TilingPattern"), U(na, "MAX_PATTERN_SIZE", 3e3);
let Vc = na;
function Im({
  src: f,
  srcPos: t = 0,
  dest: e,
  width: s,
  height: i,
  nonBlackColor: n = 4294967295,
  inverseDecode: a = !1
}) {
  const o = jt.isLittleEndian ? 4278190080 : 255, [h, l] = a ? [n, o] : [o, n], c = s >> 3, u = s & 7, p = f.length;
  e = new Uint32Array(e.buffer);
  let b = 0;
  for (let v = 0; v < i; v++) {
    for (const _ = t + c; t < _; t++) {
      const w = t < p ? f[t] : 255;
      e[b++] = w & 128 ? l : h, e[b++] = w & 64 ? l : h, e[b++] = w & 32 ? l : h, e[b++] = w & 16 ? l : h, e[b++] = w & 8 ? l : h, e[b++] = w & 4 ? l : h, e[b++] = w & 2 ? l : h, e[b++] = w & 1 ? l : h;
    }
    if (u === 0)
      continue;
    const y = t < p ? f[t++] : 255;
    for (let _ = 0; _ < u; _++)
      e[b++] = y & 1 << 7 - _ ? l : h;
  }
  return {
    srcPos: t,
    destPos: b
  };
}
d(Im, "convertBlackAndWhiteToRGBA");
const wp = 16, _p = 100, Pm = 15, Ep = 10, Sp = 1e3, Zt = 16;
function Dm(f, t) {
  if (f._removeMirroring)
    throw new Error("Context is already forwarding operations.");
  f.__originalSave = f.save, f.__originalRestore = f.restore, f.__originalRotate = f.rotate, f.__originalScale = f.scale, f.__originalTranslate = f.translate, f.__originalTransform = f.transform, f.__originalSetTransform = f.setTransform, f.__originalResetTransform = f.resetTransform, f.__originalClip = f.clip, f.__originalMoveTo = f.moveTo, f.__originalLineTo = f.lineTo, f.__originalBezierCurveTo = f.bezierCurveTo, f.__originalRect = f.rect, f.__originalClosePath = f.closePath, f.__originalBeginPath = f.beginPath, f._removeMirroring = () => {
    f.save = f.__originalSave, f.restore = f.__originalRestore, f.rotate = f.__originalRotate, f.scale = f.__originalScale, f.translate = f.__originalTranslate, f.transform = f.__originalTransform, f.setTransform = f.__originalSetTransform, f.resetTransform = f.__originalResetTransform, f.clip = f.__originalClip, f.moveTo = f.__originalMoveTo, f.lineTo = f.__originalLineTo, f.bezierCurveTo = f.__originalBezierCurveTo, f.rect = f.__originalRect, f.closePath = f.__originalClosePath, f.beginPath = f.__originalBeginPath, delete f._removeMirroring;
  }, f.save = /* @__PURE__ */ d(function() {
    t.save(), this.__originalSave();
  }, "ctxSave"), f.restore = /* @__PURE__ */ d(function() {
    t.restore(), this.__originalRestore();
  }, "ctxRestore"), f.translate = /* @__PURE__ */ d(function(s, i) {
    t.translate(s, i), this.__originalTranslate(s, i);
  }, "ctxTranslate"), f.scale = /* @__PURE__ */ d(function(s, i) {
    t.scale(s, i), this.__originalScale(s, i);
  }, "ctxScale"), f.transform = /* @__PURE__ */ d(function(s, i, n, a, o, h) {
    t.transform(s, i, n, a, o, h), this.__originalTransform(s, i, n, a, o, h);
  }, "ctxTransform"), f.setTransform = /* @__PURE__ */ d(function(s, i, n, a, o, h) {
    t.setTransform(s, i, n, a, o, h), this.__originalSetTransform(s, i, n, a, o, h);
  }, "ctxSetTransform"), f.resetTransform = /* @__PURE__ */ d(function() {
    t.resetTransform(), this.__originalResetTransform();
  }, "ctxResetTransform"), f.rotate = /* @__PURE__ */ d(function(s) {
    t.rotate(s), this.__originalRotate(s);
  }, "ctxRotate"), f.clip = /* @__PURE__ */ d(function(s) {
    t.clip(s), this.__originalClip(s);
  }, "ctxRotate"), f.moveTo = function(e, s) {
    t.moveTo(e, s), this.__originalMoveTo(e, s);
  }, f.lineTo = function(e, s) {
    t.lineTo(e, s), this.__originalLineTo(e, s);
  }, f.bezierCurveTo = function(e, s, i, n, a, o) {
    t.bezierCurveTo(e, s, i, n, a, o), this.__originalBezierCurveTo(e, s, i, n, a, o);
  }, f.rect = function(e, s, i, n) {
    t.rect(e, s, i, n), this.__originalRect(e, s, i, n);
  }, f.closePath = function() {
    t.closePath(), this.__originalClosePath();
  }, f.beginPath = function() {
    t.beginPath(), this.__originalBeginPath();
  };
}
d(Dm, "mirrorContextOperations");
const rf = class rf {
  constructor(t) {
    this.canvasFactory = t, this.cache = /* @__PURE__ */ Object.create(null);
  }
  getCanvas(t, e, s) {
    let i;
    return this.cache[t] !== void 0 ? (i = this.cache[t], this.canvasFactory.reset(i, e, s)) : (i = this.canvasFactory.create(e, s), this.cache[t] = i), i;
  }
  delete(t) {
    delete this.cache[t];
  }
  clear() {
    for (const t in this.cache) {
      const e = this.cache[t];
      this.canvasFactory.destroy(e), delete this.cache[t];
    }
  }
};
d(rf, "CachedCanvases");
let Gc = rf;
function nh(f, t, e, s, i, n, a, o, h, l) {
  const [c, u, p, b, v, y] = ct(f);
  if (u === 0 && p === 0) {
    const E = a * c + v, S = Math.round(E), C = o * b + y, T = Math.round(C), x = (a + h) * c + v, k = Math.abs(Math.round(x) - S) || 1, P = (o + l) * b + y, O = Math.abs(Math.round(P) - T) || 1;
    return f.setTransform(Math.sign(c), 0, 0, Math.sign(b), S, T), f.drawImage(t, e, s, i, n, 0, 0, k, O), f.setTransform(c, u, p, b, v, y), [k, O];
  }
  if (c === 0 && b === 0) {
    const E = o * p + v, S = Math.round(E), C = a * u + y, T = Math.round(C), x = (o + l) * p + v, k = Math.abs(Math.round(x) - S) || 1, P = (a + h) * u + y, O = Math.abs(Math.round(P) - T) || 1;
    return f.setTransform(0, Math.sign(u), Math.sign(p), 0, S, T), f.drawImage(t, e, s, i, n, 0, 0, O, k), f.setTransform(c, u, p, b, v, y), [O, k];
  }
  f.drawImage(t, e, s, i, n, a, o, h, l);
  const _ = Math.hypot(c, u), w = Math.hypot(p, b);
  return [_ * h, w * l];
}
d(nh, "drawImageAtIntegerCoords");
function Fm(f) {
  const {
    width: t,
    height: e
  } = f;
  if (t > Sp || e > Sp)
    return null;
  const s = 1e3, i = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), n = t + 1;
  let a = new Uint8Array(n * (e + 1)), o, h, l;
  const c = t + 7 & -8;
  let u = new Uint8Array(c * e), p = 0;
  for (const w of f.data) {
    let E = 128;
    for (; E > 0; )
      u[p++] = w & E ? 0 : 255, E >>= 1;
  }
  let b = 0;
  for (p = 0, u[p] !== 0 && (a[0] = 1, ++b), h = 1; h < t; h++)
    u[p] !== u[p + 1] && (a[h] = u[p] ? 2 : 1, ++b), p++;
  for (u[p] !== 0 && (a[h] = 2, ++b), o = 1; o < e; o++) {
    p = o * c, l = o * n, u[p - c] !== u[p] && (a[l] = u[p] ? 1 : 8, ++b);
    let w = (u[p] ? 4 : 0) + (u[p - c] ? 8 : 0);
    for (h = 1; h < t; h++)
      w = (w >> 2) + (u[p + 1] ? 4 : 0) + (u[p - c + 1] ? 8 : 0), i[w] && (a[l + h] = i[w], ++b), p++;
    if (u[p - c] !== u[p] && (a[l + h] = u[p] ? 2 : 4, ++b), b > s)
      return null;
  }
  for (p = c * (e - 1), l = o * n, u[p] !== 0 && (a[l] = 8, ++b), h = 1; h < t; h++)
    u[p] !== u[p + 1] && (a[l + h] = u[p] ? 4 : 8, ++b), p++;
  if (u[p] !== 0 && (a[l + h] = 4, ++b), b > s)
    return null;
  const v = new Int32Array([0, n, -1, 0, -n, 0, 0, 0, 1]), y = new Path2D();
  for (o = 0; b && o <= e; o++) {
    let w = o * n;
    const E = w + t;
    for (; w < E && !a[w]; )
      w++;
    if (w === E)
      continue;
    y.moveTo(w % n, o);
    const S = w;
    let C = a[w];
    do {
      const T = v[C];
      do
        w += T;
      while (!a[w]);
      const x = a[w];
      x !== 5 && x !== 10 ? (C = x, a[w] = 0) : (C = x & 51 * C >> 4, a[w] &= C >> 2 | C << 2), y.lineTo(w % n, w / n | 0), a[w] || --b;
    } while (S !== w);
    --o;
  }
  return u = null, a = null, /* @__PURE__ */ d(function(w) {
    w.save(), w.scale(1 / t, -1 / e), w.translate(0, -e), w.fill(y), w.beginPath(), w.restore();
  }, "drawOutline");
}
d(Fm, "compileType3Glyph");
const af = class af {
  constructor(t, e) {
    this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = Ip, this.textMatrixScale = 1, this.fontMatrix = ec, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = Nt.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, t, e]);
  }
  clone() {
    const t = Object.create(this);
    return t.clipBox = this.clipBox.slice(), t;
  }
  setCurrentPoint(t, e) {
    this.x = t, this.y = e;
  }
  updatePathMinMax(t, e, s) {
    [e, s] = I.applyTransform([e, s], t), this.minX = Math.min(this.minX, e), this.minY = Math.min(this.minY, s), this.maxX = Math.max(this.maxX, e), this.maxY = Math.max(this.maxY, s);
  }
  updateRectMinMax(t, e) {
    const s = I.applyTransform(e, t), i = I.applyTransform(e.slice(2), t), n = I.applyTransform([e[0], e[3]], t), a = I.applyTransform([e[2], e[1]], t);
    this.minX = Math.min(this.minX, s[0], i[0], n[0], a[0]), this.minY = Math.min(this.minY, s[1], i[1], n[1], a[1]), this.maxX = Math.max(this.maxX, s[0], i[0], n[0], a[0]), this.maxY = Math.max(this.maxY, s[1], i[1], n[1], a[1]);
  }
  updateScalingPathMinMax(t, e) {
    I.scaleMinMax(t, e), this.minX = Math.min(this.minX, e[0]), this.minY = Math.min(this.minY, e[1]), this.maxX = Math.max(this.maxX, e[2]), this.maxY = Math.max(this.maxY, e[3]);
  }
  updateCurvePathMinMax(t, e, s, i, n, a, o, h, l, c) {
    const u = I.bezierBoundingBox(e, s, i, n, a, o, h, l, c);
    c || this.updateRectMinMax(t, u);
  }
  getPathBoundingBox(t = qt.FILL, e = null) {
    const s = [this.minX, this.minY, this.maxX, this.maxY];
    if (t === qt.STROKE) {
      e || et("Stroke bounding box must include transform.");
      const i = I.singularValueDecompose2dScale(e), n = i[0] * this.lineWidth / 2, a = i[1] * this.lineWidth / 2;
      s[0] -= n, s[1] -= a, s[2] += n, s[3] += a;
    }
    return s;
  }
  updateClipFromPath() {
    const t = I.intersect(this.clipBox, this.getPathBoundingBox());
    this.startNewPathAndClipBox(t || [0, 0, 0, 0]);
  }
  isEmptyClip() {
    return this.minX === 1 / 0;
  }
  startNewPathAndClipBox(t) {
    this.clipBox = t, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
  }
  getClippedPathBoundingBox(t = qt.FILL, e = null) {
    return I.intersect(this.clipBox, this.getPathBoundingBox(t, e));
  }
};
d(af, "CanvasExtraState");
let Xh = af;
function Cp(f, t) {
  if (typeof ImageData < "u" && t instanceof ImageData) {
    f.putImageData(t, 0, 0);
    return;
  }
  const e = t.height, s = t.width, i = e % Zt, n = (e - i) / Zt, a = i === 0 ? n : n + 1, o = f.createImageData(s, Zt);
  let h = 0, l;
  const c = t.data, u = o.data;
  let p, b, v, y;
  if (t.kind === lh.GRAYSCALE_1BPP) {
    const _ = c.byteLength, w = new Uint32Array(u.buffer, 0, u.byteLength >> 2), E = w.length, S = s + 7 >> 3, C = 4294967295, T = jt.isLittleEndian ? 4278190080 : 255;
    for (p = 0; p < a; p++) {
      for (v = p < n ? Zt : i, l = 0, b = 0; b < v; b++) {
        const x = _ - h;
        let k = 0;
        const P = x > S ? s : x * 8 - 7, O = P & -8;
        let q = 0, F = 0;
        for (; k < O; k += 8)
          F = c[h++], w[l++] = F & 128 ? C : T, w[l++] = F & 64 ? C : T, w[l++] = F & 32 ? C : T, w[l++] = F & 16 ? C : T, w[l++] = F & 8 ? C : T, w[l++] = F & 4 ? C : T, w[l++] = F & 2 ? C : T, w[l++] = F & 1 ? C : T;
        for (; k < P; k++)
          q === 0 && (F = c[h++], q = 128), w[l++] = F & q ? C : T, q >>= 1;
      }
      for (; l < E; )
        w[l++] = 0;
      f.putImageData(o, 0, p * Zt);
    }
  } else if (t.kind === lh.RGBA_32BPP) {
    for (b = 0, y = s * Zt * 4, p = 0; p < n; p++)
      u.set(c.subarray(h, h + y)), h += y, f.putImageData(o, 0, b), b += Zt;
    p < a && (y = s * i * 4, u.set(c.subarray(h, h + y)), f.putImageData(o, 0, b));
  } else if (t.kind === lh.RGB_24BPP)
    for (v = Zt, y = s * v, p = 0; p < a; p++) {
      for (p >= n && (v = i, y = s * v), l = 0, b = y; b--; )
        u[l++] = c[h++], u[l++] = c[h++], u[l++] = c[h++], u[l++] = 255;
      f.putImageData(o, 0, p * Zt);
    }
  else
    throw new Error(`bad image kind: ${t.kind}`);
}
d(Cp, "putBinaryImageData");
function xp(f, t) {
  if (t.bitmap) {
    f.drawImage(t.bitmap, 0, 0);
    return;
  }
  const e = t.height, s = t.width, i = e % Zt, n = (e - i) / Zt, a = i === 0 ? n : n + 1, o = f.createImageData(s, Zt);
  let h = 0;
  const l = t.data, c = o.data;
  for (let u = 0; u < a; u++) {
    const p = u < n ? Zt : i;
    ({
      srcPos: h
    } = Im({
      src: l,
      srcPos: h,
      dest: c,
      width: s,
      height: p,
      nonBlackColor: 0
    })), f.putImageData(o, 0, u * Zt);
  }
}
d(xp, "putBinaryImageMask");
function Hr(f, t) {
  const e = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const s of e)
    f[s] !== void 0 && (t[s] = f[s]);
  f.setLineDash !== void 0 && (t.setLineDash(f.getLineDash()), t.lineDashOffset = f.lineDashOffset);
}
d(Hr, "copyCtxState");
function rh(f) {
  if (f.strokeStyle = f.fillStyle = "#000000", f.fillRule = "nonzero", f.globalAlpha = 1, f.lineWidth = 1, f.lineCap = "butt", f.lineJoin = "miter", f.miterLimit = 10, f.globalCompositeOperation = "source-over", f.font = "10px sans-serif", f.setLineDash !== void 0 && (f.setLineDash([]), f.lineDashOffset = 0), !$t) {
    const {
      filter: t
    } = f;
    t !== "none" && t !== "" && (f.filter = "none");
  }
}
d(rh, "resetCtxToDefault");
function Tp(f, t) {
  if (t)
    return !0;
  const e = I.singularValueDecompose2dScale(f);
  e[0] = Math.fround(e[0]), e[1] = Math.fround(e[1]);
  const s = Math.fround((globalThis.devicePixelRatio || 1) * bi.PDF_TO_CSS_UNITS);
  return e[0] <= s && e[1] <= s;
}
d(Tp, "getImageSmoothingEnabled");
const Nm = ["butt", "round", "square"], Om = ["miter", "round", "bevel"], Hm = {}, Lp = {};
var vi, qc, Xc;
const Ml = class Ml {
  constructor(t, e, s, i, n, {
    optionalContentConfig: a,
    markedContentStack: o = null
  }, h, l) {
    A(this, vi);
    this.ctx = t, this.current = new Xh(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = e, this.objs = s, this.canvasFactory = i, this.filterFactory = n, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = o || [], this.optionalContentConfig = a, this.cachedCanvases = new Gc(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = h, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = l, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
  }
  getObject(t, e = null) {
    return typeof t == "string" ? t.startsWith("g_") ? this.commonObjs.get(t) : this.objs.get(t) : e;
  }
  beginDrawing({
    transform: t,
    viewport: e,
    transparency: s = !1,
    background: i = null
  }) {
    const n = this.ctx.canvas.width, a = this.ctx.canvas.height, o = this.ctx.fillStyle;
    if (this.ctx.fillStyle = i || "#ffffff", this.ctx.fillRect(0, 0, n, a), this.ctx.fillStyle = o, s) {
      const h = this.cachedCanvases.getCanvas("transparent", n, a);
      this.compositeCtx = this.ctx, this.transparentCanvas = h.canvas, this.ctx = h.context, this.ctx.save(), this.ctx.transform(...ct(this.compositeCtx));
    }
    this.ctx.save(), rh(this.ctx), t && (this.ctx.transform(...t), this.outputScaleX = t[0], this.outputScaleY = t[0]), this.ctx.transform(...e.transform), this.viewportScale = e.scale, this.baseTransform = ct(this.ctx);
  }
  executeOperatorList(t, e, s, i) {
    const n = t.argsArray, a = t.fnArray;
    let o = e || 0;
    const h = n.length;
    if (h === o)
      return o;
    const l = h - o > Ep && typeof s == "function", c = l ? Date.now() + Pm : 0;
    let u = 0;
    const p = this.commonObjs, b = this.objs;
    let v;
    for (; ; ) {
      if (i !== void 0 && o === i.nextBreakPoint)
        return i.breakIt(o, s), o;
      if (v = a[o], v !== Ee.dependency)
        this[v].apply(this, n[o]);
      else
        for (const y of n[o]) {
          const _ = y.startsWith("g_") ? p : b;
          if (!_.has(y))
            return _.get(y, s), o;
        }
      if (o++, o === h)
        return o;
      if (l && ++u > Ep) {
        if (Date.now() > c)
          return s(), o;
        u = 0;
      }
    }
  }
  endDrawing() {
    m(this, vi, qc).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
    for (const t of this._cachedBitmapsMap.values()) {
      for (const e of t.values())
        typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement && (e.width = e.height = 0);
      t.clear();
    }
    this._cachedBitmapsMap.clear(), m(this, vi, Xc).call(this);
  }
  _scaleImage(t, e) {
    const s = t.width, i = t.height;
    let n = Math.max(Math.hypot(e[0], e[1]), 1), a = Math.max(Math.hypot(e[2], e[3]), 1), o = s, h = i, l = "prescale1", c, u;
    for (; n > 2 && o > 1 || a > 2 && h > 1; ) {
      let p = o, b = h;
      n > 2 && o > 1 && (p = o >= 16384 ? Math.floor(o / 2) - 1 || 1 : Math.ceil(o / 2), n /= o / p), a > 2 && h > 1 && (b = h >= 16384 ? Math.floor(h / 2) - 1 || 1 : Math.ceil(h) / 2, a /= h / b), c = this.cachedCanvases.getCanvas(l, p, b), u = c.context, u.clearRect(0, 0, p, b), u.drawImage(t, 0, 0, o, h, 0, 0, p, b), t = c.canvas, o = p, h = b, l = l === "prescale1" ? "prescale2" : "prescale1";
    }
    return {
      img: t,
      paintWidth: o,
      paintHeight: h
    };
  }
  _createMaskCanvas(t) {
    const e = this.ctx, {
      width: s,
      height: i
    } = t, n = this.current.fillColor, a = this.current.patternFill, o = ct(e);
    let h, l, c, u;
    if ((t.bitmap || t.data) && t.count > 1) {
      const P = t.bitmap || t.data.buffer;
      l = JSON.stringify(a ? o : [o.slice(0, 4), n]), h = this._cachedBitmapsMap.get(P), h || (h = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(P, h));
      const O = h.get(l);
      if (O && !a) {
        const q = Math.round(Math.min(o[0], o[2]) + o[4]), F = Math.round(Math.min(o[1], o[3]) + o[5]);
        return {
          canvas: O,
          offsetX: q,
          offsetY: F
        };
      }
      c = O;
    }
    c || (u = this.cachedCanvases.getCanvas("maskCanvas", s, i), xp(u.context, t));
    let p = I.transform(o, [1 / s, 0, 0, -1 / i, 0, 0]);
    p = I.transform(p, [1, 0, 0, 1, 0, -i]);
    const [b, v, y, _] = I.getAxialAlignedBoundingBox([0, 0, s, i], p), w = Math.round(y - b) || 1, E = Math.round(_ - v) || 1, S = this.cachedCanvases.getCanvas("fillCanvas", w, E), C = S.context, T = b, x = v;
    C.translate(-T, -x), C.transform(...p), c || (c = this._scaleImage(u.canvas, os(C)), c = c.img, h && a && h.set(l, c)), C.imageSmoothingEnabled = Tp(ct(C), t.interpolate), nh(C, c, 0, 0, c.width, c.height, 0, 0, s, i), C.globalCompositeOperation = "source-in";
    const k = I.transform(os(C), [1, 0, 0, 1, -T, -x]);
    return C.fillStyle = a ? n.getPattern(e, this, k, qt.FILL) : n, C.fillRect(0, 0, s, i), h && !a && (this.cachedCanvases.delete("fillCanvas"), h.set(l, S.canvas)), {
      canvas: S.canvas,
      offsetX: Math.round(T),
      offsetY: Math.round(x)
    };
  }
  setLineWidth(t) {
    t !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = t, this.ctx.lineWidth = t;
  }
  setLineCap(t) {
    this.ctx.lineCap = Nm[t];
  }
  setLineJoin(t) {
    this.ctx.lineJoin = Om[t];
  }
  setMiterLimit(t) {
    this.ctx.miterLimit = t;
  }
  setDash(t, e) {
    const s = this.ctx;
    s.setLineDash !== void 0 && (s.setLineDash(t), s.lineDashOffset = e);
  }
  setRenderingIntent(t) {
  }
  setFlatness(t) {
  }
  setGState(t) {
    for (const [e, s] of t)
      switch (e) {
        case "LW":
          this.setLineWidth(s);
          break;
        case "LC":
          this.setLineCap(s);
          break;
        case "LJ":
          this.setLineJoin(s);
          break;
        case "ML":
          this.setMiterLimit(s);
          break;
        case "D":
          this.setDash(s[0], s[1]);
          break;
        case "RI":
          this.setRenderingIntent(s);
          break;
        case "FL":
          this.setFlatness(s);
          break;
        case "Font":
          this.setFont(s[0], s[1]);
          break;
        case "CA":
          this.current.strokeAlpha = s;
          break;
        case "ca":
          this.current.fillAlpha = s, this.ctx.globalAlpha = s;
          break;
        case "BM":
          this.ctx.globalCompositeOperation = s;
          break;
        case "SMask":
          this.current.activeSMask = s ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
          break;
        case "TR":
          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(s);
          break;
      }
  }
  get inSMaskMode() {
    return !!this.suspendedCtx;
  }
  checkSMaskState() {
    const t = this.inSMaskMode;
    this.current.activeSMask && !t ? this.beginSMaskMode() : !this.current.activeSMask && t && this.endSMaskMode();
  }
  beginSMaskMode() {
    if (this.inSMaskMode)
      throw new Error("beginSMaskMode called while already in smask mode");
    const t = this.ctx.canvas.width, e = this.ctx.canvas.height, s = "smaskGroupAt" + this.groupLevel, i = this.cachedCanvases.getCanvas(s, t, e);
    this.suspendedCtx = this.ctx, this.ctx = i.context;
    const n = this.ctx;
    n.setTransform(...ct(this.suspendedCtx)), Hr(this.suspendedCtx, n), Dm(n, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
  }
  endSMaskMode() {
    if (!this.inSMaskMode)
      throw new Error("endSMaskMode called while not in smask mode");
    this.ctx._removeMirroring(), Hr(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
  }
  compose(t) {
    if (!this.current.activeSMask)
      return;
    t ? (t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.ceil(t[2]), t[3] = Math.ceil(t[3])) : t = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    const e = this.current.activeSMask, s = this.suspendedCtx;
    this.composeSMask(s, e, this.ctx, t), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
  }
  composeSMask(t, e, s, i) {
    const n = i[0], a = i[1], o = i[2] - n, h = i[3] - a;
    o === 0 || h === 0 || (this.genericComposeSMask(e.context, s, o, h, e.subtype, e.backdrop, e.transferMap, n, a, e.offsetX, e.offsetY), t.save(), t.globalAlpha = 1, t.globalCompositeOperation = "source-over", t.setTransform(1, 0, 0, 1, 0, 0), t.drawImage(s.canvas, 0, 0), t.restore());
  }
  genericComposeSMask(t, e, s, i, n, a, o, h, l, c, u) {
    let p = t.canvas, b = h - c, v = l - u;
    if (a) {
      if (b < 0 || v < 0 || b + s > p.width || v + i > p.height) {
        const _ = this.cachedCanvases.getCanvas("maskExtension", s, i), w = _.context;
        w.drawImage(p, -b, -v), a.some((E) => E !== 0) && (w.globalCompositeOperation = "destination-atop", w.fillStyle = I.makeHexColor(...a), w.fillRect(0, 0, s, i), w.globalCompositeOperation = "source-over"), p = _.canvas, b = v = 0;
      } else if (a.some((_) => _ !== 0)) {
        t.save(), t.globalAlpha = 1, t.setTransform(1, 0, 0, 1, 0, 0);
        const _ = new Path2D();
        _.rect(b, v, s, i), t.clip(_), t.globalCompositeOperation = "destination-atop", t.fillStyle = I.makeHexColor(...a), t.fillRect(b, v, s, i), t.restore();
      }
    }
    e.save(), e.globalAlpha = 1, e.setTransform(1, 0, 0, 1, 0, 0), n === "Alpha" && o ? e.filter = this.filterFactory.addAlphaFilter(o) : n === "Luminosity" && (e.filter = this.filterFactory.addLuminosityFilter(o));
    const y = new Path2D();
    y.rect(h, l, s, i), e.clip(y), e.globalCompositeOperation = "destination-in", e.drawImage(p, b, v, s, i, h, l, s, i), e.restore();
  }
  save() {
    this.inSMaskMode ? (Hr(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
    const t = this.current;
    this.stateStack.push(t), this.current = t.clone();
  }
  restore() {
    this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), Hr(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
  }
  transform(t, e, s, i, n, a) {
    this.ctx.transform(t, e, s, i, n, a), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
  }
  constructPath(t, e, s) {
    const i = this.ctx, n = this.current;
    let a = n.x, o = n.y, h, l;
    const c = ct(i), u = c[0] === 0 && c[3] === 0 || c[1] === 0 && c[2] === 0, p = u ? s.slice(0) : null;
    for (let b = 0, v = 0, y = t.length; b < y; b++)
      switch (t[b] | 0) {
        case Ee.rectangle:
          a = e[v++], o = e[v++];
          const _ = e[v++], w = e[v++], E = a + _, S = o + w;
          i.moveTo(a, o), _ === 0 || w === 0 ? i.lineTo(E, S) : (i.lineTo(E, o), i.lineTo(E, S), i.lineTo(a, S)), u || n.updateRectMinMax(c, [a, o, E, S]), i.closePath();
          break;
        case Ee.moveTo:
          a = e[v++], o = e[v++], i.moveTo(a, o), u || n.updatePathMinMax(c, a, o);
          break;
        case Ee.lineTo:
          a = e[v++], o = e[v++], i.lineTo(a, o), u || n.updatePathMinMax(c, a, o);
          break;
        case Ee.curveTo:
          h = a, l = o, a = e[v + 4], o = e[v + 5], i.bezierCurveTo(e[v], e[v + 1], e[v + 2], e[v + 3], a, o), n.updateCurvePathMinMax(c, h, l, e[v], e[v + 1], e[v + 2], e[v + 3], a, o, p), v += 6;
          break;
        case Ee.curveTo2:
          h = a, l = o, i.bezierCurveTo(a, o, e[v], e[v + 1], e[v + 2], e[v + 3]), n.updateCurvePathMinMax(c, h, l, a, o, e[v], e[v + 1], e[v + 2], e[v + 3], p), a = e[v + 2], o = e[v + 3], v += 4;
          break;
        case Ee.curveTo3:
          h = a, l = o, a = e[v + 2], o = e[v + 3], i.bezierCurveTo(e[v], e[v + 1], a, o, a, o), n.updateCurvePathMinMax(c, h, l, e[v], e[v + 1], a, o, a, o, p), v += 4;
          break;
        case Ee.closePath:
          i.closePath();
          break;
      }
    u && n.updateScalingPathMinMax(c, p), n.setCurrentPoint(a, o);
  }
  closePath() {
    this.ctx.closePath();
  }
  stroke(t = !0) {
    const e = this.ctx, s = this.current.strokeColor;
    e.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof s == "object" && (s != null && s.getPattern) ? (e.save(), e.strokeStyle = s.getPattern(e, this, os(e), qt.STROKE), this.rescaleAndStroke(!1), e.restore()) : this.rescaleAndStroke(!0)), t && this.consumePath(this.current.getClippedPathBoundingBox()), e.globalAlpha = this.current.fillAlpha;
  }
  closeStroke() {
    this.closePath(), this.stroke();
  }
  fill(t = !0) {
    const e = this.ctx, s = this.current.fillColor, i = this.current.patternFill;
    let n = !1;
    i && (e.save(), e.fillStyle = s.getPattern(e, this, os(e), qt.FILL), n = !0);
    const a = this.current.getClippedPathBoundingBox();
    this.contentVisible && a !== null && (this.pendingEOFill ? (e.fill("evenodd"), this.pendingEOFill = !1) : e.fill()), n && e.restore(), t && this.consumePath(a);
  }
  eoFill() {
    this.pendingEOFill = !0, this.fill();
  }
  fillStroke() {
    this.fill(!1), this.stroke(!1), this.consumePath();
  }
  eoFillStroke() {
    this.pendingEOFill = !0, this.fillStroke();
  }
  closeFillStroke() {
    this.closePath(), this.fillStroke();
  }
  closeEOFillStroke() {
    this.pendingEOFill = !0, this.closePath(), this.fillStroke();
  }
  endPath() {
    this.consumePath();
  }
  clip() {
    this.pendingClip = Hm;
  }
  eoClip() {
    this.pendingClip = Lp;
  }
  beginText() {
    this.current.textMatrix = Ip, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
  }
  endText() {
    const t = this.pendingTextPaths, e = this.ctx;
    if (t === void 0) {
      e.beginPath();
      return;
    }
    e.save(), e.beginPath();
    for (const s of t)
      e.setTransform(...s.transform), e.translate(s.x, s.y), s.addToPath(e, s.fontSize);
    e.restore(), e.clip(), e.beginPath(), delete this.pendingTextPaths;
  }
  setCharSpacing(t) {
    this.current.charSpacing = t;
  }
  setWordSpacing(t) {
    this.current.wordSpacing = t;
  }
  setHScale(t) {
    this.current.textHScale = t / 100;
  }
  setLeading(t) {
    this.current.leading = -t;
  }
  setFont(t, e) {
    var c;
    const s = this.commonObjs.get(t), i = this.current;
    if (!s)
      throw new Error(`Can't find font for ${t}`);
    if (i.fontMatrix = s.fontMatrix || ec, (i.fontMatrix[0] === 0 || i.fontMatrix[3] === 0) && $("Invalid font matrix for font " + t), e < 0 ? (e = -e, i.fontDirection = -1) : i.fontDirection = 1, this.current.font = s, this.current.fontSize = e, s.isType3Font)
      return;
    const n = s.loadedName || "sans-serif", a = ((c = s.systemFontInfo) == null ? void 0 : c.css) || `"${n}", ${s.fallbackName}`;
    let o = "normal";
    s.black ? o = "900" : s.bold && (o = "bold");
    const h = s.italic ? "italic" : "normal";
    let l = e;
    e < wp ? l = wp : e > _p && (l = _p), this.current.fontSizeScale = e / l, this.ctx.font = `${h} ${o} ${l}px ${a}`;
  }
  setTextRenderingMode(t) {
    this.current.textRenderingMode = t;
  }
  setTextRise(t) {
    this.current.textRise = t;
  }
  moveText(t, e) {
    this.current.x = this.current.lineX += t, this.current.y = this.current.lineY += e;
  }
  setLeadingMoveText(t, e) {
    this.setLeading(-e), this.moveText(t, e);
  }
  setTextMatrix(t, e, s, i, n, a) {
    this.current.textMatrix = [t, e, s, i, n, a], this.current.textMatrixScale = Math.hypot(t, e), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
  }
  nextLine() {
    this.moveText(0, this.current.leading);
  }
  paintChar(t, e, s, i) {
    const n = this.ctx, a = this.current, o = a.font, h = a.textRenderingMode, l = a.fontSize / a.fontSizeScale, c = h & Nt.FILL_STROKE_MASK, u = !!(h & Nt.ADD_TO_PATH_FLAG), p = a.patternFill && !o.missingFile;
    let b;
    (o.disableFontFace || u || p) && (b = o.getPathGenerator(this.commonObjs, t)), o.disableFontFace || p ? (n.save(), n.translate(e, s), n.beginPath(), b(n, l), i && n.setTransform(...i), (c === Nt.FILL || c === Nt.FILL_STROKE) && n.fill(), (c === Nt.STROKE || c === Nt.FILL_STROKE) && n.stroke(), n.restore()) : ((c === Nt.FILL || c === Nt.FILL_STROKE) && n.fillText(t, e, s), (c === Nt.STROKE || c === Nt.FILL_STROKE) && n.strokeText(t, e, s)), u && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
      transform: ct(n),
      x: e,
      y: s,
      fontSize: l,
      addToPath: b
    });
  }
  get isFontSubpixelAAEnabled() {
    const {
      context: t
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    t.scale(1.5, 1), t.fillText("I", 0, 10);
    const e = t.getImageData(0, 0, 10, 10).data;
    let s = !1;
    for (let i = 3; i < e.length; i += 4)
      if (e[i] > 0 && e[i] < 255) {
        s = !0;
        break;
      }
    return X(this, "isFontSubpixelAAEnabled", s);
  }
  showText(t) {
    const e = this.current, s = e.font;
    if (s.isType3Font)
      return this.showType3Text(t);
    const i = e.fontSize;
    if (i === 0)
      return;
    const n = this.ctx, a = e.fontSizeScale, o = e.charSpacing, h = e.wordSpacing, l = e.fontDirection, c = e.textHScale * l, u = t.length, p = s.vertical, b = p ? 1 : -1, v = s.defaultVMetrics, y = i * e.fontMatrix[0], _ = e.textRenderingMode === Nt.FILL && !s.disableFontFace && !e.patternFill;
    n.save(), n.transform(...e.textMatrix), n.translate(e.x, e.y + e.textRise), l > 0 ? n.scale(c, -1) : n.scale(c, 1);
    let w;
    if (e.patternFill) {
      n.save();
      const x = e.fillColor.getPattern(n, this, os(n), qt.FILL);
      w = ct(n), n.restore(), n.fillStyle = x;
    }
    let E = e.lineWidth;
    const S = e.textMatrixScale;
    if (S === 0 || E === 0) {
      const x = e.textRenderingMode & Nt.FILL_STROKE_MASK;
      (x === Nt.STROKE || x === Nt.FILL_STROKE) && (E = this.getSinglePixelWidth());
    } else
      E /= S;
    if (a !== 1 && (n.scale(a, a), E /= a), n.lineWidth = E, s.isInvalidPDFjsFont) {
      const x = [];
      let k = 0;
      for (const P of t)
        x.push(P.unicode), k += P.width;
      n.fillText(x.join(""), 0, 0), e.x += k * y * c, n.restore(), this.compose();
      return;
    }
    let C = 0, T;
    for (T = 0; T < u; ++T) {
      const x = t[T];
      if (typeof x == "number") {
        C += b * x * i / 1e3;
        continue;
      }
      let k = !1;
      const P = (x.isSpace ? h : 0) + o, O = x.fontChar, q = x.accent;
      let F, ht, rt = x.width;
      if (p) {
        const lt = x.vmetric || v, Ft = -(x.vmetric ? lt[1] : rt * 0.5) * y, H = lt[2] * y;
        rt = lt ? -lt[0] : rt, F = Ft / a, ht = (C + H) / a;
      } else
        F = C / a, ht = 0;
      if (s.remeasure && rt > 0) {
        const lt = n.measureText(O).width * 1e3 / i * a;
        if (rt < lt && this.isFontSubpixelAAEnabled) {
          const Ft = rt / lt;
          k = !0, n.save(), n.scale(Ft, 1), F /= Ft;
        } else rt !== lt && (F += (rt - lt) / 2e3 * i / a);
      }
      if (this.contentVisible && (x.isInFont || s.missingFile)) {
        if (_ && !q)
          n.fillText(O, F, ht);
        else if (this.paintChar(O, F, ht, w), q) {
          const lt = F + i * q.offset.x / a, Ft = ht - i * q.offset.y / a;
          this.paintChar(q.fontChar, lt, Ft, w);
        }
      }
      const at = p ? rt * y - P * l : rt * y + P * l;
      C += at, k && n.restore();
    }
    p ? e.y -= C : e.x += C * c, n.restore(), this.compose();
  }
  showType3Text(t) {
    const e = this.ctx, s = this.current, i = s.font, n = s.fontSize, a = s.fontDirection, o = i.vertical ? 1 : -1, h = s.charSpacing, l = s.wordSpacing, c = s.textHScale * a, u = s.fontMatrix || ec, p = t.length, b = s.textRenderingMode === Nt.INVISIBLE;
    let v, y, _, w;
    if (!(b || n === 0)) {
      for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, e.save(), e.transform(...s.textMatrix), e.translate(s.x, s.y), e.scale(c, a), v = 0; v < p; ++v) {
        if (y = t[v], typeof y == "number") {
          w = o * y * n / 1e3, this.ctx.translate(w, 0), s.x += w * c;
          continue;
        }
        const E = (y.isSpace ? l : 0) + h, S = i.charProcOperatorList[y.operatorListId];
        if (!S) {
          $(`Type3 character "${y.operatorListId}" is not available.`);
          continue;
        }
        this.contentVisible && (this.processingType3 = y, this.save(), e.scale(n, n), e.transform(...u), this.executeOperatorList(S), this.restore()), _ = I.applyTransform([y.width, 0], u)[0] * n + E, e.translate(_, 0), s.x += _ * c;
      }
      e.restore(), this.processingType3 = null;
    }
  }
  setCharWidth(t, e) {
  }
  setCharWidthAndBounds(t, e, s, i, n, a) {
    this.ctx.rect(s, i, n - s, a - i), this.ctx.clip(), this.endPath();
  }
  getColorN_Pattern(t) {
    let e;
    if (t[0] === "TilingPattern") {
      const s = t[1], i = this.baseTransform || ct(this.ctx), n = {
        createCanvasGraphics: /* @__PURE__ */ d((a) => new Ml(a, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
          optionalContentConfig: this.optionalContentConfig,
          markedContentStack: this.markedContentStack
        }), "createCanvasGraphics")
      };
      e = new Vc(t, s, this.ctx, n, i);
    } else
      e = this._getPattern(t[1], t[2]);
    return e;
  }
  setStrokeColorN() {
    this.current.strokeColor = this.getColorN_Pattern(arguments);
  }
  setFillColorN() {
    this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
  }
  setStrokeRGBColor(t, e, s) {
    this.ctx.strokeStyle = this.current.strokeColor = I.makeHexColor(t, e, s);
  }
  setStrokeTransparent() {
    this.ctx.strokeStyle = this.current.strokeColor = "transparent";
  }
  setFillRGBColor(t, e, s) {
    this.ctx.fillStyle = this.current.fillColor = I.makeHexColor(t, e, s), this.current.patternFill = !1;
  }
  setFillTransparent() {
    this.ctx.fillStyle = this.current.fillColor = "transparent", this.current.patternFill = !1;
  }
  _getPattern(t, e = null) {
    let s;
    return this.cachedPatterns.has(t) ? s = this.cachedPatterns.get(t) : (s = Mm(this.getObject(t)), this.cachedPatterns.set(t, s)), e && (s.matrix = e), s;
  }
  shadingFill(t) {
    if (!this.contentVisible)
      return;
    const e = this.ctx;
    this.save();
    const s = this._getPattern(t);
    e.fillStyle = s.getPattern(e, this, os(e), qt.SHADING);
    const i = os(e);
    if (i) {
      const {
        width: n,
        height: a
      } = e.canvas, [o, h, l, c] = I.getAxialAlignedBoundingBox([0, 0, n, a], i);
      this.ctx.fillRect(o, h, l - o, c - h);
    } else
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    this.compose(this.current.getClippedPathBoundingBox()), this.restore();
  }
  beginInlineImage() {
    et("Should not call beginInlineImage");
  }
  beginImageData() {
    et("Should not call beginImageData");
  }
  paintFormXObjectBegin(t, e) {
    if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), t && this.transform(...t), this.baseTransform = ct(this.ctx), e)) {
      const s = e[2] - e[0], i = e[3] - e[1];
      this.ctx.rect(e[0], e[1], s, i), this.current.updateRectMinMax(ct(this.ctx), e), this.clip(), this.endPath();
    }
  }
  paintFormXObjectEnd() {
    this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
  }
  beginGroup(t) {
    if (!this.contentVisible)
      return;
    this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
    const e = this.ctx;
    t.isolated || jl("TODO: Support non-isolated groups."), t.knockout && $("Knockout groups not supported.");
    const s = ct(e);
    if (t.matrix && e.transform(...t.matrix), !t.bbox)
      throw new Error("Bounding box is required.");
    let i = I.getAxialAlignedBoundingBox(t.bbox, ct(e));
    const n = [0, 0, e.canvas.width, e.canvas.height];
    i = I.intersect(i, n) || [0, 0, 0, 0];
    const a = Math.floor(i[0]), o = Math.floor(i[1]), h = Math.max(Math.ceil(i[2]) - a, 1), l = Math.max(Math.ceil(i[3]) - o, 1);
    this.current.startNewPathAndClipBox([0, 0, h, l]);
    let c = "groupAt" + this.groupLevel;
    t.smask && (c += "_smask_" + this.smaskCounter++ % 2);
    const u = this.cachedCanvases.getCanvas(c, h, l), p = u.context;
    p.translate(-a, -o), p.transform(...s), t.smask ? this.smaskStack.push({
      canvas: u.canvas,
      context: p,
      offsetX: a,
      offsetY: o,
      subtype: t.smask.subtype,
      backdrop: t.smask.backdrop,
      transferMap: t.smask.transferMap || null,
      startTransformInverse: null
    }) : (e.setTransform(1, 0, 0, 1, 0, 0), e.translate(a, o), e.save()), Hr(e, p), this.ctx = p, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(e), this.groupLevel++;
  }
  endGroup(t) {
    if (!this.contentVisible)
      return;
    this.groupLevel--;
    const e = this.ctx, s = this.groupStack.pop();
    if (this.ctx = s, this.ctx.imageSmoothingEnabled = !1, t.smask)
      this.tempSMask = this.smaskStack.pop(), this.restore();
    else {
      this.ctx.restore();
      const i = ct(this.ctx);
      this.restore(), this.ctx.save(), this.ctx.setTransform(...i);
      const n = I.getAxialAlignedBoundingBox([0, 0, e.canvas.width, e.canvas.height], i);
      this.ctx.drawImage(e.canvas, 0, 0), this.ctx.restore(), this.compose(n);
    }
  }
  beginAnnotation(t, e, s, i, n) {
    if (m(this, vi, qc).call(this), rh(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), e) {
      const a = e[2] - e[0], o = e[3] - e[1];
      if (n && this.annotationCanvasMap) {
        s = s.slice(), s[4] -= e[0], s[5] -= e[1], e = e.slice(), e[0] = e[1] = 0, e[2] = a, e[3] = o;
        const [h, l] = I.singularValueDecompose2dScale(ct(this.ctx)), {
          viewportScale: c
        } = this, u = Math.ceil(a * this.outputScaleX * c), p = Math.ceil(o * this.outputScaleY * c);
        this.annotationCanvas = this.canvasFactory.create(u, p);
        const {
          canvas: b,
          context: v
        } = this.annotationCanvas;
        this.annotationCanvasMap.set(t, b), this.annotationCanvas.savedCtx = this.ctx, this.ctx = v, this.ctx.save(), this.ctx.setTransform(h, 0, 0, -l, 0, o * l), rh(this.ctx);
      } else
        rh(this.ctx), this.ctx.rect(e[0], e[1], a, o), this.ctx.clip(), this.endPath();
    }
    this.current = new Xh(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...s), this.transform(...i);
  }
  endAnnotation() {
    this.annotationCanvas && (this.ctx.restore(), m(this, vi, Xc).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
  }
  paintImageMaskXObject(t) {
    if (!this.contentVisible)
      return;
    const e = t.count;
    t = this.getObject(t.data, t), t.count = e;
    const s = this.ctx, i = this.processingType3;
    if (i && (i.compiled === void 0 && (i.compiled = Fm(t)), i.compiled)) {
      i.compiled(s);
      return;
    }
    const n = this._createMaskCanvas(t), a = n.canvas;
    s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.drawImage(a, n.offsetX, n.offsetY), s.restore(), this.compose();
  }
  paintImageMaskXObjectRepeat(t, e, s = 0, i = 0, n, a) {
    if (!this.contentVisible)
      return;
    t = this.getObject(t.data, t);
    const o = this.ctx;
    o.save();
    const h = ct(o);
    o.transform(e, s, i, n, 0, 0);
    const l = this._createMaskCanvas(t);
    o.setTransform(1, 0, 0, 1, l.offsetX - h[4], l.offsetY - h[5]);
    for (let c = 0, u = a.length; c < u; c += 2) {
      const p = I.transform(h, [e, s, i, n, a[c], a[c + 1]]), [b, v] = I.applyTransform([0, 0], p);
      o.drawImage(l.canvas, b, v);
    }
    o.restore(), this.compose();
  }
  paintImageMaskXObjectGroup(t) {
    if (!this.contentVisible)
      return;
    const e = this.ctx, s = this.current.fillColor, i = this.current.patternFill;
    for (const n of t) {
      const {
        data: a,
        width: o,
        height: h,
        transform: l
      } = n, c = this.cachedCanvases.getCanvas("maskCanvas", o, h), u = c.context;
      u.save();
      const p = this.getObject(a, n);
      xp(u, p), u.globalCompositeOperation = "source-in", u.fillStyle = i ? s.getPattern(u, this, os(e), qt.FILL) : s, u.fillRect(0, 0, o, h), u.restore(), e.save(), e.transform(...l), e.scale(1, -1), nh(e, c.canvas, 0, 0, o, h, 0, -1, 1, 1), e.restore();
    }
    this.compose();
  }
  paintImageXObject(t) {
    if (!this.contentVisible)
      return;
    const e = this.getObject(t);
    if (!e) {
      $("Dependent image isn't ready yet");
      return;
    }
    this.paintInlineImageXObject(e);
  }
  paintImageXObjectRepeat(t, e, s, i) {
    if (!this.contentVisible)
      return;
    const n = this.getObject(t);
    if (!n) {
      $("Dependent image isn't ready yet");
      return;
    }
    const a = n.width, o = n.height, h = [];
    for (let l = 0, c = i.length; l < c; l += 2)
      h.push({
        transform: [e, 0, 0, s, i[l], i[l + 1]],
        x: 0,
        y: 0,
        w: a,
        h: o
      });
    this.paintInlineImageXObjectGroup(n, h);
  }
  applyTransferMapsToCanvas(t) {
    return this.current.transferMaps !== "none" && (t.filter = this.current.transferMaps, t.drawImage(t.canvas, 0, 0), t.filter = "none"), t.canvas;
  }
  applyTransferMapsToBitmap(t) {
    if (this.current.transferMaps === "none")
      return t.bitmap;
    const {
      bitmap: e,
      width: s,
      height: i
    } = t, n = this.cachedCanvases.getCanvas("inlineImage", s, i), a = n.context;
    return a.filter = this.current.transferMaps, a.drawImage(e, 0, 0), a.filter = "none", n.canvas;
  }
  paintInlineImageXObject(t) {
    if (!this.contentVisible)
      return;
    const e = t.width, s = t.height, i = this.ctx;
    if (this.save(), !$t) {
      const {
        filter: o
      } = i;
      o !== "none" && o !== "" && (i.filter = "none");
    }
    i.scale(1 / e, -1 / s);
    let n;
    if (t.bitmap)
      n = this.applyTransferMapsToBitmap(t);
    else if (typeof HTMLElement == "function" && t instanceof HTMLElement || !t.data)
      n = t;
    else {
      const h = this.cachedCanvases.getCanvas("inlineImage", e, s).context;
      Cp(h, t), n = this.applyTransferMapsToCanvas(h);
    }
    const a = this._scaleImage(n, os(i));
    i.imageSmoothingEnabled = Tp(ct(i), t.interpolate), nh(i, a.img, 0, 0, a.paintWidth, a.paintHeight, 0, -s, e, s), this.compose(), this.restore();
  }
  paintInlineImageXObjectGroup(t, e) {
    if (!this.contentVisible)
      return;
    const s = this.ctx;
    let i;
    if (t.bitmap)
      i = t.bitmap;
    else {
      const n = t.width, a = t.height, h = this.cachedCanvases.getCanvas("inlineImage", n, a).context;
      Cp(h, t), i = this.applyTransferMapsToCanvas(h);
    }
    for (const n of e)
      s.save(), s.transform(...n.transform), s.scale(1, -1), nh(s, i, n.x, n.y, n.w, n.h, 0, -1, 1, 1), s.restore();
    this.compose();
  }
  paintSolidColorImageMask() {
    this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
  }
  markPoint(t) {
  }
  markPointProps(t, e) {
  }
  beginMarkedContent(t) {
    this.markedContentStack.push({
      visible: !0
    });
  }
  beginMarkedContentProps(t, e) {
    t === "OC" ? this.markedContentStack.push({
      visible: this.optionalContentConfig.isVisible(e)
    }) : this.markedContentStack.push({
      visible: !0
    }), this.contentVisible = this.isContentVisible();
  }
  endMarkedContent() {
    this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
  }
  beginCompat() {
  }
  endCompat() {
  }
  consumePath(t) {
    const e = this.current.isEmptyClip();
    this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(t);
    const s = this.ctx;
    this.pendingClip && (e || (this.pendingClip === Lp ? s.clip("evenodd") : s.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), s.beginPath();
  }
  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const t = ct(this.ctx);
      if (t[1] === 0 && t[2] === 0)
        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(t[0]), Math.abs(t[3]));
      else {
        const e = Math.abs(t[0] * t[3] - t[2] * t[1]), s = Math.hypot(t[0], t[2]), i = Math.hypot(t[1], t[3]);
        this._cachedGetSinglePixelWidth = Math.max(s, i) / e;
      }
    }
    return this._cachedGetSinglePixelWidth;
  }
  getScaleForStroking() {
    if (this._cachedScaleForStroking[0] === -1) {
      const {
        lineWidth: t
      } = this.current, {
        a: e,
        b: s,
        c: i,
        d: n
      } = this.ctx.getTransform();
      let a, o;
      if (s === 0 && i === 0) {
        const h = Math.abs(e), l = Math.abs(n);
        if (h === l)
          if (t === 0)
            a = o = 1 / h;
          else {
            const c = h * t;
            a = o = c < 1 ? 1 / c : 1;
          }
        else if (t === 0)
          a = 1 / h, o = 1 / l;
        else {
          const c = h * t, u = l * t;
          a = c < 1 ? 1 / c : 1, o = u < 1 ? 1 / u : 1;
        }
      } else {
        const h = Math.abs(e * n - s * i), l = Math.hypot(e, s), c = Math.hypot(i, n);
        if (t === 0)
          a = c / h, o = l / h;
        else {
          const u = t * h;
          a = c > u ? c / u : 1, o = l > u ? l / u : 1;
        }
      }
      this._cachedScaleForStroking[0] = a, this._cachedScaleForStroking[1] = o;
    }
    return this._cachedScaleForStroking;
  }
  rescaleAndStroke(t) {
    const {
      ctx: e
    } = this, {
      lineWidth: s
    } = this.current, [i, n] = this.getScaleForStroking();
    if (e.lineWidth = s || 1, i === 1 && n === 1) {
      e.stroke();
      return;
    }
    const a = e.getLineDash();
    if (t && e.save(), e.scale(i, n), a.length > 0) {
      const o = Math.max(i, n);
      e.setLineDash(a.map((h) => h / o)), e.lineDashOffset /= o;
    }
    e.stroke(), t && e.restore();
  }
  isContentVisible() {
    for (let t = this.markedContentStack.length - 1; t >= 0; t--)
      if (!this.markedContentStack[t].visible)
        return !1;
    return !0;
  }
};
vi = new WeakSet(), qc = /* @__PURE__ */ d(function() {
  for (; this.stateStack.length || this.inSMaskMode; )
    this.restore();
  this.current.activeSMask = null, this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
}, "#restoreInitialState"), Xc = /* @__PURE__ */ d(function() {
  if (this.pageColors) {
    const t = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
    if (t !== "none") {
      const e = this.ctx.filter;
      this.ctx.filter = t, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = e;
    }
  }
}, "#drawFilter"), d(Ml, "CanvasGraphics");
let Un = Ml;
for (const f in Ee)
  Un.prototype[f] !== void 0 && (Un.prototype[Ee[f]] = Un.prototype[f]);
var Xa, Ya;
const ra = class ra {
  static get workerPort() {
    return r(this, Xa);
  }
  static set workerPort(t) {
    if (!(typeof Worker < "u" && t instanceof Worker) && t !== null)
      throw new Error("Invalid `workerPort` type.");
    g(this, Xa, t);
  }
  static get workerSrc() {
    return r(this, Ya);
  }
  static set workerSrc(t) {
    if (typeof t != "string")
      throw new Error("Invalid `workerSrc` type.");
    g(this, Ya, t);
  }
};
Xa = new WeakMap(), Ya = new WeakMap(), d(ra, "GlobalWorkerOptions"), A(ra, Xa, null), A(ra, Ya, "");
let Ds = ra;
const ah = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
}, pt = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function ie(f) {
  switch (f instanceof Error || typeof f == "object" && f !== null || et('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), f.name) {
    case "AbortException":
      return new Bs(f.message);
    case "MissingPDFException":
      return new Hs(f.message);
    case "PasswordException":
      return new oa(f.message, f.code);
    case "UnexpectedResponseException":
      return new Nr(f.message, f.status);
    case "UnknownErrorException":
      return new ha(f.message, f.details);
    default:
      return new ha(f.message, f.toString());
  }
}
d(ie, "wrapReason");
var is, hg, lg, gh;
const of = class of {
  constructor(t, e, s) {
    A(this, is);
    this.sourceName = t, this.targetName = e, this.comObj = s, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (i) => {
      const n = i.data;
      if (n.targetName !== this.sourceName)
        return;
      if (n.stream) {
        m(this, is, lg).call(this, n);
        return;
      }
      if (n.callback) {
        const o = n.callbackId, h = this.callbackCapabilities[o];
        if (!h)
          throw new Error(`Cannot resolve callback ${o}`);
        if (delete this.callbackCapabilities[o], n.callback === ah.DATA)
          h.resolve(n.data);
        else if (n.callback === ah.ERROR)
          h.reject(ie(n.reason));
        else
          throw new Error("Unexpected callback case");
        return;
      }
      const a = this.actionHandler[n.action];
      if (!a)
        throw new Error(`Unknown action from worker: ${n.action}`);
      if (n.callbackId) {
        const o = this.sourceName, h = n.sourceName;
        new Promise(function(l) {
          l(a(n.data));
        }).then(function(l) {
          s.postMessage({
            sourceName: o,
            targetName: h,
            callback: ah.DATA,
            callbackId: n.callbackId,
            data: l
          });
        }, function(l) {
          s.postMessage({
            sourceName: o,
            targetName: h,
            callback: ah.ERROR,
            callbackId: n.callbackId,
            reason: ie(l)
          });
        });
        return;
      }
      if (n.streamId) {
        m(this, is, hg).call(this, n);
        return;
      }
      a(n.data);
    }, s.addEventListener("message", this._onComObjOnMessage);
  }
  on(t, e) {
    const s = this.actionHandler;
    if (s[t])
      throw new Error(`There is already an actionName called "${t}"`);
    s[t] = e;
  }
  send(t, e, s) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: t,
      data: e
    }, s);
  }
  sendWithPromise(t, e, s) {
    const i = this.callbackId++, n = Promise.withResolvers();
    this.callbackCapabilities[i] = n;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: t,
        callbackId: i,
        data: e
      }, s);
    } catch (a) {
      n.reject(a);
    }
    return n.promise;
  }
  sendWithStream(t, e, s, i) {
    const n = this.streamId++, a = this.sourceName, o = this.targetName, h = this.comObj;
    return new ReadableStream({
      start: /* @__PURE__ */ d((l) => {
        const c = Promise.withResolvers();
        return this.streamControllers[n] = {
          controller: l,
          startCall: c,
          pullCall: null,
          cancelCall: null,
          isClosed: !1
        }, h.postMessage({
          sourceName: a,
          targetName: o,
          action: t,
          streamId: n,
          data: e,
          desiredSize: l.desiredSize
        }, i), c.promise;
      }, "start"),
      pull: /* @__PURE__ */ d((l) => {
        const c = Promise.withResolvers();
        return this.streamControllers[n].pullCall = c, h.postMessage({
          sourceName: a,
          targetName: o,
          stream: pt.PULL,
          streamId: n,
          desiredSize: l.desiredSize
        }), c.promise;
      }, "pull"),
      cancel: /* @__PURE__ */ d((l) => {
        _t(l instanceof Error, "cancel must have a valid reason");
        const c = Promise.withResolvers();
        return this.streamControllers[n].cancelCall = c, this.streamControllers[n].isClosed = !0, h.postMessage({
          sourceName: a,
          targetName: o,
          stream: pt.CANCEL,
          streamId: n,
          reason: ie(l)
        }), c.promise;
      }, "cancel")
    }, s);
  }
  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }
};
is = new WeakSet(), hg = /* @__PURE__ */ d(function(t) {
  const e = t.streamId, s = this.sourceName, i = t.sourceName, n = this.comObj, a = this, o = this.actionHandler[t.action], h = {
    enqueue(l, c = 1, u) {
      if (this.isCancelled)
        return;
      const p = this.desiredSize;
      this.desiredSize -= c, p > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), n.postMessage({
        sourceName: s,
        targetName: i,
        stream: pt.ENQUEUE,
        streamId: e,
        chunk: l
      }, u);
    },
    close() {
      this.isCancelled || (this.isCancelled = !0, n.postMessage({
        sourceName: s,
        targetName: i,
        stream: pt.CLOSE,
        streamId: e
      }), delete a.streamSinks[e]);
    },
    error(l) {
      _t(l instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, n.postMessage({
        sourceName: s,
        targetName: i,
        stream: pt.ERROR,
        streamId: e,
        reason: ie(l)
      }));
    },
    sinkCapability: Promise.withResolvers(),
    onPull: null,
    onCancel: null,
    isCancelled: !1,
    desiredSize: t.desiredSize,
    ready: null
  };
  h.sinkCapability.resolve(), h.ready = h.sinkCapability.promise, this.streamSinks[e] = h, new Promise(function(l) {
    l(o(t.data, h));
  }).then(function() {
    n.postMessage({
      sourceName: s,
      targetName: i,
      stream: pt.START_COMPLETE,
      streamId: e,
      success: !0
    });
  }, function(l) {
    n.postMessage({
      sourceName: s,
      targetName: i,
      stream: pt.START_COMPLETE,
      streamId: e,
      reason: ie(l)
    });
  });
}, "#createStreamSink"), lg = /* @__PURE__ */ d(function(t) {
  const e = t.streamId, s = this.sourceName, i = t.sourceName, n = this.comObj, a = this.streamControllers[e], o = this.streamSinks[e];
  switch (t.stream) {
    case pt.START_COMPLETE:
      t.success ? a.startCall.resolve() : a.startCall.reject(ie(t.reason));
      break;
    case pt.PULL_COMPLETE:
      t.success ? a.pullCall.resolve() : a.pullCall.reject(ie(t.reason));
      break;
    case pt.PULL:
      if (!o) {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: pt.PULL_COMPLETE,
          streamId: e,
          success: !0
        });
        break;
      }
      o.desiredSize <= 0 && t.desiredSize > 0 && o.sinkCapability.resolve(), o.desiredSize = t.desiredSize, new Promise(function(h) {
        var l;
        h((l = o.onPull) == null ? void 0 : l.call(o));
      }).then(function() {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: pt.PULL_COMPLETE,
          streamId: e,
          success: !0
        });
      }, function(h) {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: pt.PULL_COMPLETE,
          streamId: e,
          reason: ie(h)
        });
      });
      break;
    case pt.ENQUEUE:
      if (_t(a, "enqueue should have stream controller"), a.isClosed)
        break;
      a.controller.enqueue(t.chunk);
      break;
    case pt.CLOSE:
      if (_t(a, "close should have stream controller"), a.isClosed)
        break;
      a.isClosed = !0, a.controller.close(), m(this, is, gh).call(this, a, e);
      break;
    case pt.ERROR:
      _t(a, "error should have stream controller"), a.controller.error(ie(t.reason)), m(this, is, gh).call(this, a, e);
      break;
    case pt.CANCEL_COMPLETE:
      t.success ? a.cancelCall.resolve() : a.cancelCall.reject(ie(t.reason)), m(this, is, gh).call(this, a, e);
      break;
    case pt.CANCEL:
      if (!o)
        break;
      new Promise(function(h) {
        var l;
        h((l = o.onCancel) == null ? void 0 : l.call(o, ie(t.reason)));
      }).then(function() {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: pt.CANCEL_COMPLETE,
          streamId: e,
          success: !0
        });
      }, function(h) {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: pt.CANCEL_COMPLETE,
          streamId: e,
          reason: ie(h)
        });
      }), o.sinkCapability.reject(ie(t.reason)), o.isCancelled = !0, delete this.streamSinks[e];
      break;
    default:
      throw new Error("Unexpected stream case");
  }
}, "#processStreamMessage"), gh = /* @__PURE__ */ d(async function(t, e) {
  var s, i, n;
  await Promise.allSettled([(s = t.startCall) == null ? void 0 : s.promise, (i = t.pullCall) == null ? void 0 : i.promise, (n = t.cancelCall) == null ? void 0 : n.promise]), delete this.streamControllers[e];
}, "#deleteStreamController"), d(of, "MessageHandler");
let xi = of;
var Gi, Ka;
const hf = class hf {
  constructor({
    parsedData: t,
    rawData: e
  }) {
    A(this, Gi);
    A(this, Ka);
    g(this, Gi, t), g(this, Ka, e);
  }
  getRaw() {
    return r(this, Ka);
  }
  get(t) {
    return r(this, Gi).get(t) ?? null;
  }
  getAll() {
    return vu(r(this, Gi));
  }
  has(t) {
    return r(this, Gi).has(t);
  }
};
Gi = new WeakMap(), Ka = new WeakMap(), d(hf, "Metadata");
let Yc = hf;
const Vs = Symbol("INTERNAL");
var Qa, Ja, Za, er;
const lf = class lf {
  constructor(t, {
    name: e,
    intent: s,
    usage: i
  }) {
    A(this, Qa, !1);
    A(this, Ja, !1);
    A(this, Za, !1);
    A(this, er, !0);
    g(this, Qa, !!(t & ue.DISPLAY)), g(this, Ja, !!(t & ue.PRINT)), this.name = e, this.intent = s, this.usage = i;
  }
  get visible() {
    if (r(this, Za))
      return r(this, er);
    if (!r(this, er))
      return !1;
    const {
      print: t,
      view: e
    } = this.usage;
    return r(this, Qa) ? (e == null ? void 0 : e.viewState) !== "OFF" : r(this, Ja) ? (t == null ? void 0 : t.printState) !== "OFF" : !0;
  }
  _setVisible(t, e, s = !1) {
    t !== Vs && et("Internal method `_setVisible` called."), g(this, Za, s), g(this, er, e);
  }
};
Qa = new WeakMap(), Ja = new WeakMap(), Za = new WeakMap(), er = new WeakMap(), d(lf, "OptionalContentGroup");
let Kc = lf;
var ei, tt, sr, ir, to, Jc;
const cf = class cf {
  constructor(t, e = ue.DISPLAY) {
    A(this, to);
    A(this, ei, null);
    A(this, tt, /* @__PURE__ */ new Map());
    A(this, sr, null);
    A(this, ir, null);
    if (this.renderingIntent = e, this.name = null, this.creator = null, t !== null) {
      this.name = t.name, this.creator = t.creator, g(this, ir, t.order);
      for (const s of t.groups)
        r(this, tt).set(s.id, new Kc(e, s));
      if (t.baseState === "OFF")
        for (const s of r(this, tt).values())
          s._setVisible(Vs, !1);
      for (const s of t.on)
        r(this, tt).get(s)._setVisible(Vs, !0);
      for (const s of t.off)
        r(this, tt).get(s)._setVisible(Vs, !1);
      g(this, sr, this.getHash());
    }
  }
  isVisible(t) {
    if (r(this, tt).size === 0)
      return !0;
    if (!t)
      return jl("Optional content group not defined."), !0;
    if (t.type === "OCG")
      return r(this, tt).has(t.id) ? r(this, tt).get(t.id).visible : ($(`Optional content group not found: ${t.id}`), !0);
    if (t.type === "OCMD") {
      if (t.expression)
        return m(this, to, Jc).call(this, t.expression);
      if (!t.policy || t.policy === "AnyOn") {
        for (const e of t.ids) {
          if (!r(this, tt).has(e))
            return $(`Optional content group not found: ${e}`), !0;
          if (r(this, tt).get(e).visible)
            return !0;
        }
        return !1;
      } else if (t.policy === "AllOn") {
        for (const e of t.ids) {
          if (!r(this, tt).has(e))
            return $(`Optional content group not found: ${e}`), !0;
          if (!r(this, tt).get(e).visible)
            return !1;
        }
        return !0;
      } else if (t.policy === "AnyOff") {
        for (const e of t.ids) {
          if (!r(this, tt).has(e))
            return $(`Optional content group not found: ${e}`), !0;
          if (!r(this, tt).get(e).visible)
            return !0;
        }
        return !1;
      } else if (t.policy === "AllOff") {
        for (const e of t.ids) {
          if (!r(this, tt).has(e))
            return $(`Optional content group not found: ${e}`), !0;
          if (r(this, tt).get(e).visible)
            return !1;
        }
        return !0;
      }
      return $(`Unknown optional content policy ${t.policy}.`), !0;
    }
    return $(`Unknown group type ${t.type}.`), !0;
  }
  setVisibility(t, e = !0) {
    const s = r(this, tt).get(t);
    if (!s) {
      $(`Optional content group not found: ${t}`);
      return;
    }
    s._setVisible(Vs, !!e, !0), g(this, ei, null);
  }
  setOCGState({
    state: t,
    preserveRB: e
  }) {
    let s;
    for (const i of t) {
      switch (i) {
        case "ON":
        case "OFF":
        case "Toggle":
          s = i;
          continue;
      }
      const n = r(this, tt).get(i);
      if (n)
        switch (s) {
          case "ON":
            n._setVisible(Vs, !0);
            break;
          case "OFF":
            n._setVisible(Vs, !1);
            break;
          case "Toggle":
            n._setVisible(Vs, !n.visible);
            break;
        }
    }
    g(this, ei, null);
  }
  get hasInitialVisibility() {
    return r(this, sr) === null || this.getHash() === r(this, sr);
  }
  getOrder() {
    return r(this, tt).size ? r(this, ir) ? r(this, ir).slice() : [...r(this, tt).keys()] : null;
  }
  getGroups() {
    return r(this, tt).size > 0 ? vu(r(this, tt)) : null;
  }
  getGroup(t) {
    return r(this, tt).get(t) || null;
  }
  getHash() {
    if (r(this, ei) !== null)
      return r(this, ei);
    const t = new Gh();
    for (const [e, s] of r(this, tt))
      t.update(`${e}:${s.visible}`);
    return g(this, ei, t.hexdigest());
  }
};
ei = new WeakMap(), tt = new WeakMap(), sr = new WeakMap(), ir = new WeakMap(), to = new WeakSet(), Jc = /* @__PURE__ */ d(function(t) {
  const e = t.length;
  if (e < 2)
    return !0;
  const s = t[0];
  for (let i = 1; i < e; i++) {
    const n = t[i];
    let a;
    if (Array.isArray(n))
      a = m(this, to, Jc).call(this, n);
    else if (r(this, tt).has(n))
      a = r(this, tt).get(n).visible;
    else
      return $(`Optional content group not found: ${n}`), !0;
    switch (s) {
      case "And":
        if (!a)
          return !1;
        break;
      case "Or":
        if (a)
          return !0;
        break;
      case "Not":
        return !a;
      default:
        return !0;
    }
  }
  return s === "And";
}, "#evaluateVisibilityExpression"), d(cf, "OptionalContentConfig");
let Qc = cf;
const df = class df {
  constructor(t, {
    disableRange: e = !1,
    disableStream: s = !1
  }) {
    _t(t, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    const {
      length: i,
      initialData: n,
      progressiveDone: a,
      contentDispositionFilename: o
    } = t;
    if (this._queuedChunks = [], this._progressiveDone = a, this._contentDispositionFilename = o, (n == null ? void 0 : n.length) > 0) {
      const h = n instanceof Uint8Array && n.byteLength === n.buffer.byteLength ? n.buffer : new Uint8Array(n).buffer;
      this._queuedChunks.push(h);
    }
    this._pdfDataRangeTransport = t, this._isStreamingSupported = !s, this._isRangeSupported = !e, this._contentLength = i, this._fullRequestReader = null, this._rangeReaders = [], t.addRangeListener((h, l) => {
      this._onReceiveData({
        begin: h,
        chunk: l
      });
    }), t.addProgressListener((h, l) => {
      this._onProgress({
        loaded: h,
        total: l
      });
    }), t.addProgressiveReadListener((h) => {
      this._onReceiveData({
        chunk: h
      });
    }), t.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    }), t.transportReady();
  }
  _onReceiveData({
    begin: t,
    chunk: e
  }) {
    const s = e instanceof Uint8Array && e.byteLength === e.buffer.byteLength ? e.buffer : new Uint8Array(e).buffer;
    if (t === void 0)
      this._fullRequestReader ? this._fullRequestReader._enqueue(s) : this._queuedChunks.push(s);
    else {
      const i = this._rangeReaders.some(function(n) {
        return n._begin !== t ? !1 : (n._enqueue(s), !0);
      });
      _t(i, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }
  get _progressiveDataLength() {
    var t;
    return ((t = this._fullRequestReader) == null ? void 0 : t._loaded) ?? 0;
  }
  _onProgress(t) {
    var e, s, i, n;
    t.total === void 0 ? (s = (e = this._rangeReaders[0]) == null ? void 0 : e.onProgress) == null || s.call(e, {
      loaded: t.loaded
    }) : (n = (i = this._fullRequestReader) == null ? void 0 : i.onProgress) == null || n.call(i, {
      loaded: t.loaded,
      total: t.total
    });
  }
  _onProgressiveDone() {
    var t;
    (t = this._fullRequestReader) == null || t.progressiveDone(), this._progressiveDone = !0;
  }
  _removeRangeReader(t) {
    const e = this._rangeReaders.indexOf(t);
    e >= 0 && this._rangeReaders.splice(e, 1);
  }
  getFullReader() {
    _t(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const t = this._queuedChunks;
    return this._queuedChunks = null, new td(this, t, this._progressiveDone, this._contentDispositionFilename);
  }
  getRangeReader(t, e) {
    if (e <= this._progressiveDataLength)
      return null;
    const s = new ed(this, t, e);
    return this._pdfDataRangeTransport.requestDataRange(t, e), this._rangeReaders.push(s), s;
  }
  cancelAllRequests(t) {
    var e;
    (e = this._fullRequestReader) == null || e.cancel(t);
    for (const s of this._rangeReaders.slice(0))
      s.cancel(t);
    this._pdfDataRangeTransport.abort();
  }
};
d(df, "PDFDataTransportStream");
let Zc = df;
const uf = class uf {
  constructor(t, e, s = !1, i = null) {
    this._stream = t, this._done = s || !1, this._filename = yu(i) ? i : null, this._queuedChunks = e || [], this._loaded = 0;
    for (const n of this._queuedChunks)
      this._loaded += n.byteLength;
    this._requests = [], this._headersReady = Promise.resolve(), t._fullRequestReader = this, this.onProgress = null;
  }
  _enqueue(t) {
    this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
      value: t,
      done: !1
    }) : this._queuedChunks.push(t), this._loaded += t.byteLength);
  }
  get headersReady() {
    return this._headersReady;
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }
  get contentLength() {
    return this._stream._contentLength;
  }
  async read() {
    if (this._queuedChunks.length > 0)
      return {
        value: this._queuedChunks.shift(),
        done: !1
      };
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const t = Promise.withResolvers();
    return this._requests.push(t), t.promise;
  }
  cancel(t) {
    this._done = !0;
    for (const e of this._requests)
      e.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0;
  }
  progressiveDone() {
    this._done || (this._done = !0);
  }
};
d(uf, "PDFDataTransportStreamReader");
let td = uf;
const ff = class ff {
  constructor(t, e, s) {
    this._stream = t, this._begin = e, this._end = s, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
  }
  _enqueue(t) {
    if (!this._done) {
      if (this._requests.length === 0)
        this._queuedChunk = t;
      else {
        this._requests.shift().resolve({
          value: t,
          done: !1
        });
        for (const s of this._requests)
          s.resolve({
            value: void 0,
            done: !0
          });
        this._requests.length = 0;
      }
      this._done = !0, this._stream._removeRangeReader(this);
    }
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    if (this._queuedChunk) {
      const e = this._queuedChunk;
      return this._queuedChunk = null, {
        value: e,
        done: !1
      };
    }
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const t = Promise.withResolvers();
    return this._requests.push(t), t.promise;
  }
  cancel(t) {
    this._done = !0;
    for (const e of this._requests)
      e.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._stream._removeRangeReader(this);
  }
};
d(ff, "PDFDataTransportStreamRangeReader");
let ed = ff;
function Bm(f) {
  let t = !0, e = s("filename\\*", "i").exec(f);
  if (e) {
    e = e[1];
    let c = o(e);
    return c = unescape(c), c = h(c), c = l(c), n(c);
  }
  if (e = a(f), e) {
    const c = l(e);
    return n(c);
  }
  if (e = s("filename", "i").exec(f), e) {
    e = e[1];
    let c = o(e);
    return c = l(c), n(c);
  }
  function s(c, u) {
    return new RegExp("(?:^|;)\\s*" + c + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', u);
  }
  d(s, "toParamRegExp");
  function i(c, u) {
    if (c) {
      if (!/^[\x00-\xFF]+$/.test(u))
        return u;
      try {
        const p = new TextDecoder(c, {
          fatal: !0
        }), b = Wl(u);
        u = p.decode(b), t = !1;
      } catch {
      }
    }
    return u;
  }
  d(i, "textdecode");
  function n(c) {
    return t && /[\x80-\xff]/.test(c) && (c = i("utf-8", c), t && (c = i("iso-8859-1", c))), c;
  }
  d(n, "fixupEncoding");
  function a(c) {
    const u = [];
    let p;
    const b = s("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
    for (; (p = b.exec(c)) !== null; ) {
      let [, y, _, w] = p;
      if (y = parseInt(y, 10), y in u) {
        if (y === 0)
          break;
        continue;
      }
      u[y] = [_, w];
    }
    const v = [];
    for (let y = 0; y < u.length && y in u; ++y) {
      let [_, w] = u[y];
      w = o(w), _ && (w = unescape(w), y === 0 && (w = h(w))), v.push(w);
    }
    return v.join("");
  }
  d(a, "rfc2231getparam");
  function o(c) {
    if (c.startsWith('"')) {
      const u = c.slice(1).split('\\"');
      for (let p = 0; p < u.length; ++p) {
        const b = u[p].indexOf('"');
        b !== -1 && (u[p] = u[p].slice(0, b), u.length = p + 1), u[p] = u[p].replaceAll(/\\(.)/g, "$1");
      }
      c = u.join('"');
    }
    return c;
  }
  d(o, "rfc2616unquote");
  function h(c) {
    const u = c.indexOf("'");
    if (u === -1)
      return c;
    const p = c.slice(0, u), v = c.slice(u + 1).replace(/^[^']*'/, "");
    return i(p, v);
  }
  d(h, "rfc5987decode");
  function l(c) {
    return !c.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(c) ? c : c.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(u, p, b, v) {
      if (b === "q" || b === "Q")
        return v = v.replaceAll("_", " "), v = v.replaceAll(/=([0-9a-fA-F]{2})/g, function(y, _) {
          return String.fromCharCode(parseInt(_, 16));
        }), i(p, v);
      try {
        v = atob(v);
      } catch {
      }
      return i(p, v);
    });
  }
  return d(l, "rfc2047decode"), "";
}
d(Bm, "getFilenameFromContentDispositionHeader");
function _u({
  getResponseHeader: f,
  isHttp: t,
  rangeChunkSize: e,
  disableRange: s
}) {
  const i = {
    allowRangeRequests: !1,
    suggestedLength: void 0
  }, n = parseInt(f("Content-Length"), 10);
  return !Number.isInteger(n) || (i.suggestedLength = n, n <= 2 * e) || s || !t || f("Accept-Ranges") !== "bytes" || (f("Content-Encoding") || "identity") !== "identity" || (i.allowRangeRequests = !0), i;
}
d(_u, "validateRangeRequestCapabilities");
function Eu(f) {
  const t = f("Content-Disposition");
  if (t) {
    let e = Bm(t);
    if (e.includes("%"))
      try {
        e = decodeURIComponent(e);
      } catch {
      }
    if (yu(e))
      return e;
  }
  return null;
}
d(Eu, "extractFilenameFromHeader");
function ql(f, t) {
  return f === 404 || f === 0 && t.startsWith("file:") ? new Hs('Missing PDF "' + t + '".') : new Nr(`Unexpected server response (${f}) while retrieving PDF "${t}".`, f);
}
d(ql, "createResponseStatusError");
function cg(f) {
  return f === 200 || f === 206;
}
d(cg, "validateResponseStatus");
function dg(f, t, e) {
  return {
    method: "GET",
    headers: f,
    signal: e.signal,
    mode: "cors",
    credentials: t ? "include" : "same-origin",
    redirect: "follow"
  };
}
d(dg, "createFetchOptions");
function ug(f) {
  const t = new Headers();
  for (const e in f) {
    const s = f[e];
    s !== void 0 && t.append(e, s);
  }
  return t;
}
d(ug, "createHeaders");
function fg(f) {
  return f instanceof Uint8Array ? f.buffer : f instanceof ArrayBuffer ? f : ($(`getArrayBuffer - unexpected data format: ${f}`), new Uint8Array(f).buffer);
}
d(fg, "getArrayBuffer");
const pf = class pf {
  constructor(t) {
    this.source = t, this.isHttp = /^https?:/i.test(t.url), this.httpHeaders = this.isHttp && t.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var t;
    return ((t = this._fullRequestReader) == null ? void 0 : t._loaded) ?? 0;
  }
  getFullReader() {
    return _t(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new sd(this), this._fullRequestReader;
  }
  getRangeReader(t, e) {
    if (e <= this._progressiveDataLength)
      return null;
    const s = new id(this, t, e);
    return this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(t) {
    var e;
    (e = this._fullRequestReader) == null || e.cancel(t);
    for (const s of this._rangeRequestReaders.slice(0))
      s.cancel(t);
  }
};
d(pf, "PDFFetchStream");
let Yh = pf;
const gf = class gf {
  constructor(t) {
    this._stream = t, this._reader = null, this._loaded = 0, this._filename = null;
    const e = t.source;
    this._withCredentials = e.withCredentials || !1, this._contentLength = e.length, this._headersCapability = Promise.withResolvers(), this._disableRange = e.disableRange || !1, this._rangeChunkSize = e.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !e.disableStream, this._isRangeSupported = !e.disableRange, this._headers = ug(this._stream.httpHeaders);
    const s = e.url;
    fetch(s, dg(this._headers, this._withCredentials, this._abortController)).then((i) => {
      if (!cg(i.status))
        throw ql(i.status, s);
      this._reader = i.body.getReader(), this._headersCapability.resolve();
      const n = /* @__PURE__ */ d((h) => i.headers.get(h), "getResponseHeader"), {
        allowRangeRequests: a,
        suggestedLength: o
      } = _u({
        getResponseHeader: n,
        isHttp: this._stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = a, this._contentLength = o || this._contentLength, this._filename = Eu(n), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new Bs("Streaming is disabled."));
    }).catch(this._headersCapability.reject), this.onProgress = null;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    await this._headersCapability.promise;
    const {
      value: t,
      done: e
    } = await this._reader.read();
    return e ? {
      value: t,
      done: e
    } : (this._loaded += t.byteLength, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    }), {
      value: fg(t),
      done: !1
    });
  }
  cancel(t) {
    var e;
    (e = this._reader) == null || e.cancel(t), this._abortController.abort();
  }
};
d(gf, "PDFFetchStreamReader");
let sd = gf;
const mf = class mf {
  constructor(t, e, s) {
    this._stream = t, this._reader = null, this._loaded = 0;
    const i = t.source;
    this._withCredentials = i.withCredentials || !1, this._readCapability = Promise.withResolvers(), this._isStreamingSupported = !i.disableStream, this._abortController = new AbortController(), this._headers = ug(this._stream.httpHeaders), this._headers.append("Range", `bytes=${e}-${s - 1}`);
    const n = i.url;
    fetch(n, dg(this._headers, this._withCredentials, this._abortController)).then((a) => {
      if (!cg(a.status))
        throw ql(a.status, n);
      this._readCapability.resolve(), this._reader = a.body.getReader();
    }).catch(this._readCapability.reject), this.onProgress = null;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    await this._readCapability.promise;
    const {
      value: t,
      done: e
    } = await this._reader.read();
    return e ? {
      value: t,
      done: e
    } : (this._loaded += t.byteLength, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded
    }), {
      value: fg(t),
      done: !1
    });
  }
  cancel(t) {
    var e;
    (e = this._reader) == null || e.cancel(t), this._abortController.abort();
  }
};
d(mf, "PDFFetchStreamRangeReader");
let id = mf;
const Zl = 200, tc = 206;
function Um(f) {
  const t = f.response;
  return typeof t != "string" ? t : Wl(t).buffer;
}
d(Um, "network_getArrayBuffer");
const bf = class bf {
  constructor(t, e = {}) {
    this.url = t, this.isHttp = /^https?:/i.test(t), this.httpHeaders = this.isHttp && e.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = e.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
  }
  requestRange(t, e, s) {
    const i = {
      begin: t,
      end: e
    };
    for (const n in s)
      i[n] = s[n];
    return this.request(i);
  }
  requestFull(t) {
    return this.request(t);
  }
  request(t) {
    const e = new XMLHttpRequest(), s = this.currXhrId++, i = this.pendingRequests[s] = {
      xhr: e
    };
    e.open("GET", this.url), e.withCredentials = this.withCredentials;
    for (const n in this.httpHeaders) {
      const a = this.httpHeaders[n];
      a !== void 0 && e.setRequestHeader(n, a);
    }
    return this.isHttp && "begin" in t && "end" in t ? (e.setRequestHeader("Range", `bytes=${t.begin}-${t.end - 1}`), i.expectedStatus = tc) : i.expectedStatus = Zl, e.responseType = "arraybuffer", t.onError && (e.onerror = function(n) {
      t.onError(e.status);
    }), e.onreadystatechange = this.onStateChange.bind(this, s), e.onprogress = this.onProgress.bind(this, s), i.onHeadersReceived = t.onHeadersReceived, i.onDone = t.onDone, i.onError = t.onError, i.onProgress = t.onProgress, e.send(null), s;
  }
  onProgress(t, e) {
    var i;
    const s = this.pendingRequests[t];
    s && ((i = s.onProgress) == null || i.call(s, e));
  }
  onStateChange(t, e) {
    var h, l, c;
    const s = this.pendingRequests[t];
    if (!s)
      return;
    const i = s.xhr;
    if (i.readyState >= 2 && s.onHeadersReceived && (s.onHeadersReceived(), delete s.onHeadersReceived), i.readyState !== 4 || !(t in this.pendingRequests))
      return;
    if (delete this.pendingRequests[t], i.status === 0 && this.isHttp) {
      (h = s.onError) == null || h.call(s, i.status);
      return;
    }
    const n = i.status || Zl;
    if (!(n === Zl && s.expectedStatus === tc) && n !== s.expectedStatus) {
      (l = s.onError) == null || l.call(s, i.status);
      return;
    }
    const o = Um(i);
    if (n === tc) {
      const u = i.getResponseHeader("Content-Range"), p = /bytes (\d+)-(\d+)\/(\d+)/.exec(u);
      s.onDone({
        begin: parseInt(p[1], 10),
        chunk: o
      });
    } else o ? s.onDone({
      begin: 0,
      chunk: o
    }) : (c = s.onError) == null || c.call(s, i.status);
  }
  getRequestXhr(t) {
    return this.pendingRequests[t].xhr;
  }
  isPendingRequest(t) {
    return t in this.pendingRequests;
  }
  abortRequest(t) {
    const e = this.pendingRequests[t].xhr;
    delete this.pendingRequests[t], e.abort();
  }
};
d(bf, "NetworkManager");
let nd = bf;
const Af = class Af {
  constructor(t) {
    this._source = t, this._manager = new nd(t.url, {
      httpHeaders: t.httpHeaders,
      withCredentials: t.withCredentials
    }), this._rangeChunkSize = t.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  _onRangeRequestReaderClosed(t) {
    const e = this._rangeRequestReaders.indexOf(t);
    e >= 0 && this._rangeRequestReaders.splice(e, 1);
  }
  getFullReader() {
    return _t(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new ad(this._manager, this._source), this._fullRequestReader;
  }
  getRangeReader(t, e) {
    const s = new od(this._manager, t, e);
    return s.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(t) {
    var e;
    (e = this._fullRequestReader) == null || e.cancel(t);
    for (const s of this._rangeRequestReaders.slice(0))
      s.cancel(t);
  }
};
d(Af, "PDFNetworkStream");
let rd = Af;
const vf = class vf {
  constructor(t, e) {
    this._manager = t;
    const s = {
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = e.url, this._fullRequestId = t.requestFull(s), this._headersReceivedCapability = Promise.withResolvers(), this._disableRange = e.disableRange || !1, this._contentLength = e.length, this._rangeChunkSize = e.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
  }
  _onHeadersReceived() {
    const t = this._fullRequestId, e = this._manager.getRequestXhr(t), s = /* @__PURE__ */ d((a) => e.getResponseHeader(a), "getResponseHeader"), {
      allowRangeRequests: i,
      suggestedLength: n
    } = _u({
      getResponseHeader: s,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });
    i && (this._isRangeSupported = !0), this._contentLength = n || this._contentLength, this._filename = Eu(s), this._isRangeSupported && this._manager.abortRequest(t), this._headersReceivedCapability.resolve();
  }
  _onDone(t) {
    if (t && (this._requests.length > 0 ? this._requests.shift().resolve({
      value: t.chunk,
      done: !1
    }) : this._cachedChunks.push(t.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
      for (const e of this._requests)
        e.resolve({
          value: void 0,
          done: !0
        });
      this._requests.length = 0;
    }
  }
  _onError(t) {
    this._storedError = ql(t, this._url), this._headersReceivedCapability.reject(this._storedError);
    for (const e of this._requests)
      e.reject(this._storedError);
    this._requests.length = 0, this._cachedChunks.length = 0;
  }
  _onProgress(t) {
    var e;
    (e = this.onProgress) == null || e.call(this, {
      loaded: t.loaded,
      total: t.lengthComputable ? t.total : this._contentLength
    });
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get contentLength() {
    return this._contentLength;
  }
  get headersReady() {
    return this._headersReceivedCapability.promise;
  }
  async read() {
    if (this._storedError)
      throw this._storedError;
    if (this._cachedChunks.length > 0)
      return {
        value: this._cachedChunks.shift(),
        done: !1
      };
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const t = Promise.withResolvers();
    return this._requests.push(t), t.promise;
  }
  cancel(t) {
    this._done = !0, this._headersReceivedCapability.reject(t);
    for (const e of this._requests)
      e.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
  }
};
d(vf, "PDFNetworkStreamFullRequestReader");
let ad = vf;
const yf = class yf {
  constructor(t, e, s) {
    this._manager = t;
    const i = {
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = t.url, this._requestId = t.requestRange(e, s, i), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
  }
  _close() {
    var t;
    (t = this.onClosed) == null || t.call(this, this);
  }
  _onDone(t) {
    const e = t.chunk;
    this._requests.length > 0 ? this._requests.shift().resolve({
      value: e,
      done: !1
    }) : this._queuedChunk = e, this._done = !0;
    for (const s of this._requests)
      s.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._close();
  }
  _onError(t) {
    this._storedError = ql(t, this._url);
    for (const e of this._requests)
      e.reject(this._storedError);
    this._requests.length = 0, this._queuedChunk = null;
  }
  _onProgress(t) {
    var e;
    this.isStreamingSupported || (e = this.onProgress) == null || e.call(this, {
      loaded: t.loaded
    });
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    if (this._storedError)
      throw this._storedError;
    if (this._queuedChunk !== null) {
      const e = this._queuedChunk;
      return this._queuedChunk = null, {
        value: e,
        done: !1
      };
    }
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const t = Promise.withResolvers();
    return this._requests.push(t), t.promise;
  }
  cancel(t) {
    this._done = !0;
    for (const e of this._requests)
      e.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
  }
};
d(yf, "PDFNetworkStreamRangeRequestReader");
let od = yf;
const pg = /^file:\/\/\/[a-zA-Z]:\//;
function zm(f) {
  const t = _e.get("url"), e = t.parse(f);
  return e.protocol === "file:" || e.host ? e : /^[a-z]:[/\\]/i.test(f) ? t.parse(`file:///${f}`) : (e.host || (e.protocol = "file:"), e);
}
d(zm, "parseUrl");
const wf = class wf {
  constructor(t) {
    this.source = t, this.url = zm(t.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && t.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var t;
    return ((t = this._fullRequestReader) == null ? void 0 : t._loaded) ?? 0;
  }
  getFullReader() {
    return _t(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new dd(this) : new ld(this), this._fullRequestReader;
  }
  getRangeReader(t, e) {
    if (e <= this._progressiveDataLength)
      return null;
    const s = this.isFsUrl ? new ud(this, t, e) : new cd(this, t, e);
    return this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(t) {
    var e;
    (e = this._fullRequestReader) == null || e.cancel(t);
    for (const s of this._rangeRequestReaders.slice(0))
      s.cancel(t);
  }
};
d(wf, "PDFNodeStream");
let hd = wf;
const _f = class _f {
  constructor(t) {
    this._url = t.url, this._done = !1, this._storedError = null, this.onProgress = null;
    const e = t.source;
    this._contentLength = e.length, this._loaded = 0, this._filename = null, this._disableRange = e.disableRange || !1, this._rangeChunkSize = e.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !e.disableStream, this._isRangeSupported = !e.disableRange, this._readableStream = null, this._readCapability = Promise.withResolvers(), this._headersCapability = Promise.withResolvers();
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    if (await this._readCapability.promise, this._done)
      return {
        value: void 0,
        done: !0
      };
    if (this._storedError)
      throw this._storedError;
    const t = this._readableStream.read();
    return t === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += t.length, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    }), {
      value: new Uint8Array(t).buffer,
      done: !1
    });
  }
  cancel(t) {
    if (!this._readableStream) {
      this._error(t);
      return;
    }
    this._readableStream.destroy(t);
  }
  _error(t) {
    this._storedError = t, this._readCapability.resolve();
  }
  _setReadableStream(t) {
    this._readableStream = t, t.on("readable", () => {
      this._readCapability.resolve();
    }), t.on("end", () => {
      t.destroy(), this._done = !0, this._readCapability.resolve();
    }), t.on("error", (e) => {
      this._error(e);
    }), !this._isStreamingSupported && this._isRangeSupported && this._error(new Bs("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
  }
};
d(_f, "BaseFullReader");
let Kh = _f;
const Ef = class Ef {
  constructor(t) {
    this._url = t.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = Promise.withResolvers();
    const e = t.source;
    this._isStreamingSupported = !e.disableStream;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    if (await this._readCapability.promise, this._done)
      return {
        value: void 0,
        done: !0
      };
    if (this._storedError)
      throw this._storedError;
    const t = this._readableStream.read();
    return t === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += t.length, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded
    }), {
      value: new Uint8Array(t).buffer,
      done: !1
    });
  }
  cancel(t) {
    if (!this._readableStream) {
      this._error(t);
      return;
    }
    this._readableStream.destroy(t);
  }
  _error(t) {
    this._storedError = t, this._readCapability.resolve();
  }
  _setReadableStream(t) {
    this._readableStream = t, t.on("readable", () => {
      this._readCapability.resolve();
    }), t.on("end", () => {
      t.destroy(), this._done = !0, this._readCapability.resolve();
    }), t.on("error", (e) => {
      this._error(e);
    }), this._storedError && this._readableStream.destroy(this._storedError);
  }
};
d(Ef, "BaseRangeReader");
let Qh = Ef;
function Jh(f, t) {
  return {
    protocol: f.protocol,
    auth: f.auth,
    host: f.hostname,
    port: f.port,
    path: f.path,
    method: "GET",
    headers: t
  };
}
d(Jh, "createRequestOptions");
const Sf = class Sf extends Kh {
  constructor(t) {
    super(t);
    const e = /* @__PURE__ */ d((s) => {
      if (s.statusCode === 404) {
        const o = new Hs(`Missing PDF "${this._url}".`);
        this._storedError = o, this._headersCapability.reject(o);
        return;
      }
      this._headersCapability.resolve(), this._setReadableStream(s);
      const i = /* @__PURE__ */ d((o) => this._readableStream.headers[o.toLowerCase()], "getResponseHeader"), {
        allowRangeRequests: n,
        suggestedLength: a
      } = _u({
        getResponseHeader: i,
        isHttp: t.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = n, this._contentLength = a || this._contentLength, this._filename = Eu(i);
    }, "handleResponse");
    if (this._request = null, this._url.protocol === "http:") {
      const s = _e.get("http");
      this._request = s.request(Jh(this._url, t.httpHeaders), e);
    } else {
      const s = _e.get("https");
      this._request = s.request(Jh(this._url, t.httpHeaders), e);
    }
    this._request.on("error", (s) => {
      this._storedError = s, this._headersCapability.reject(s);
    }), this._request.end();
  }
};
d(Sf, "PDFNodeStreamFullReader");
let ld = Sf;
const Cf = class Cf extends Qh {
  constructor(t, e, s) {
    super(t), this._httpHeaders = {};
    for (const n in t.httpHeaders) {
      const a = t.httpHeaders[n];
      a !== void 0 && (this._httpHeaders[n] = a);
    }
    this._httpHeaders.Range = `bytes=${e}-${s - 1}`;
    const i = /* @__PURE__ */ d((n) => {
      if (n.statusCode === 404) {
        const a = new Hs(`Missing PDF "${this._url}".`);
        this._storedError = a;
        return;
      }
      this._setReadableStream(n);
    }, "handleResponse");
    if (this._request = null, this._url.protocol === "http:") {
      const n = _e.get("http");
      this._request = n.request(Jh(this._url, this._httpHeaders), i);
    } else {
      const n = _e.get("https");
      this._request = n.request(Jh(this._url, this._httpHeaders), i);
    }
    this._request.on("error", (n) => {
      this._storedError = n;
    }), this._request.end();
  }
};
d(Cf, "PDFNodeStreamRangeReader");
let cd = Cf;
const xf = class xf extends Kh {
  constructor(t) {
    super(t);
    let e = decodeURIComponent(this._url.path);
    pg.test(this._url.href) && (e = e.replace(/^\//, ""));
    const s = _e.get("fs");
    s.promises.lstat(e).then((i) => {
      this._contentLength = i.size, this._setReadableStream(s.createReadStream(e)), this._headersCapability.resolve();
    }, (i) => {
      i.code === "ENOENT" && (i = new Hs(`Missing PDF "${e}".`)), this._storedError = i, this._headersCapability.reject(i);
    });
  }
};
d(xf, "PDFNodeStreamFsFullReader");
let dd = xf;
const Tf = class Tf extends Qh {
  constructor(t, e, s) {
    super(t);
    let i = decodeURIComponent(this._url.path);
    pg.test(this._url.href) && (i = i.replace(/^\//, ""));
    const n = _e.get("fs");
    this._setReadableStream(n.createReadStream(i, {
      start: e,
      end: s - 1
    }));
  }
};
d(Tf, "PDFNodeStreamFsRangeReader");
let ud = Tf;
const $m = 1e5, Kt = 30, jm = 0.8;
var Mp, si, Jt, eo, so, qi, As, io, no, Xi, nr, rr, ii, ar, ro, or, Yi, ao, oo, Ki, Qi, ni, hr, zs, gg, mg, fd, ns, mh, bg, Ag;
const Rt = class Rt {
  constructor({
    textContentSource: t,
    container: e,
    viewport: s
  }) {
    A(this, zs);
    A(this, si, Promise.withResolvers());
    A(this, Jt, null);
    A(this, eo, !1);
    A(this, so, !!((Mp = globalThis.FontInspector) != null && Mp.enabled));
    A(this, qi, null);
    A(this, As, null);
    A(this, io, 0);
    A(this, no, 0);
    A(this, Xi, null);
    A(this, nr, null);
    A(this, rr, 0);
    A(this, ii, 0);
    A(this, ar, /* @__PURE__ */ Object.create(null));
    A(this, ro, []);
    A(this, or, null);
    A(this, Yi, []);
    A(this, ao, /* @__PURE__ */ new WeakMap());
    A(this, oo, null);
    var h;
    if (t instanceof ReadableStream)
      g(this, or, t);
    else if (typeof t == "object")
      g(this, or, new ReadableStream({
        start(l) {
          l.enqueue(t), l.close();
        }
      }));
    else
      throw new Error('No "textContentSource" parameter specified.');
    g(this, Jt, g(this, nr, e)), g(this, ii, s.scale * (globalThis.devicePixelRatio || 1)), g(this, rr, s.rotation), g(this, As, {
      prevFontSize: null,
      prevFontFamily: null,
      div: null,
      properties: null,
      ctx: null
    });
    const {
      pageWidth: i,
      pageHeight: n,
      pageX: a,
      pageY: o
    } = s.rawDims;
    g(this, oo, [1, 0, 0, -1, -a, o + n]), g(this, no, i), g(this, io, n), m(h = Rt, ns, bg).call(h), xn(e, s), r(this, si).promise.catch(() => {
    }).then(() => {
      r(Rt, hr).delete(this), g(this, As, null), g(this, ar, null);
    });
  }
  render() {
    const t = /* @__PURE__ */ d(() => {
      r(this, Xi).read().then(({
        value: e,
        done: s
      }) => {
        if (s) {
          r(this, si).resolve();
          return;
        }
        r(this, qi) ?? g(this, qi, e.lang), Object.assign(r(this, ar), e.styles), m(this, zs, gg).call(this, e.items), t();
      }, r(this, si).reject);
    }, "pump");
    return g(this, Xi, r(this, or).getReader()), r(Rt, hr).add(this), t(), r(this, si).promise;
  }
  update({
    viewport: t,
    onBefore: e = null
  }) {
    var n;
    const s = t.scale * (globalThis.devicePixelRatio || 1), i = t.rotation;
    if (i !== r(this, rr) && (e == null || e(), g(this, rr, i), xn(r(this, nr), {
      rotation: i
    })), s !== r(this, ii)) {
      e == null || e(), g(this, ii, s);
      const a = {
        prevFontSize: null,
        prevFontFamily: null,
        div: null,
        properties: null,
        ctx: m(n = Rt, ns, mh).call(n, r(this, qi))
      };
      for (const o of r(this, Yi))
        a.properties = r(this, ao).get(o), a.div = o, m(this, zs, fd).call(this, a);
    }
  }
  cancel() {
    var e;
    const t = new Bs("TextLayer task cancelled.");
    (e = r(this, Xi)) == null || e.cancel(t).catch(() => {
    }), g(this, Xi, null), r(this, si).reject(t);
  }
  get textDivs() {
    return r(this, Yi);
  }
  get textContentItemsStr() {
    return r(this, ro);
  }
  static cleanup() {
    if (!(r(this, hr).size > 0)) {
      r(this, Ki).clear();
      for (const {
        canvas: t
      } of r(this, Qi).values())
        t.remove();
      r(this, Qi).clear();
    }
  }
};
si = new WeakMap(), Jt = new WeakMap(), eo = new WeakMap(), so = new WeakMap(), qi = new WeakMap(), As = new WeakMap(), io = new WeakMap(), no = new WeakMap(), Xi = new WeakMap(), nr = new WeakMap(), rr = new WeakMap(), ii = new WeakMap(), ar = new WeakMap(), ro = new WeakMap(), or = new WeakMap(), Yi = new WeakMap(), ao = new WeakMap(), oo = new WeakMap(), Ki = new WeakMap(), Qi = new WeakMap(), ni = new WeakMap(), hr = new WeakMap(), zs = new WeakSet(), gg = /* @__PURE__ */ d(function(t) {
  var i, n;
  if (r(this, eo))
    return;
  (n = r(this, As)).ctx ?? (n.ctx = m(i = Rt, ns, mh).call(i, r(this, qi)));
  const e = r(this, Yi), s = r(this, ro);
  for (const a of t) {
    if (e.length > $m) {
      $("Ignoring additional textDivs for performance reasons."), g(this, eo, !0);
      return;
    }
    if (a.str === void 0) {
      if (a.type === "beginMarkedContentProps" || a.type === "beginMarkedContent") {
        const o = r(this, Jt);
        g(this, Jt, document.createElement("span")), r(this, Jt).classList.add("markedContent"), a.id !== null && r(this, Jt).setAttribute("id", `${a.id}`), o.append(r(this, Jt));
      } else a.type === "endMarkedContent" && g(this, Jt, r(this, Jt).parentNode);
      continue;
    }
    s.push(a.str), m(this, zs, mg).call(this, a);
  }
}, "#processItems"), mg = /* @__PURE__ */ d(function(t) {
  var y;
  const e = document.createElement("span"), s = {
    angle: 0,
    canvasWidth: 0,
    hasText: t.str !== "",
    hasEOL: t.hasEOL,
    fontSize: 0
  };
  r(this, Yi).push(e);
  const i = I.transform(r(this, oo), t.transform);
  let n = Math.atan2(i[1], i[0]);
  const a = r(this, ar)[t.fontName];
  a.vertical && (n += Math.PI / 2);
  const o = r(this, so) && a.fontSubstitution || a.fontFamily, h = Math.hypot(i[2], i[3]), l = h * m(y = Rt, ns, Ag).call(y, o, r(this, qi));
  let c, u;
  n === 0 ? (c = i[4], u = i[5] - l) : (c = i[4] + l * Math.sin(n), u = i[5] - l * Math.cos(n));
  const p = "calc(var(--scale-factor)*", b = e.style;
  r(this, Jt) === r(this, nr) ? (b.left = `${(100 * c / r(this, no)).toFixed(2)}%`, b.top = `${(100 * u / r(this, io)).toFixed(2)}%`) : (b.left = `${p}${c.toFixed(2)}px)`, b.top = `${p}${u.toFixed(2)}px)`), b.fontSize = `${p}${(r(Rt, ni) * h).toFixed(2)}px)`, b.fontFamily = o, s.fontSize = h, e.setAttribute("role", "presentation"), e.textContent = t.str, e.dir = t.dir, r(this, so) && (e.dataset.fontName = a.fontSubstitutionLoadedName || t.fontName), n !== 0 && (s.angle = n * (180 / Math.PI));
  let v = !1;
  if (t.str.length > 1)
    v = !0;
  else if (t.str !== " " && t.transform[0] !== t.transform[3]) {
    const _ = Math.abs(t.transform[0]), w = Math.abs(t.transform[3]);
    _ !== w && Math.max(_, w) / Math.min(_, w) > 1.5 && (v = !0);
  }
  if (v && (s.canvasWidth = a.vertical ? t.height : t.width), r(this, ao).set(e, s), r(this, As).div = e, r(this, As).properties = s, m(this, zs, fd).call(this, r(this, As)), s.hasText && r(this, Jt).append(e), s.hasEOL) {
    const _ = document.createElement("br");
    _.setAttribute("role", "presentation"), r(this, Jt).append(_);
  }
}, "#appendText"), fd = /* @__PURE__ */ d(function(t) {
  const {
    div: e,
    properties: s,
    ctx: i,
    prevFontSize: n,
    prevFontFamily: a
  } = t, {
    style: o
  } = e;
  let h = "";
  if (r(Rt, ni) > 1 && (h = `scale(${1 / r(Rt, ni)})`), s.canvasWidth !== 0 && s.hasText) {
    const {
      fontFamily: l
    } = o, {
      canvasWidth: c,
      fontSize: u
    } = s;
    (n !== u || a !== l) && (i.font = `${u * r(this, ii)}px ${l}`, t.prevFontSize = u, t.prevFontFamily = l);
    const {
      width: p
    } = i.measureText(e.textContent);
    p > 0 && (h = `scaleX(${c * r(this, ii) / p}) ${h}`);
  }
  s.angle !== 0 && (h = `rotate(${s.angle}deg) ${h}`), h.length > 0 && (o.transform = h);
}, "#layout"), ns = new WeakSet(), mh = /* @__PURE__ */ d(function(t = null) {
  let e = r(this, Qi).get(t || (t = ""));
  if (!e) {
    const s = document.createElement("canvas");
    s.className = "hiddenCanvasElement", s.lang = t, document.body.append(s), e = s.getContext("2d", {
      alpha: !1,
      willReadFrequently: !0
    }), r(this, Qi).set(t, e);
  }
  return e;
}, "#getCtx"), bg = /* @__PURE__ */ d(function() {
  if (r(this, ni) !== null)
    return;
  const t = document.createElement("div");
  t.style.opacity = 0, t.style.lineHeight = 1, t.style.fontSize = "1px", t.style.position = "absolute", t.textContent = "X", document.body.append(t), g(this, ni, t.getBoundingClientRect().height), t.remove();
}, "#ensureMinFontSizeComputed"), Ag = /* @__PURE__ */ d(function(t, e) {
  const s = r(this, Ki).get(t);
  if (s)
    return s;
  const i = m(this, ns, mh).call(this, e), n = i.font;
  i.canvas.width = i.canvas.height = Kt, i.font = `${Kt}px ${t}`;
  const a = i.measureText("");
  let o = a.fontBoundingBoxAscent, h = Math.abs(a.fontBoundingBoxDescent);
  if (o) {
    const u = o / (o + h);
    return r(this, Ki).set(t, u), i.canvas.width = i.canvas.height = 0, i.font = n, u;
  }
  i.strokeStyle = "red", i.clearRect(0, 0, Kt, Kt), i.strokeText("g", 0, 0);
  let l = i.getImageData(0, 0, Kt, Kt).data;
  h = 0;
  for (let u = l.length - 1 - 3; u >= 0; u -= 4)
    if (l[u] > 0) {
      h = Math.ceil(u / 4 / Kt);
      break;
    }
  i.clearRect(0, 0, Kt, Kt), i.strokeText("A", 0, Kt), l = i.getImageData(0, 0, Kt, Kt).data, o = 0;
  for (let u = 0, p = l.length; u < p; u += 4)
    if (l[u] > 0) {
      o = Kt - Math.floor(u / 4 / Kt);
      break;
    }
  i.canvas.width = i.canvas.height = 0, i.font = n;
  const c = o ? o / (o + h) : jm;
  return r(this, Ki).set(t, c), c;
}, "#getAscent"), A(Rt, ns), d(Rt, "TextLayer"), A(Rt, Ki, /* @__PURE__ */ new Map()), A(Rt, Qi, /* @__PURE__ */ new Map()), A(Rt, ni, null), A(Rt, hr, /* @__PURE__ */ new Set());
let pa = Rt;
const Il = class Il {
  static textContent(t) {
    const e = [], s = {
      items: e,
      styles: /* @__PURE__ */ Object.create(null)
    };
    function i(n) {
      var h;
      if (!n)
        return;
      let a = null;
      const o = n.name;
      if (o === "#text")
        a = n.value;
      else if (Il.shouldBuildText(o))
        (h = n == null ? void 0 : n.attributes) != null && h.textContent ? a = n.attributes.textContent : n.value && (a = n.value);
      else return;
      if (a !== null && e.push({
        str: a
      }), !!n.children)
        for (const l of n.children)
          i(l);
    }
    return d(i, "walk"), i(t), s;
  }
  static shouldBuildText(t) {
    return !(t === "textarea" || t === "input" || t === "option" || t === "select");
  }
};
d(Il, "XfaText");
let ga = Il;
const Wm = 65536, Vm = 100, Gm = 5e3, qm = $t ? Hc : lc, Xm = $t ? Bc : Uh, Ym = $t ? Oc : ac, Km = $t ? Uc : zh;
function Qm(f = {}) {
  typeof f == "string" || f instanceof URL ? f = {
    url: f
  } : (f instanceof ArrayBuffer || ArrayBuffer.isView(f)) && (f = {
    data: f
  });
  const t = new pd(), {
    docId: e
  } = t, s = f.url ? Jm(f.url) : null, i = f.data ? Zm(f.data) : null, n = f.httpHeaders || null, a = f.withCredentials === !0, o = f.password ?? null, h = f.range instanceof Zh ? f.range : null, l = Number.isInteger(f.rangeChunkSize) && f.rangeChunkSize > 0 ? f.rangeChunkSize : Wm;
  let c = f.worker instanceof zn ? f.worker : null;
  const u = f.verbosity, p = typeof f.docBaseUrl == "string" && !Gl(f.docBaseUrl) ? f.docBaseUrl : null, b = typeof f.cMapUrl == "string" ? f.cMapUrl : null, v = f.cMapPacked !== !1, y = f.CMapReaderFactory || Xm, _ = typeof f.standardFontDataUrl == "string" ? f.standardFontDataUrl : null, w = f.StandardFontDataFactory || Km, E = f.stopAtErrors !== !0, S = Number.isInteger(f.maxImageSize) && f.maxImageSize > -1 ? f.maxImageSize : -1, C = f.isEvalSupported !== !1, T = typeof f.isOffscreenCanvasSupported == "boolean" ? f.isOffscreenCanvasSupported : !$t, x = Number.isInteger(f.canvasMaxAreaInBytes) ? f.canvasMaxAreaInBytes : -1, k = typeof f.disableFontFace == "boolean" ? f.disableFontFace : $t, P = f.fontExtraProperties === !0, O = f.enableXfa === !0, q = f.ownerDocument || globalThis.document, F = f.disableRange === !0, ht = f.disableStream === !0, rt = f.disableAutoFetch === !0, at = f.pdfBug === !0, lt = f.enableHWA === !0, Ft = h ? h.length : f.length ?? NaN, H = typeof f.useSystemFonts == "boolean" ? f.useSystemFonts : !$t && !k, z = typeof f.useWorkerFetch == "boolean" ? f.useWorkerFetch : y === Uh && w === zh && b && _ && jr(b, document.baseURI) && jr(_, document.baseURI), th = f.canvasFactory || new qm({
    ownerDocument: q,
    enableHWA: lt
  }), eh = f.filterFactory || new Ym({
    docId: e,
    ownerDocument: q
  }), sh = null;
  gm(u);
  const Wt = {
    canvasFactory: th,
    filterFactory: eh
  };
  if (z || (Wt.cMapReaderFactory = new y({
    baseUrl: b,
    isCompressed: v
  }), Wt.standardFontDataFactory = new w({
    baseUrl: _
  })), !c) {
    const wi = {
      verbosity: u,
      port: Ds.workerPort
    };
    c = wi.port ? zn.fromPort(wi) : new zn(wi), t._worker = c;
  }
  const Lt = {
    docId: e,
    apiVersion: "4.5.136",
    data: i,
    password: o,
    disableAutoFetch: rt,
    rangeChunkSize: l,
    length: Ft,
    docBaseUrl: p,
    enableXfa: O,
    evaluatorOptions: {
      maxImageSize: S,
      disableFontFace: k,
      ignoreErrors: E,
      isEvalSupported: C,
      isOffscreenCanvasSupported: T,
      canvasMaxAreaInBytes: x,
      fontExtraProperties: P,
      useSystemFonts: H,
      cMapUrl: z ? b : null,
      standardFontDataUrl: z ? _ : null
    }
  }, ih = {
    disableFontFace: k,
    fontExtraProperties: P,
    ownerDocument: q,
    pdfBug: at,
    styleElement: sh,
    loadingParams: {
      disableAutoFetch: rt,
      enableXfa: O
    }
  };
  return c.promise.then(function() {
    if (t.destroyed)
      throw new Error("Loading aborted");
    if (c.destroyed)
      throw new Error("Worker was destroyed");
    const wi = c.messageHandler.sendWithPromise("GetDocRequest", Lt, i ? [i.buffer] : null);
    let js;
    if (h)
      js = new Zc(h, {
        disableRange: F,
        disableStream: ht
      });
    else if (!i) {
      if (!s)
        throw new Error("getDocument - no `url` parameter provided.");
      js = (/* @__PURE__ */ d((rs) => $t ? (/* @__PURE__ */ d(function() {
        return typeof fetch < "u" && typeof Response < "u" && "body" in Response.prototype;
      }, "isFetchSupported"))() && jr(rs.url) ? new Yh(rs) : new hd(rs) : jr(rs.url) ? new Yh(rs) : new rd(rs), "createPDFNetworkStream"))({
        url: s,
        length: Ft,
        httpHeaders: n,
        withCredentials: a,
        rangeChunkSize: l,
        disableRange: F,
        disableStream: ht
      });
    }
    return wi.then((mt) => {
      if (t.destroyed)
        throw new Error("Loading aborted");
      if (c.destroyed)
        throw new Error("Worker was destroyed");
      const rs = new xi(e, mt, c.port), pp = new Ad(rs, t, js, ih, Wt);
      t._transport = pp, rs.send("Ready", null);
    });
  }).catch(t._capability.reject), t;
}
d(Qm, "getDocument");
function Jm(f) {
  if (f instanceof URL)
    return f.href;
  try {
    return new URL(f, window.location).href;
  } catch {
    if ($t && typeof f == "string")
      return f;
  }
  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
}
d(Jm, "getUrlProp");
function Zm(f) {
  if ($t && typeof Buffer < "u" && f instanceof Buffer)
    throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
  if (f instanceof Uint8Array && f.byteLength === f.buffer.byteLength)
    return f;
  if (typeof f == "string")
    return Wl(f);
  if (f instanceof ArrayBuffer || ArrayBuffer.isView(f) || typeof f == "object" && !isNaN(f == null ? void 0 : f.length))
    return new Uint8Array(f);
  throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
}
d(Zm, "getDataProp");
function Rp(f) {
  return typeof f == "object" && Number.isInteger(f == null ? void 0 : f.num) && f.num >= 0 && Number.isInteger(f == null ? void 0 : f.gen) && f.gen >= 0;
}
d(Rp, "isRefProxy");
var Pl;
const aa = class aa {
  constructor() {
    this._capability = Promise.withResolvers(), this._transport = null, this._worker = null, this.docId = `d${se(aa, Pl)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
  }
  get promise() {
    return this._capability.promise;
  }
  async destroy() {
    var t, e, s;
    this.destroyed = !0;
    try {
      (t = this._worker) != null && t.port && (this._worker._pendingDestroy = !0), await ((e = this._transport) == null ? void 0 : e.destroy());
    } catch (i) {
      throw (s = this._worker) != null && s.port && delete this._worker._pendingDestroy, i;
    }
    this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
  }
};
Pl = new WeakMap(), d(aa, "PDFDocumentLoadingTask"), A(aa, Pl, 0);
let pd = aa;
const Lf = class Lf {
  constructor(t, e, s = !1, i = null) {
    this.length = t, this.initialData = e, this.progressiveDone = s, this.contentDispositionFilename = i, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = Promise.withResolvers();
  }
  addRangeListener(t) {
    this._rangeListeners.push(t);
  }
  addProgressListener(t) {
    this._progressListeners.push(t);
  }
  addProgressiveReadListener(t) {
    this._progressiveReadListeners.push(t);
  }
  addProgressiveDoneListener(t) {
    this._progressiveDoneListeners.push(t);
  }
  onDataRange(t, e) {
    for (const s of this._rangeListeners)
      s(t, e);
  }
  onDataProgress(t, e) {
    this._readyCapability.promise.then(() => {
      for (const s of this._progressListeners)
        s(t, e);
    });
  }
  onDataProgressiveRead(t) {
    this._readyCapability.promise.then(() => {
      for (const e of this._progressiveReadListeners)
        e(t);
    });
  }
  onDataProgressiveDone() {
    this._readyCapability.promise.then(() => {
      for (const t of this._progressiveDoneListeners)
        t();
    });
  }
  transportReady() {
    this._readyCapability.resolve();
  }
  requestDataRange(t, e) {
    et("Abstract method PDFDataRangeTransport.requestDataRange");
  }
  abort() {
  }
};
d(Lf, "PDFDataRangeTransport");
let Zh = Lf;
const Rf = class Rf {
  constructor(t, e) {
    this._pdfInfo = t, this._transport = e;
  }
  get annotationStorage() {
    return this._transport.annotationStorage;
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get numPages() {
    return this._pdfInfo.numPages;
  }
  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }
  get isPureXfa() {
    return X(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }
  getPage(t) {
    return this._transport.getPage(t);
  }
  getPageIndex(t) {
    return this._transport.getPageIndex(t);
  }
  getDestinations() {
    return this._transport.getDestinations();
  }
  getDestination(t) {
    return this._transport.getDestination(t);
  }
  getPageLabels() {
    return this._transport.getPageLabels();
  }
  getPageLayout() {
    return this._transport.getPageLayout();
  }
  getPageMode() {
    return this._transport.getPageMode();
  }
  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }
  getOpenAction() {
    return this._transport.getOpenAction();
  }
  getAttachments() {
    return this._transport.getAttachments();
  }
  getJSActions() {
    return this._transport.getDocJSActions();
  }
  getOutline() {
    return this._transport.getOutline();
  }
  getOptionalContentConfig({
    intent: t = "display"
  } = {}) {
    const {
      renderingIntent: e
    } = this._transport.getRenderingIntent(t);
    return this._transport.getOptionalContentConfig(e);
  }
  getPermissions() {
    return this._transport.getPermissions();
  }
  getMetadata() {
    return this._transport.getMetadata();
  }
  getMarkInfo() {
    return this._transport.getMarkInfo();
  }
  getData() {
    return this._transport.getData();
  }
  saveDocument() {
    return this._transport.saveDocument();
  }
  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }
  cleanup(t = !1) {
    return this._transport.startCleanup(t || this.isPureXfa);
  }
  destroy() {
    return this.loadingTask.destroy();
  }
  cachedPageNumber(t) {
    return this._transport.cachedPageNumber(t);
  }
  get loadingParams() {
    return this._transport.loadingParams;
  }
  get loadingTask() {
    return this._transport.loadingTask;
  }
  getFieldObjects() {
    return this._transport.getFieldObjects();
  }
  hasJSActions() {
    return this._transport.hasJSActions();
  }
  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }
};
d(Rf, "PDFDocumentProxy");
let gd = Rf;
var ri, vs, ye, Nn, bh;
const kf = class kf {
  constructor(t, e, s, i = !1) {
    A(this, ye);
    A(this, ri, null);
    A(this, vs, !1);
    this._pageIndex = t, this._pageInfo = e, this._transport = s, this._stats = i ? new $h() : null, this._pdfBug = i, this.commonObjs = s.commonObjs, this.objs = new tl(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
  }
  get pageNumber() {
    return this._pageIndex + 1;
  }
  get rotate() {
    return this._pageInfo.rotate;
  }
  get ref() {
    return this._pageInfo.ref;
  }
  get userUnit() {
    return this._pageInfo.userUnit;
  }
  get view() {
    return this._pageInfo.view;
  }
  getViewport({
    scale: t,
    rotation: e = this.rotate,
    offsetX: s = 0,
    offsetY: i = 0,
    dontFlip: n = !1
  } = {}) {
    return new ca({
      viewBox: this.view,
      scale: t,
      rotation: e,
      offsetX: s,
      offsetY: i,
      dontFlip: n
    });
  }
  getAnnotations({
    intent: t = "display"
  } = {}) {
    const {
      renderingIntent: e
    } = this._transport.getRenderingIntent(t);
    return this._transport.getAnnotations(this._pageIndex, e);
  }
  getJSActions() {
    return this._transport.getPageJSActions(this._pageIndex);
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get isPureXfa() {
    return X(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  async getXfa() {
    var t;
    return ((t = this._transport._htmlForXfa) == null ? void 0 : t.children[this._pageIndex]) || null;
  }
  render({
    canvasContext: t,
    viewport: e,
    intent: s = "display",
    annotationMode: i = Ys.ENABLE,
    transform: n = null,
    background: a = null,
    optionalContentConfigPromise: o = null,
    annotationCanvasMap: h = null,
    pageColors: l = null,
    printAnnotationStorage: c = null,
    isEditing: u = !1
  }) {
    var C, T;
    (C = this._stats) == null || C.time("Overall");
    const p = this._transport.getRenderingIntent(s, i, c, u), {
      renderingIntent: b,
      cacheKey: v
    } = p;
    g(this, vs, !1), m(this, ye, bh).call(this), o || (o = this._transport.getOptionalContentConfig(b));
    let y = this._intentStates.get(v);
    y || (y = /* @__PURE__ */ Object.create(null), this._intentStates.set(v, y)), y.streamReaderCancelTimeout && (clearTimeout(y.streamReaderCancelTimeout), y.streamReaderCancelTimeout = null);
    const _ = !!(b & ue.PRINT);
    y.displayReadyCapability || (y.displayReadyCapability = Promise.withResolvers(), y.operatorList = {
      fnArray: [],
      argsArray: [],
      lastChunk: !1,
      separateAnnots: null
    }, (T = this._stats) == null || T.time("Page Request"), this._pumpOperatorList(p));
    const w = /* @__PURE__ */ d((x) => {
      var k;
      y.renderTasks.delete(E), (this._maybeCleanupAfterRender || _) && g(this, vs, !0), m(this, ye, Nn).call(this, !_), x ? (E.capability.reject(x), this._abortOperatorList({
        intentState: y,
        reason: x instanceof Error ? x : new Error(x)
      })) : E.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"), (k = globalThis.Stats) != null && k.enabled && globalThis.Stats.add(this.pageNumber, this._stats));
    }, "complete"), E = new wd({
      callback: w,
      params: {
        canvasContext: t,
        viewport: e,
        transform: n,
        background: a
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap: h,
      operatorList: y.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: this._transport.canvasFactory,
      filterFactory: this._transport.filterFactory,
      useRequestAnimationFrame: !_,
      pdfBug: this._pdfBug,
      pageColors: l
    });
    (y.renderTasks || (y.renderTasks = /* @__PURE__ */ new Set())).add(E);
    const S = E.task;
    return Promise.all([y.displayReadyCapability.promise, o]).then(([x, k]) => {
      var P;
      if (this.destroyed) {
        w();
        return;
      }
      if ((P = this._stats) == null || P.time("Rendering"), !(k.renderingIntent & b))
        throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
      E.initializeGraphics({
        transparency: x,
        optionalContentConfig: k
      }), E.operatorListChanged();
    }).catch(w), S;
  }
  getOperatorList({
    intent: t = "display",
    annotationMode: e = Ys.ENABLE,
    printAnnotationStorage: s = null,
    isEditing: i = !1
  } = {}) {
    var l;
    function n() {
      o.operatorList.lastChunk && (o.opListReadCapability.resolve(o.operatorList), o.renderTasks.delete(h));
    }
    d(n, "operatorListChanged");
    const a = this._transport.getRenderingIntent(t, e, s, i, !0);
    let o = this._intentStates.get(a.cacheKey);
    o || (o = /* @__PURE__ */ Object.create(null), this._intentStates.set(a.cacheKey, o));
    let h;
    return o.opListReadCapability || (h = /* @__PURE__ */ Object.create(null), h.operatorListChanged = n, o.opListReadCapability = Promise.withResolvers(), (o.renderTasks || (o.renderTasks = /* @__PURE__ */ new Set())).add(h), o.operatorList = {
      fnArray: [],
      argsArray: [],
      lastChunk: !1,
      separateAnnots: null
    }, (l = this._stats) == null || l.time("Page Request"), this._pumpOperatorList(a)), o.opListReadCapability.promise;
  }
  streamTextContent({
    includeMarkedContent: t = !1,
    disableNormalization: e = !1
  } = {}) {
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      includeMarkedContent: t === !0,
      disableNormalization: e === !0
    }, {
      highWaterMark: 100,
      size(i) {
        return i.items.length;
      }
    });
  }
  getTextContent(t = {}) {
    if (this._transport._htmlForXfa)
      return this.getXfa().then((s) => ga.textContent(s));
    const e = this.streamTextContent(t);
    return new Promise(function(s, i) {
      function n() {
        a.read().then(function({
          value: h,
          done: l
        }) {
          if (l) {
            s(o);
            return;
          }
          o.lang ?? (o.lang = h.lang), Object.assign(o.styles, h.styles), o.items.push(...h.items), n();
        }, i);
      }
      d(n, "pump");
      const a = e.getReader(), o = {
        items: [],
        styles: /* @__PURE__ */ Object.create(null),
        lang: null
      };
      n();
    });
  }
  getStructTree() {
    return this._transport.getStructTree(this._pageIndex);
  }
  _destroy() {
    this.destroyed = !0;
    const t = [];
    for (const e of this._intentStates.values())
      if (this._abortOperatorList({
        intentState: e,
        reason: new Error("Page was destroyed."),
        force: !0
      }), !e.opListReadCapability)
        for (const s of e.renderTasks)
          t.push(s.completed), s.cancel();
    return this.objs.clear(), g(this, vs, !1), m(this, ye, bh).call(this), Promise.all(t);
  }
  cleanup(t = !1) {
    g(this, vs, !0);
    const e = m(this, ye, Nn).call(this, !1);
    return t && e && this._stats && (this._stats = new $h()), e;
  }
  _startRenderPage(t, e) {
    var i, n;
    const s = this._intentStates.get(e);
    s && ((i = this._stats) == null || i.timeEnd("Page Request"), (n = s.displayReadyCapability) == null || n.resolve(t));
  }
  _renderPageChunk(t, e) {
    for (let s = 0, i = t.length; s < i; s++)
      e.operatorList.fnArray.push(t.fnArray[s]), e.operatorList.argsArray.push(t.argsArray[s]);
    e.operatorList.lastChunk = t.lastChunk, e.operatorList.separateAnnots = t.separateAnnots;
    for (const s of e.renderTasks)
      s.operatorListChanged();
    t.lastChunk && m(this, ye, Nn).call(this, !0);
  }
  _pumpOperatorList({
    renderingIntent: t,
    cacheKey: e,
    annotationStorageSerializable: s,
    modifiedIds: i
  }) {
    const {
      map: n,
      transfer: a
    } = s, h = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: t,
      cacheKey: e,
      annotationStorage: n,
      modifiedIds: i
    }, a).getReader(), l = this._intentStates.get(e);
    l.streamReader = h;
    const c = /* @__PURE__ */ d(() => {
      h.read().then(({
        value: u,
        done: p
      }) => {
        if (p) {
          l.streamReader = null;
          return;
        }
        this._transport.destroyed || (this._renderPageChunk(u, l), c());
      }, (u) => {
        if (l.streamReader = null, !this._transport.destroyed) {
          if (l.operatorList) {
            l.operatorList.lastChunk = !0;
            for (const p of l.renderTasks)
              p.operatorListChanged();
            m(this, ye, Nn).call(this, !0);
          }
          if (l.displayReadyCapability)
            l.displayReadyCapability.reject(u);
          else if (l.opListReadCapability)
            l.opListReadCapability.reject(u);
          else
            throw u;
        }
      });
    }, "pump");
    c();
  }
  _abortOperatorList({
    intentState: t,
    reason: e,
    force: s = !1
  }) {
    if (t.streamReader) {
      if (t.streamReaderCancelTimeout && (clearTimeout(t.streamReaderCancelTimeout), t.streamReaderCancelTimeout = null), !s) {
        if (t.renderTasks.size > 0)
          return;
        if (e instanceof da) {
          let i = Vm;
          e.extraDelay > 0 && e.extraDelay < 1e3 && (i += e.extraDelay), t.streamReaderCancelTimeout = setTimeout(() => {
            t.streamReaderCancelTimeout = null, this._abortOperatorList({
              intentState: t,
              reason: e,
              force: !0
            });
          }, i);
          return;
        }
      }
      if (t.streamReader.cancel(new Bs(e.message)).catch(() => {
      }), t.streamReader = null, !this._transport.destroyed) {
        for (const [i, n] of this._intentStates)
          if (n === t) {
            this._intentStates.delete(i);
            break;
          }
        this.cleanup();
      }
    }
  }
  get stats() {
    return this._stats;
  }
};
ri = new WeakMap(), vs = new WeakMap(), ye = new WeakSet(), Nn = /* @__PURE__ */ d(function(t = !1) {
  if (m(this, ye, bh).call(this), !r(this, vs) || this.destroyed)
    return !1;
  if (t)
    return g(this, ri, setTimeout(() => {
      g(this, ri, null), m(this, ye, Nn).call(this, !1);
    }, Gm)), !1;
  for (const {
    renderTasks: e,
    operatorList: s
  } of this._intentStates.values())
    if (e.size > 0 || !s.lastChunk)
      return !1;
  return this._intentStates.clear(), this.objs.clear(), g(this, vs, !1), !0;
}, "#tryCleanup"), bh = /* @__PURE__ */ d(function() {
  r(this, ri) && (clearTimeout(r(this, ri)), g(this, ri, null));
}, "#abortDelayedCleanup"), d(kf, "PDFPageProxy");
let md = kf;
var Ji, Dl;
const Mf = class Mf {
  constructor() {
    A(this, Ji, /* @__PURE__ */ new Set());
    A(this, Dl, Promise.resolve());
  }
  postMessage(t, e) {
    const s = {
      data: structuredClone(t, e ? {
        transfer: e
      } : null)
    };
    r(this, Dl).then(() => {
      for (const i of r(this, Ji))
        i.call(this, s);
    });
  }
  addEventListener(t, e) {
    r(this, Ji).add(e);
  }
  removeEventListener(t, e) {
    r(this, Ji).delete(e);
  }
  terminate() {
    r(this, Ji).clear();
  }
};
Ji = new WeakMap(), Dl = new WeakMap(), d(Mf, "LoopbackPort");
let bd = Mf;
const ls = {
  isWorkerDisabled: !1,
  fakeWorkerId: 0
};
$t && (ls.isWorkerDisabled = !0, Ds.workerSrc || (Ds.workerSrc = "./pdf.worker.mjs")), ls.isSameOrigin = function(f, t) {
  let e;
  try {
    if (e = new URL(f), !e.origin || e.origin === "null")
      return !1;
  } catch {
    return !1;
  }
  const s = new URL(t, e);
  return e.origin === s.origin;
}, ls.createCDNWrapper = function(f) {
  const t = `await import("${f}");`;
  return URL.createObjectURL(new Blob([t], {
    type: "text/javascript"
  }));
};
var Zi, lr, Ah, cr, vh;
const Qt = class Qt {
  constructor({
    name: t = null,
    port: e = null,
    verbosity: s = mm()
  } = {}) {
    A(this, lr);
    var i;
    if (this.name = t, this.destroyed = !1, this.verbosity = s, this._readyCapability = Promise.withResolvers(), this._port = null, this._webWorker = null, this._messageHandler = null, e) {
      if ((i = r(Qt, Zi)) != null && i.has(e))
        throw new Error("Cannot use more than one PDFWorker per port.");
      (r(Qt, Zi) || g(Qt, Zi, /* @__PURE__ */ new WeakMap())).set(e, this), this._initializeFromPort(e);
      return;
    }
    this._initialize();
  }
  get promise() {
    return $t ? Promise.all([_e.promise, this._readyCapability.promise]) : this._readyCapability.promise;
  }
  get port() {
    return this._port;
  }
  get messageHandler() {
    return this._messageHandler;
  }
  _initializeFromPort(t) {
    this._port = t, this._messageHandler = new xi("main", "worker", t), this._messageHandler.on("ready", function() {
    }), m(this, lr, Ah).call(this);
  }
  _initialize() {
    if (ls.isWorkerDisabled || r(Qt, cr, vh)) {
      this._setupFakeWorker();
      return;
    }
    let {
      workerSrc: t
    } = Qt;
    try {
      ls.isSameOrigin(window.location.href, t) || (t = ls.createCDNWrapper(new URL(t, window.location).href));
      const e = new Worker(t, {
        type: "module"
      }), s = new xi("main", "worker", e), i = /* @__PURE__ */ d(() => {
        n.abort(), s.destroy(), e.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
      }, "terminateEarly"), n = new AbortController();
      e.addEventListener("error", () => {
        this._webWorker || i();
      }, {
        signal: n.signal
      }), s.on("test", (o) => {
        if (n.abort(), this.destroyed || !o) {
          i();
          return;
        }
        this._messageHandler = s, this._port = e, this._webWorker = e, m(this, lr, Ah).call(this);
      }), s.on("ready", (o) => {
        if (n.abort(), this.destroyed) {
          i();
          return;
        }
        try {
          a();
        } catch {
          this._setupFakeWorker();
        }
      });
      const a = /* @__PURE__ */ d(() => {
        const o = new Uint8Array();
        s.send("test", o, [o.buffer]);
      }, "sendTest");
      a();
      return;
    } catch {
      jl("The worker has been disabled.");
    }
    this._setupFakeWorker();
  }
  _setupFakeWorker() {
    ls.isWorkerDisabled || ($("Setting up fake worker."), ls.isWorkerDisabled = !0), Qt._setupFakeWorkerGlobal.then((t) => {
      if (this.destroyed) {
        this._readyCapability.reject(new Error("Worker was destroyed"));
        return;
      }
      const e = new bd();
      this._port = e;
      const s = `fake${ls.fakeWorkerId++}`, i = new xi(s + "_worker", s, e);
      t.setup(i, e), this._messageHandler = new xi(s, s + "_worker", e), m(this, lr, Ah).call(this);
    }).catch((t) => {
      this._readyCapability.reject(new Error(`Setting up fake worker failed: "${t.message}".`));
    });
  }
  destroy() {
    var t;
    this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (t = r(Qt, Zi)) == null || t.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
  }
  static fromPort(t) {
    var s;
    if (!(t != null && t.port))
      throw new Error("PDFWorker.fromPort - invalid method signature.");
    const e = (s = r(this, Zi)) == null ? void 0 : s.get(t.port);
    if (e) {
      if (e._pendingDestroy)
        throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
      return e;
    }
    return new Qt(t);
  }
  static get workerSrc() {
    if (Ds.workerSrc)
      return Ds.workerSrc;
    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }
  static get _setupFakeWorkerGlobal() {
    return X(this, "_setupFakeWorkerGlobal", (/* @__PURE__ */ d(async () => r(this, cr, vh) ? r(this, cr, vh) : (await import(
      /* webpackIgnore: true */
      /* @vite-ignore */
      new URL(
        /*webpackIgnore: true*/
        this.workerSrc,
        typeof WEAVY_IMPORT_URL == "string" && (!import.meta.url || !new URL(import.meta.url).href.startsWith(WEAVY_IMPORT_URL)) ? WEAVY_IMPORT_URL : import.meta.url
      ).href
    )).WorkerMessageHandler, "loader"))());
  }
};
Zi = new WeakMap(), lr = new WeakSet(), Ah = /* @__PURE__ */ d(function() {
  this._readyCapability.resolve(), this._messageHandler.send("configure", {
    verbosity: this.verbosity
  });
}, "#resolve"), cr = new WeakSet(), vh = /* @__PURE__ */ d(function() {
  var t;
  try {
    return ((t = globalThis.pdfjsWorker) == null ? void 0 : t.WorkerMessageHandler) || null;
  } catch {
    return null;
  }
}, "#mainThreadWorkerMessageHandler"), A(Qt, cr), d(Qt, "PDFWorker"), A(Qt, Zi);
let zn = Qt;
var ys, qe, dr, ur, Xe, tn, Gr;
const If = class If {
  constructor(t, e, s, i, n) {
    A(this, tn);
    A(this, ys, /* @__PURE__ */ new Map());
    A(this, qe, /* @__PURE__ */ new Map());
    A(this, dr, /* @__PURE__ */ new Map());
    A(this, ur, /* @__PURE__ */ new Map());
    A(this, Xe, null);
    this.messageHandler = t, this.loadingTask = e, this.commonObjs = new tl(), this.fontLoader = new Dc({
      ownerDocument: i.ownerDocument,
      styleElement: i.styleElement
    }), this.loadingParams = i.loadingParams, this._params = i, this.canvasFactory = n.canvasFactory, this.filterFactory = n.filterFactory, this.cMapReaderFactory = n.cMapReaderFactory, this.standardFontDataFactory = n.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = s, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = Promise.withResolvers(), this.setupMessageHandler();
  }
  get annotationStorage() {
    return X(this, "annotationStorage", new ua());
  }
  getRenderingIntent(t, e = Ys.ENABLE, s = null, i = !1, n = !1) {
    let a = ue.DISPLAY, o = Pc;
    switch (t) {
      case "any":
        a = ue.ANY;
        break;
      case "display":
        break;
      case "print":
        a = ue.PRINT;
        break;
      default:
        $(`getRenderingIntent - invalid intent: ${t}`);
    }
    const h = a & ue.PRINT && s instanceof qh ? s : this.annotationStorage;
    switch (e) {
      case Ys.DISABLE:
        a += ue.ANNOTATIONS_DISABLE;
        break;
      case Ys.ENABLE:
        break;
      case Ys.ENABLE_FORMS:
        a += ue.ANNOTATIONS_FORMS;
        break;
      case Ys.ENABLE_STORAGE:
        a += ue.ANNOTATIONS_STORAGE, o = h.serializable;
        break;
      default:
        $(`getRenderingIntent - invalid annotationMode: ${e}`);
    }
    i && (a += ue.IS_EDITING), n && (a += ue.OPLIST);
    const {
      ids: l,
      hash: c
    } = h.modifiedIds, u = [a, o.hash, c];
    return {
      renderingIntent: a,
      cacheKey: u.join("_"),
      annotationStorageSerializable: o,
      modifiedIds: l
    };
  }
  destroy() {
    var s;
    if (this.destroyCapability)
      return this.destroyCapability.promise;
    this.destroyed = !0, this.destroyCapability = Promise.withResolvers(), (s = r(this, Xe)) == null || s.reject(new Error("Worker was destroyed during onPassword callback"));
    const t = [];
    for (const i of r(this, qe).values())
      t.push(i._destroy());
    r(this, qe).clear(), r(this, dr).clear(), r(this, ur).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
    const e = this.messageHandler.sendWithPromise("Terminate", null);
    return t.push(e), Promise.all(t).then(() => {
      var i;
      this.commonObjs.clear(), this.fontLoader.clear(), r(this, ys).clear(), this.filterFactory.destroy(), pa.cleanup(), (i = this._networkStream) == null || i.cancelAllRequests(new Bs("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
    }, this.destroyCapability.reject), this.destroyCapability.promise;
  }
  setupMessageHandler() {
    const {
      messageHandler: t,
      loadingTask: e
    } = this;
    t.on("GetReader", (s, i) => {
      _t(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (n) => {
        this._lastProgress = {
          loaded: n.loaded,
          total: n.total
        };
      }, i.onPull = () => {
        this._fullReader.read().then(function({
          value: n,
          done: a
        }) {
          if (a) {
            i.close();
            return;
          }
          _t(n instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), i.enqueue(new Uint8Array(n), 1, [n]);
        }).catch((n) => {
          i.error(n);
        });
      }, i.onCancel = (n) => {
        this._fullReader.cancel(n), i.ready.catch((a) => {
          if (!this.destroyed)
            throw a;
        });
      };
    }), t.on("ReaderHeadersReady", (s) => {
      const i = Promise.withResolvers(), n = this._fullReader;
      return n.headersReady.then(() => {
        var a;
        (!n.isStreamingSupported || !n.isRangeSupported) && (this._lastProgress && ((a = e.onProgress) == null || a.call(e, this._lastProgress)), n.onProgress = (o) => {
          var h;
          (h = e.onProgress) == null || h.call(e, {
            loaded: o.loaded,
            total: o.total
          });
        }), i.resolve({
          isStreamingSupported: n.isStreamingSupported,
          isRangeSupported: n.isRangeSupported,
          contentLength: n.contentLength
        });
      }, i.reject), i.promise;
    }), t.on("GetRangeReader", (s, i) => {
      _t(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
      const n = this._networkStream.getRangeReader(s.begin, s.end);
      if (!n) {
        i.close();
        return;
      }
      i.onPull = () => {
        n.read().then(function({
          value: a,
          done: o
        }) {
          if (o) {
            i.close();
            return;
          }
          _t(a instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), i.enqueue(new Uint8Array(a), 1, [a]);
        }).catch((a) => {
          i.error(a);
        });
      }, i.onCancel = (a) => {
        n.cancel(a), i.ready.catch((o) => {
          if (!this.destroyed)
            throw o;
        });
      };
    }), t.on("GetDoc", ({
      pdfInfo: s
    }) => {
      this._numPages = s.numPages, this._htmlForXfa = s.htmlForXfa, delete s.htmlForXfa, e._capability.resolve(new gd(s, this));
    }), t.on("DocException", function(s) {
      let i;
      switch (s.name) {
        case "PasswordException":
          i = new oa(s.message, s.code);
          break;
        case "InvalidPDFException":
          i = new Fh(s.message);
          break;
        case "MissingPDFException":
          i = new Hs(s.message);
          break;
        case "UnexpectedResponseException":
          i = new Nr(s.message, s.status);
          break;
        case "UnknownErrorException":
          i = new ha(s.message, s.details);
          break;
        default:
          et("DocException - expected a valid Error.");
      }
      e._capability.reject(i);
    }), t.on("PasswordRequest", (s) => {
      if (g(this, Xe, Promise.withResolvers()), e.onPassword) {
        const i = /* @__PURE__ */ d((n) => {
          n instanceof Error ? r(this, Xe).reject(n) : r(this, Xe).resolve({
            password: n
          });
        }, "updatePassword");
        try {
          e.onPassword(i, s.code);
        } catch (n) {
          r(this, Xe).reject(n);
        }
      } else
        r(this, Xe).reject(new oa(s.message, s.code));
      return r(this, Xe).promise;
    }), t.on("DataLoaded", (s) => {
      var i;
      (i = e.onProgress) == null || i.call(e, {
        loaded: s.length,
        total: s.length
      }), this.downloadInfoCapability.resolve(s);
    }), t.on("StartRenderPage", (s) => {
      if (this.destroyed)
        return;
      r(this, qe).get(s.pageIndex)._startRenderPage(s.transparency, s.cacheKey);
    }), t.on("commonobj", ([s, i, n]) => {
      var a;
      if (this.destroyed || this.commonObjs.has(s))
        return null;
      switch (i) {
        case "Font":
          const {
            disableFontFace: o,
            fontExtraProperties: h,
            pdfBug: l
          } = this._params;
          if ("error" in n) {
            const b = n.error;
            $(`Error during font loading: ${b}`), this.commonObjs.resolve(s, b);
            break;
          }
          const c = l && ((a = globalThis.FontInspector) != null && a.enabled) ? (b, v) => globalThis.FontInspector.fontAdded(b, v) : null, u = new Fc(n, {
            disableFontFace: o,
            inspectFont: c
          });
          this.fontLoader.bind(u).catch(() => t.sendWithPromise("FontFallback", {
            id: s
          })).finally(() => {
            !h && u.data && (u.data = null), this.commonObjs.resolve(s, u);
          });
          break;
        case "CopyLocalImage":
          const {
            imageRef: p
          } = n;
          _t(p, "The imageRef must be defined.");
          for (const b of r(this, qe).values())
            for (const [, v] of b.objs)
              if ((v == null ? void 0 : v.ref) === p)
                return v.dataLen ? (this.commonObjs.resolve(s, structuredClone(v)), v.dataLen) : null;
          break;
        case "FontPath":
        case "Image":
        case "Pattern":
          this.commonObjs.resolve(s, n);
          break;
        default:
          throw new Error(`Got unknown common object type ${i}`);
      }
      return null;
    }), t.on("obj", ([s, i, n, a]) => {
      var h;
      if (this.destroyed)
        return;
      const o = r(this, qe).get(i);
      if (!o.objs.has(s)) {
        if (o._intentStates.size === 0) {
          (h = a == null ? void 0 : a.bitmap) == null || h.close();
          return;
        }
        switch (n) {
          case "Image":
            o.objs.resolve(s, a), (a == null ? void 0 : a.dataLen) > dm && (o._maybeCleanupAfterRender = !0);
            break;
          case "Pattern":
            o.objs.resolve(s, a);
            break;
          default:
            throw new Error(`Got unknown object type ${n}`);
        }
      }
    }), t.on("DocProgress", (s) => {
      var i;
      this.destroyed || (i = e.onProgress) == null || i.call(e, {
        loaded: s.loaded,
        total: s.total
      });
    }), t.on("FetchBuiltInCMap", (s) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(s) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), t.on("FetchStandardFontData", (s) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(s) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
  }
  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }
  saveDocument() {
    var s;
    this.annotationStorage.size <= 0 && $("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
    const {
      map: t,
      transfer: e
    } = this.annotationStorage.serializable;
    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: t,
      filename: ((s = this._fullReader) == null ? void 0 : s.filename) ?? null
    }, e).finally(() => {
      this.annotationStorage.resetModified();
    });
  }
  getPage(t) {
    if (!Number.isInteger(t) || t <= 0 || t > this._numPages)
      return Promise.reject(new Error("Invalid page request."));
    const e = t - 1, s = r(this, dr).get(e);
    if (s)
      return s;
    const i = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex: e
    }).then((n) => {
      if (this.destroyed)
        throw new Error("Transport destroyed");
      n.refStr && r(this, ur).set(n.refStr, t);
      const a = new md(e, n, this, this._params.pdfBug);
      return r(this, qe).set(e, a), a;
    });
    return r(this, dr).set(e, i), i;
  }
  getPageIndex(t) {
    return Rp(t) ? this.messageHandler.sendWithPromise("GetPageIndex", {
      num: t.num,
      gen: t.gen
    }) : Promise.reject(new Error("Invalid pageIndex request."));
  }
  getAnnotations(t, e) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex: t,
      intent: e
    });
  }
  getFieldObjects() {
    return m(this, tn, Gr).call(this, "GetFieldObjects");
  }
  hasJSActions() {
    return m(this, tn, Gr).call(this, "HasJSActions");
  }
  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }
  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }
  getDestination(t) {
    return typeof t != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
      id: t
    });
  }
  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }
  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }
  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }
  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }
  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }
  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }
  getDocJSActions() {
    return m(this, tn, Gr).call(this, "GetDocJSActions");
  }
  getPageJSActions(t) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex: t
    });
  }
  getStructTree(t) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex: t
    });
  }
  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }
  getOptionalContentConfig(t) {
    return m(this, tn, Gr).call(this, "GetOptionalContentConfig").then((e) => new Qc(e, t));
  }
  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }
  getMetadata() {
    const t = "GetMetadata", e = r(this, ys).get(t);
    if (e)
      return e;
    const s = this.messageHandler.sendWithPromise(t, null).then((i) => {
      var n, a;
      return {
        info: i[0],
        metadata: i[1] ? new Yc(i[1]) : null,
        contentDispositionFilename: ((n = this._fullReader) == null ? void 0 : n.filename) ?? null,
        contentLength: ((a = this._fullReader) == null ? void 0 : a.contentLength) ?? null
      };
    });
    return r(this, ys).set(t, s), s;
  }
  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }
  async startCleanup(t = !1) {
    if (!this.destroyed) {
      await this.messageHandler.sendWithPromise("Cleanup", null);
      for (const e of r(this, qe).values())
        if (!e.cleanup())
          throw new Error(`startCleanup: Page ${e.pageNumber} is currently rendering.`);
      this.commonObjs.clear(), t || this.fontLoader.clear(), r(this, ys).clear(), this.filterFactory.destroy(!0), pa.cleanup();
    }
  }
  cachedPageNumber(t) {
    if (!Rp(t))
      return null;
    const e = t.gen === 0 ? `${t.num}R` : `${t.num}R${t.gen}`;
    return r(this, ur).get(e) ?? null;
  }
};
ys = new WeakMap(), qe = new WeakMap(), dr = new WeakMap(), ur = new WeakMap(), Xe = new WeakMap(), tn = new WeakSet(), Gr = /* @__PURE__ */ d(function(t, e = null) {
  const s = r(this, ys).get(t);
  if (s)
    return s;
  const i = this.messageHandler.sendWithPromise(t, e);
  return r(this, ys).set(t, i), i;
}, "#cacheSimpleMethod"), d(If, "WorkerTransport");
let Ad = If;
const oh = Symbol("INITIAL_DATA");
var Re, ho, vd;
const Pf = class Pf {
  constructor() {
    A(this, ho);
    A(this, Re, /* @__PURE__ */ Object.create(null));
  }
  get(t, e = null) {
    if (e) {
      const i = m(this, ho, vd).call(this, t);
      return i.promise.then(() => e(i.data)), null;
    }
    const s = r(this, Re)[t];
    if (!s || s.data === oh)
      throw new Error(`Requesting object that isn't resolved yet ${t}.`);
    return s.data;
  }
  has(t) {
    const e = r(this, Re)[t];
    return !!e && e.data !== oh;
  }
  resolve(t, e = null) {
    const s = m(this, ho, vd).call(this, t);
    s.data = e, s.resolve();
  }
  clear() {
    var t;
    for (const e in r(this, Re)) {
      const {
        data: s
      } = r(this, Re)[e];
      (t = s == null ? void 0 : s.bitmap) == null || t.close();
    }
    g(this, Re, /* @__PURE__ */ Object.create(null));
  }
  *[Symbol.iterator]() {
    for (const t in r(this, Re)) {
      const {
        data: e
      } = r(this, Re)[t];
      e !== oh && (yield [t, e]);
    }
  }
};
Re = new WeakMap(), ho = new WeakSet(), vd = /* @__PURE__ */ d(function(t) {
  var e;
  return (e = r(this, Re))[t] || (e[t] = {
    ...Promise.withResolvers(),
    data: oh
  });
}, "#ensureObj"), d(Pf, "PDFObjects");
let tl = Pf;
var ai;
const Df = class Df {
  constructor(t) {
    A(this, ai, null);
    g(this, ai, t), this.onContinue = null;
  }
  get promise() {
    return r(this, ai).capability.promise;
  }
  cancel(t = 0) {
    r(this, ai).cancel(null, t);
  }
  get separateAnnots() {
    const {
      separateAnnots: t
    } = r(this, ai).operatorList;
    if (!t)
      return !1;
    const {
      annotationCanvasMap: e
    } = r(this, ai);
    return t.form || t.canvas && (e == null ? void 0 : e.size) > 0;
  }
};
ai = new WeakMap(), d(Df, "RenderTask");
let yd = Df;
var oi, en;
const Xs = class Xs {
  constructor({
    callback: t,
    params: e,
    objs: s,
    commonObjs: i,
    annotationCanvasMap: n,
    operatorList: a,
    pageIndex: o,
    canvasFactory: h,
    filterFactory: l,
    useRequestAnimationFrame: c = !1,
    pdfBug: u = !1,
    pageColors: p = null
  }) {
    A(this, oi, null);
    this.callback = t, this.params = e, this.objs = s, this.commonObjs = i, this.annotationCanvasMap = n, this.operatorListIdx = null, this.operatorList = a, this._pageIndex = o, this.canvasFactory = h, this.filterFactory = l, this._pdfBug = u, this.pageColors = p, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = c === !0 && typeof window < "u", this.cancelled = !1, this.capability = Promise.withResolvers(), this.task = new yd(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = e.canvasContext.canvas;
  }
  get completed() {
    return this.capability.promise.catch(function() {
    });
  }
  initializeGraphics({
    transparency: t = !1,
    optionalContentConfig: e
  }) {
    var o, h;
    if (this.cancelled)
      return;
    if (this._canvas) {
      if (r(Xs, en).has(this._canvas))
        throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
      r(Xs, en).add(this._canvas);
    }
    this._pdfBug && ((o = globalThis.StepperManager) != null && o.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
    const {
      canvasContext: s,
      viewport: i,
      transform: n,
      background: a
    } = this.params;
    this.gfx = new Un(s, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
      optionalContentConfig: e
    }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
      transform: n,
      viewport: i,
      transparency: t,
      background: a
    }), this.operatorListIdx = 0, this.graphicsReady = !0, (h = this.graphicsReadyCallback) == null || h.call(this);
  }
  cancel(t = null, e = 0) {
    var s;
    this.running = !1, this.cancelled = !0, (s = this.gfx) == null || s.endDrawing(), r(this, oi) && (window.cancelAnimationFrame(r(this, oi)), g(this, oi, null)), r(Xs, en).delete(this._canvas), this.callback(t || new da(`Rendering cancelled, page ${this._pageIndex + 1}`, e));
  }
  operatorListChanged() {
    var t;
    if (!this.graphicsReady) {
      this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
      return;
    }
    (t = this.stepper) == null || t.updateOperatorList(this.operatorList), !this.running && this._continue();
  }
  _continue() {
    this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
  }
  _scheduleNext() {
    this._useRequestAnimationFrame ? g(this, oi, window.requestAnimationFrame(() => {
      g(this, oi, null), this._nextBound().catch(this._cancelBound);
    })) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
  }
  async _next() {
    this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), r(Xs, en).delete(this._canvas), this.callback())));
  }
};
oi = new WeakMap(), en = new WeakMap(), d(Xs, "InternalRenderTask"), A(Xs, en, /* @__PURE__ */ new WeakSet());
let wd = Xs;
const tb = "4.5.136", eb = "3a21f03b0";
function kp(f) {
  return Math.floor(Math.max(0, Math.min(1, f)) * 255).toString(16).padStart(2, "0");
}
d(kp, "makeColorComp");
function Br(f) {
  return Math.max(0, Math.min(255, 255 * f));
}
d(Br, "scaleAndClamp");
const Ff = class Ff {
  static CMYK_G([t, e, s, i]) {
    return ["G", 1 - Math.min(1, 0.3 * t + 0.59 * s + 0.11 * e + i)];
  }
  static G_CMYK([t]) {
    return ["CMYK", 0, 0, 0, 1 - t];
  }
  static G_RGB([t]) {
    return ["RGB", t, t, t];
  }
  static G_rgb([t]) {
    return t = Br(t), [t, t, t];
  }
  static G_HTML([t]) {
    const e = kp(t);
    return `#${e}${e}${e}`;
  }
  static RGB_G([t, e, s]) {
    return ["G", 0.3 * t + 0.59 * e + 0.11 * s];
  }
  static RGB_rgb(t) {
    return t.map(Br);
  }
  static RGB_HTML(t) {
    return `#${t.map(kp).join("")}`;
  }
  static T_HTML() {
    return "#00000000";
  }
  static T_rgb() {
    return [null];
  }
  static CMYK_RGB([t, e, s, i]) {
    return ["RGB", 1 - Math.min(1, t + i), 1 - Math.min(1, s + i), 1 - Math.min(1, e + i)];
  }
  static CMYK_rgb([t, e, s, i]) {
    return [Br(1 - Math.min(1, t + i)), Br(1 - Math.min(1, s + i)), Br(1 - Math.min(1, e + i))];
  }
  static CMYK_HTML(t) {
    const e = this.CMYK_RGB(t).slice(1);
    return this.RGB_HTML(e);
  }
  static RGB_CMYK([t, e, s]) {
    const i = 1 - t, n = 1 - e, a = 1 - s, o = Math.min(i, n, a);
    return ["CMYK", i, n, a, o];
  }
};
d(Ff, "ColorConverters");
let el = Ff;
const Nf = class Nf {
  static setupStorage(t, e, s, i, n) {
    const a = i.getValue(e, {
      value: null
    });
    switch (s.name) {
      case "textarea":
        if (a.value !== null && (t.textContent = a.value), n === "print")
          break;
        t.addEventListener("input", (o) => {
          i.setValue(e, {
            value: o.target.value
          });
        });
        break;
      case "input":
        if (s.attributes.type === "radio" || s.attributes.type === "checkbox") {
          if (a.value === s.attributes.xfaOn ? t.setAttribute("checked", !0) : a.value === s.attributes.xfaOff && t.removeAttribute("checked"), n === "print")
            break;
          t.addEventListener("change", (o) => {
            i.setValue(e, {
              value: o.target.checked ? o.target.getAttribute("xfaOn") : o.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (a.value !== null && t.setAttribute("value", a.value), n === "print")
            break;
          t.addEventListener("input", (o) => {
            i.setValue(e, {
              value: o.target.value
            });
          });
        }
        break;
      case "select":
        if (a.value !== null) {
          t.setAttribute("value", a.value);
          for (const o of s.children)
            o.attributes.value === a.value ? o.attributes.selected = !0 : o.attributes.hasOwnProperty("selected") && delete o.attributes.selected;
        }
        t.addEventListener("input", (o) => {
          const h = o.target.options, l = h.selectedIndex === -1 ? "" : h[h.selectedIndex].value;
          i.setValue(e, {
            value: l
          });
        });
        break;
    }
  }
  static setAttributes({
    html: t,
    element: e,
    storage: s = null,
    intent: i,
    linkService: n
  }) {
    const {
      attributes: a
    } = e, o = t instanceof HTMLAnchorElement;
    a.type === "radio" && (a.name = `${a.name}-${i}`);
    for (const [h, l] of Object.entries(a))
      if (l != null)
        switch (h) {
          case "class":
            l.length && t.setAttribute(h, l.join(" "));
            break;
          case "dataId":
            break;
          case "id":
            t.setAttribute("data-element-id", l);
            break;
          case "style":
            Object.assign(t.style, l);
            break;
          case "textContent":
            t.textContent = l;
            break;
          default:
            (!o || h !== "href" && h !== "newWindow") && t.setAttribute(h, l);
        }
    o && n.addLinkAttributes(t, a.href, a.newWindow), s && a.dataId && this.setupStorage(t, a.dataId, e, s);
  }
  static render(t) {
    var u, p;
    const e = t.annotationStorage, s = t.linkService, i = t.xfaHtml, n = t.intent || "display", a = document.createElement(i.name);
    i.attributes && this.setAttributes({
      html: a,
      element: i,
      intent: n,
      linkService: s
    });
    const o = n !== "richText", h = t.div;
    if (h.append(a), t.viewport) {
      const b = `matrix(${t.viewport.transform.join(",")})`;
      h.style.transform = b;
    }
    o && h.setAttribute("class", "xfaLayer xfaFont");
    const l = [];
    if (i.children.length === 0) {
      if (i.value) {
        const b = document.createTextNode(i.value);
        a.append(b), o && ga.shouldBuildText(i.name) && l.push(b);
      }
      return {
        textDivs: l
      };
    }
    const c = [[i, -1, a]];
    for (; c.length > 0; ) {
      const [b, v, y] = c.at(-1);
      if (v + 1 === b.children.length) {
        c.pop();
        continue;
      }
      const _ = b.children[++c.at(-1)[1]];
      if (_ === null)
        continue;
      const {
        name: w
      } = _;
      if (w === "#text") {
        const S = document.createTextNode(_.value);
        l.push(S), y.append(S);
        continue;
      }
      const E = (u = _ == null ? void 0 : _.attributes) != null && u.xmlns ? document.createElementNS(_.attributes.xmlns, w) : document.createElement(w);
      if (y.append(E), _.attributes && this.setAttributes({
        html: E,
        element: _,
        storage: e,
        intent: n,
        linkService: s
      }), ((p = _.children) == null ? void 0 : p.length) > 0)
        c.push([_, -1, E]);
      else if (_.value) {
        const S = document.createTextNode(_.value);
        o && ga.shouldBuildText(w) && l.push(S), E.append(S);
      }
    }
    for (const b of h.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
      b.setAttribute("readOnly", !0);
    return {
      textDivs: l
    };
  }
  static update(t) {
    const e = `matrix(${t.viewport.transform.join(",")})`;
    t.div.style.transform = e, t.div.hidden = !1;
  }
};
d(Nf, "XfaLayer");
let sl = Nf;
const Zo = 1e3, sb = 9, Rn = /* @__PURE__ */ new WeakSet();
function Fs(f) {
  return {
    width: f[2] - f[0],
    height: f[3] - f[1]
  };
}
d(Fs, "getRectDims");
const Of = class Of {
  static create(t) {
    switch (t.data.annotationType) {
      case bt.LINK:
        return new il(t);
      case bt.TEXT:
        return new Sd(t);
      case bt.WIDGET:
        switch (t.data.fieldType) {
          case "Tx":
            return new Cd(t);
          case "Btn":
            return t.data.radioButton ? new nl(t) : t.data.checkBox ? new Td(t) : new Ld(t);
          case "Ch":
            return new Rd(t);
          case "Sig":
            return new xd(t);
        }
        return new Us(t);
      case bt.POPUP:
        return new ma(t);
      case bt.FREETEXT:
        return new rl(t);
      case bt.LINE:
        return new Pd(t);
      case bt.SQUARE:
        return new Dd(t);
      case bt.CIRCLE:
        return new Fd(t);
      case bt.POLYLINE:
        return new al(t);
      case bt.CARET:
        return new Od(t);
      case bt.INK:
        return new ol(t);
      case bt.POLYGON:
        return new Nd(t);
      case bt.HIGHLIGHT:
        return new Hd(t);
      case bt.UNDERLINE:
        return new Bd(t);
      case bt.SQUIGGLY:
        return new Ud(t);
      case bt.STRIKEOUT:
        return new zd(t);
      case bt.STAMP:
        return new hl(t);
      case bt.FILEATTACHMENT:
        return new $d(t);
      default:
        return new ft(t);
    }
  }
};
d(Of, "AnnotationElementFactory");
let _d = Of;
var sn, fr, pr, lo, Ed;
const Fl = class Fl {
  constructor(t, {
    isRenderable: e = !1,
    ignoreBorder: s = !1,
    createQuadrilaterals: i = !1
  } = {}) {
    A(this, lo);
    A(this, sn, null);
    A(this, fr, !1);
    A(this, pr, null);
    this.isRenderable = e, this.data = t.data, this.layer = t.layer, this.linkService = t.linkService, this.downloadManager = t.downloadManager, this.imageResourcesPath = t.imageResourcesPath, this.renderForms = t.renderForms, this.svgFactory = t.svgFactory, this.annotationStorage = t.annotationStorage, this.enableScripting = t.enableScripting, this.hasJSActions = t.hasJSActions, this._fieldObjects = t.fieldObjects, this.parent = t.parent, e && (this.container = this._createContainer(s)), i && this._createQuadrilaterals();
  }
  static _hasPopupData({
    titleObj: t,
    contentsObj: e,
    richText: s
  }) {
    return !!(t != null && t.str || e != null && e.str || s != null && s.str);
  }
  get _isEditable() {
    return this.data.isEditable;
  }
  get hasPopupData() {
    return Fl._hasPopupData(this.data);
  }
  updateEdited(t) {
    var s;
    if (!this.container)
      return;
    r(this, sn) || g(this, sn, {
      rect: this.data.rect.slice(0)
    });
    const {
      rect: e
    } = t;
    e && m(this, lo, Ed).call(this, e), (s = r(this, pr)) == null || s.popup.updateEdited(t);
  }
  resetEdited() {
    var t;
    r(this, sn) && (m(this, lo, Ed).call(this, r(this, sn).rect), (t = r(this, pr)) == null || t.popup.resetEdited(), g(this, sn, null));
  }
  _createContainer(t) {
    const {
      data: e,
      parent: {
        page: s,
        viewport: i
      }
    } = this, n = document.createElement("section");
    n.setAttribute("data-annotation-id", e.id), this instanceof Us || (n.tabIndex = Zo);
    const {
      style: a
    } = n;
    if (a.zIndex = this.parent.zIndex++, e.popupRef && n.setAttribute("aria-haspopup", "dialog"), e.alternativeText && (n.title = e.alternativeText), e.noRotate && n.classList.add("norotate"), !e.rect || this instanceof ma) {
      const {
        rotation: y
      } = e;
      return !e.hasOwnCanvas && y !== 0 && this.setRotation(y, n), n;
    }
    const {
      width: o,
      height: h
    } = Fs(e.rect);
    if (!t && e.borderStyle.width > 0) {
      a.borderWidth = `${e.borderStyle.width}px`;
      const y = e.borderStyle.horizontalCornerRadius, _ = e.borderStyle.verticalCornerRadius;
      if (y > 0 || _ > 0) {
        const E = `calc(${y}px * var(--scale-factor)) / calc(${_}px * var(--scale-factor))`;
        a.borderRadius = E;
      } else if (this instanceof nl) {
        const E = `calc(${o}px * var(--scale-factor)) / calc(${h}px * var(--scale-factor))`;
        a.borderRadius = E;
      }
      switch (e.borderStyle.style) {
        case Or.SOLID:
          a.borderStyle = "solid";
          break;
        case Or.DASHED:
          a.borderStyle = "dashed";
          break;
        case Or.BEVELED:
          $("Unimplemented border style: beveled");
          break;
        case Or.INSET:
          $("Unimplemented border style: inset");
          break;
        case Or.UNDERLINE:
          a.borderBottomStyle = "solid";
          break;
      }
      const w = e.borderColor || null;
      w ? (g(this, fr, !0), a.borderColor = I.makeHexColor(w[0] | 0, w[1] | 0, w[2] | 0)) : a.borderWidth = 0;
    }
    const l = I.normalizeRect([e.rect[0], s.view[3] - e.rect[1] + s.view[1], e.rect[2], s.view[3] - e.rect[3] + s.view[1]]), {
      pageWidth: c,
      pageHeight: u,
      pageX: p,
      pageY: b
    } = i.rawDims;
    a.left = `${100 * (l[0] - p) / c}%`, a.top = `${100 * (l[1] - b) / u}%`;
    const {
      rotation: v
    } = e;
    return e.hasOwnCanvas || v === 0 ? (a.width = `${100 * o / c}%`, a.height = `${100 * h / u}%`) : this.setRotation(v, n), n;
  }
  setRotation(t, e = this.container) {
    if (!this.data.rect)
      return;
    const {
      pageWidth: s,
      pageHeight: i
    } = this.parent.viewport.rawDims, {
      width: n,
      height: a
    } = Fs(this.data.rect);
    let o, h;
    t % 180 === 0 ? (o = 100 * n / s, h = 100 * a / i) : (o = 100 * a / s, h = 100 * n / i), e.style.width = `${o}%`, e.style.height = `${h}%`, e.setAttribute("data-main-rotation", (360 - t) % 360);
  }
  get _commonActions() {
    const t = /* @__PURE__ */ d((e, s, i) => {
      const n = i.detail[e], a = n[0], o = n.slice(1);
      i.target.style[s] = el[`${a}_HTML`](o), this.annotationStorage.setValue(this.data.id, {
        [s]: el[`${a}_rgb`](o)
      });
    }, "setColor");
    return X(this, "_commonActions", {
      display: /* @__PURE__ */ d((e) => {
        const {
          display: s
        } = e.detail, i = s % 2 === 1;
        this.container.style.visibility = i ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
          noView: i,
          noPrint: s === 1 || s === 2
        });
      }, "display"),
      print: /* @__PURE__ */ d((e) => {
        this.annotationStorage.setValue(this.data.id, {
          noPrint: !e.detail.print
        });
      }, "print"),
      hidden: /* @__PURE__ */ d((e) => {
        const {
          hidden: s
        } = e.detail;
        this.container.style.visibility = s ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
          noPrint: s,
          noView: s
        });
      }, "hidden"),
      focus: /* @__PURE__ */ d((e) => {
        setTimeout(() => e.target.focus({
          preventScroll: !1
        }), 0);
      }, "focus"),
      userName: /* @__PURE__ */ d((e) => {
        e.target.title = e.detail.userName;
      }, "userName"),
      readonly: /* @__PURE__ */ d((e) => {
        e.target.disabled = e.detail.readonly;
      }, "readonly"),
      required: /* @__PURE__ */ d((e) => {
        this._setRequired(e.target, e.detail.required);
      }, "required"),
      bgColor: /* @__PURE__ */ d((e) => {
        t("bgColor", "backgroundColor", e);
      }, "bgColor"),
      fillColor: /* @__PURE__ */ d((e) => {
        t("fillColor", "backgroundColor", e);
      }, "fillColor"),
      fgColor: /* @__PURE__ */ d((e) => {
        t("fgColor", "color", e);
      }, "fgColor"),
      textColor: /* @__PURE__ */ d((e) => {
        t("textColor", "color", e);
      }, "textColor"),
      borderColor: /* @__PURE__ */ d((e) => {
        t("borderColor", "borderColor", e);
      }, "borderColor"),
      strokeColor: /* @__PURE__ */ d((e) => {
        t("strokeColor", "borderColor", e);
      }, "strokeColor"),
      rotation: /* @__PURE__ */ d((e) => {
        const s = e.detail.rotation;
        this.setRotation(s), this.annotationStorage.setValue(this.data.id, {
          rotation: s
        });
      }, "rotation")
    });
  }
  _dispatchEventFromSandbox(t, e) {
    const s = this._commonActions;
    for (const i of Object.keys(e.detail)) {
      const n = t[i] || s[i];
      n == null || n(e);
    }
  }
  _setDefaultPropertiesFromJS(t) {
    if (!this.enableScripting)
      return;
    const e = this.annotationStorage.getRawValue(this.data.id);
    if (!e)
      return;
    const s = this._commonActions;
    for (const [i, n] of Object.entries(e)) {
      const a = s[i];
      if (a) {
        const o = {
          detail: {
            [i]: n
          },
          target: t
        };
        a(o), delete e[i];
      }
    }
  }
  _createQuadrilaterals() {
    if (!this.container)
      return;
    const {
      quadPoints: t
    } = this.data;
    if (!t)
      return;
    const [e, s, i, n] = this.data.rect.map((y) => Math.fround(y));
    if (t.length === 8) {
      const [y, _, w, E] = t.subarray(2, 6);
      if (i === y && n === _ && e === w && s === E)
        return;
    }
    const {
      style: a
    } = this.container;
    let o;
    if (r(this, fr)) {
      const {
        borderColor: y,
        borderWidth: _
      } = a;
      a.borderWidth = 0, o = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${y}" stroke-width="${_}">`], this.container.classList.add("hasBorder");
    }
    const h = i - e, l = n - s, {
      svgFactory: c
    } = this, u = c.createElement("svg");
    u.classList.add("quadrilateralsContainer"), u.setAttribute("width", 0), u.setAttribute("height", 0);
    const p = c.createElement("defs");
    u.append(p);
    const b = c.createElement("clipPath"), v = `clippath_${this.data.id}`;
    b.setAttribute("id", v), b.setAttribute("clipPathUnits", "objectBoundingBox"), p.append(b);
    for (let y = 2, _ = t.length; y < _; y += 8) {
      const w = t[y], E = t[y + 1], S = t[y + 2], C = t[y + 3], T = c.createElement("rect"), x = (S - e) / h, k = (n - E) / l, P = (w - S) / h, O = (E - C) / l;
      T.setAttribute("x", x), T.setAttribute("y", k), T.setAttribute("width", P), T.setAttribute("height", O), b.append(T), o == null || o.push(`<rect vector-effect="non-scaling-stroke" x="${x}" y="${k}" width="${P}" height="${O}"/>`);
    }
    r(this, fr) && (o.push("</g></svg>')"), a.backgroundImage = o.join("")), this.container.append(u), this.container.style.clipPath = `url(#${v})`;
  }
  _createPopup() {
    const {
      container: t,
      data: e
    } = this;
    t.setAttribute("aria-haspopup", "dialog");
    const s = g(this, pr, new ma({
      data: {
        color: e.color,
        titleObj: e.titleObj,
        modificationDate: e.modificationDate,
        contentsObj: e.contentsObj,
        richText: e.richText,
        parentRect: e.rect,
        borderStyle: 0,
        id: `popup_${e.id}`,
        rotation: e.rotation
      },
      parent: this.parent,
      elements: [this]
    }));
    this.parent.div.append(s.render());
  }
  render() {
    et("Abstract method `AnnotationElement.render` called");
  }
  _getElementsByName(t, e = null) {
    const s = [];
    if (this._fieldObjects) {
      const i = this._fieldObjects[t];
      if (i)
        for (const {
          page: n,
          id: a,
          exportValues: o
        } of i) {
          if (n === -1 || a === e)
            continue;
          const h = typeof o == "string" ? o : null, l = document.querySelector(`[data-element-id="${a}"]`);
          if (l && !Rn.has(l)) {
            $(`_getElementsByName - element not allowed: ${a}`);
            continue;
          }
          s.push({
            id: a,
            exportValue: h,
            domElement: l
          });
        }
      return s;
    }
    for (const i of document.getElementsByName(t)) {
      const {
        exportValue: n
      } = i, a = i.getAttribute("data-element-id");
      a !== e && Rn.has(i) && s.push({
        id: a,
        exportValue: n,
        domElement: i
      });
    }
    return s;
  }
  show() {
    var t;
    this.container && (this.container.hidden = !1), (t = this.popup) == null || t.maybeShow();
  }
  hide() {
    var t;
    this.container && (this.container.hidden = !0), (t = this.popup) == null || t.forceHide();
  }
  getElementsToTriggerPopup() {
    return this.container;
  }
  addHighlightArea() {
    const t = this.getElementsToTriggerPopup();
    if (Array.isArray(t))
      for (const e of t)
        e.classList.add("highlightArea");
    else
      t.classList.add("highlightArea");
  }
  _editOnDoubleClick() {
    if (!this._isEditable)
      return;
    const {
      annotationEditorType: t,
      data: {
        id: e
      }
    } = this;
    this.container.addEventListener("dblclick", () => {
      var s;
      (s = this.linkService.eventBus) == null || s.dispatch("switchannotationeditormode", {
        source: this,
        mode: t,
        editId: e
      });
    });
  }
};
sn = new WeakMap(), fr = new WeakMap(), pr = new WeakMap(), lo = new WeakSet(), Ed = /* @__PURE__ */ d(function(t) {
  const {
    container: {
      style: e
    },
    data: {
      rect: s,
      rotation: i
    },
    parent: {
      viewport: {
        rawDims: {
          pageWidth: n,
          pageHeight: a,
          pageX: o,
          pageY: h
        }
      }
    }
  } = this;
  s == null || s.splice(0, 4, ...t);
  const {
    width: l,
    height: c
  } = Fs(t);
  e.left = `${100 * (t[0] - o) / n}%`, e.top = `${100 * (a - t[3] + h) / a}%`, i === 0 ? (e.width = `${100 * l / n}%`, e.height = `${100 * c / a}%`) : this.setRotation(i);
}, "#setRectEdited"), d(Fl, "AnnotationElement");
let ft = Fl;
var fe, _i, vg, yg;
const Hf = class Hf extends ft {
  constructor(e, s = null) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !!(s != null && s.ignoreBorder),
      createQuadrilaterals: !0
    });
    A(this, fe);
    this.isTooltipOnly = e.data.isTooltipOnly;
  }
  render() {
    const {
      data: e,
      linkService: s
    } = this, i = document.createElement("a");
    i.setAttribute("data-element-id", e.id);
    let n = !1;
    return e.url ? (s.addLinkAttributes(i, e.url, e.newWindow), n = !0) : e.action ? (this._bindNamedAction(i, e.action), n = !0) : e.attachment ? (m(this, fe, vg).call(this, i, e.attachment, e.attachmentDest), n = !0) : e.setOCGState ? (m(this, fe, yg).call(this, i, e.setOCGState), n = !0) : e.dest ? (this._bindLink(i, e.dest), n = !0) : (e.actions && (e.actions.Action || e.actions["Mouse Up"] || e.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(i, e), n = !0), e.resetForm ? (this._bindResetFormAction(i, e.resetForm), n = !0) : this.isTooltipOnly && !n && (this._bindLink(i, ""), n = !0)), this.container.classList.add("linkAnnotation"), n && this.container.append(i), this.container;
  }
  _bindLink(e, s) {
    e.href = this.linkService.getDestinationHash(s), e.onclick = () => (s && this.linkService.goToDestination(s), !1), (s || s === "") && m(this, fe, _i).call(this);
  }
  _bindNamedAction(e, s) {
    e.href = this.linkService.getAnchorUrl(""), e.onclick = () => (this.linkService.executeNamedAction(s), !1), m(this, fe, _i).call(this);
  }
  _bindJSAction(e, s) {
    e.href = this.linkService.getAnchorUrl("");
    const i = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
    for (const n of Object.keys(s.actions)) {
      const a = i.get(n);
      a && (e[a] = () => {
        var o;
        return (o = this.linkService.eventBus) == null || o.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: s.id,
            name: n
          }
        }), !1;
      });
    }
    e.onclick || (e.onclick = () => !1), m(this, fe, _i).call(this);
  }
  _bindResetFormAction(e, s) {
    const i = e.onclick;
    if (i || (e.href = this.linkService.getAnchorUrl("")), m(this, fe, _i).call(this), !this._fieldObjects) {
      $('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), i || (e.onclick = () => !1);
      return;
    }
    e.onclick = () => {
      var u;
      i == null || i();
      const {
        fields: n,
        refs: a,
        include: o
      } = s, h = [];
      if (n.length !== 0 || a.length !== 0) {
        const p = new Set(a);
        for (const b of n) {
          const v = this._fieldObjects[b] || [];
          for (const {
            id: y
          } of v)
            p.add(y);
        }
        for (const b of Object.values(this._fieldObjects))
          for (const v of b)
            p.has(v.id) === o && h.push(v);
      } else
        for (const p of Object.values(this._fieldObjects))
          h.push(...p);
      const l = this.annotationStorage, c = [];
      for (const p of h) {
        const {
          id: b
        } = p;
        switch (c.push(b), p.type) {
          case "text": {
            const y = p.defaultValue || "";
            l.setValue(b, {
              value: y
            });
            break;
          }
          case "checkbox":
          case "radiobutton": {
            const y = p.defaultValue === p.exportValues;
            l.setValue(b, {
              value: y
            });
            break;
          }
          case "combobox":
          case "listbox": {
            const y = p.defaultValue || "";
            l.setValue(b, {
              value: y
            });
            break;
          }
          default:
            continue;
        }
        const v = document.querySelector(`[data-element-id="${b}"]`);
        if (v) {
          if (!Rn.has(v)) {
            $(`_bindResetFormAction - element not allowed: ${b}`);
            continue;
          }
        } else continue;
        v.dispatchEvent(new Event("resetform"));
      }
      return this.enableScripting && ((u = this.linkService.eventBus) == null || u.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: "app",
          ids: c,
          name: "ResetForm"
        }
      })), !1;
    };
  }
};
fe = new WeakSet(), _i = /* @__PURE__ */ d(function() {
  this.container.setAttribute("data-internal-link", "");
}, "#setInternalLink"), vg = /* @__PURE__ */ d(function(e, s, i = null) {
  e.href = this.linkService.getAnchorUrl(""), s.description && (e.title = s.description), e.onclick = () => {
    var n;
    return (n = this.downloadManager) == null || n.openOrDownloadData(s.content, s.filename, i), !1;
  }, m(this, fe, _i).call(this);
}, "#bindAttachment"), yg = /* @__PURE__ */ d(function(e, s) {
  e.href = this.linkService.getAnchorUrl(""), e.onclick = () => (this.linkService.executeSetOCGState(s), !1), m(this, fe, _i).call(this);
}, "#bindSetOCGState"), d(Hf, "LinkAnnotationElement");
let il = Hf;
const Bf = class Bf extends ft {
  constructor(t) {
    super(t, {
      isRenderable: !0
    });
  }
  render() {
    this.container.classList.add("textAnnotation");
    const t = document.createElement("img");
    return t.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", t.setAttribute("data-l10n-id", "pdfjs-text-annotation-type"), t.setAttribute("data-l10n-args", JSON.stringify({
      type: this.data.name
    })), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(t), this.container;
  }
};
d(Bf, "TextAnnotationElement");
let Sd = Bf;
const Uf = class Uf extends ft {
  render() {
    return this.container;
  }
  showElementAndHideCanvas(t) {
    var e;
    this.data.hasOwnCanvas && (((e = t.previousSibling) == null ? void 0 : e.nodeName) === "CANVAS" && (t.previousSibling.hidden = !0), t.hidden = !1);
  }
  _getKeyModifier(t) {
    return jt.platform.isMac ? t.metaKey : t.ctrlKey;
  }
  _setEventListener(t, e, s, i, n) {
    s.includes("mouse") ? t.addEventListener(s, (a) => {
      var o;
      (o = this.linkService.eventBus) == null || o.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: this.data.id,
          name: i,
          value: n(a),
          shift: a.shiftKey,
          modifier: this._getKeyModifier(a)
        }
      });
    }) : t.addEventListener(s, (a) => {
      var o;
      if (s === "blur") {
        if (!e.focused || !a.relatedTarget)
          return;
        e.focused = !1;
      } else if (s === "focus") {
        if (e.focused)
          return;
        e.focused = !0;
      }
      n && ((o = this.linkService.eventBus) == null || o.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: this.data.id,
          name: i,
          value: n(a)
        }
      }));
    });
  }
  _setEventListeners(t, e, s, i) {
    var n, a, o;
    for (const [h, l] of s)
      (l === "Action" || (n = this.data.actions) != null && n[l]) && ((l === "Focus" || l === "Blur") && (e || (e = {
        focused: !1
      })), this._setEventListener(t, e, h, l, i), l === "Focus" && !((a = this.data.actions) != null && a.Blur) ? this._setEventListener(t, e, "blur", "Blur", null) : l === "Blur" && !((o = this.data.actions) != null && o.Focus) && this._setEventListener(t, e, "focus", "Focus", null));
  }
  _setBackgroundColor(t) {
    const e = this.data.backgroundColor || null;
    t.style.backgroundColor = e === null ? "transparent" : I.makeHexColor(e[0], e[1], e[2]);
  }
  _setTextStyle(t) {
    const e = ["left", "center", "right"], {
      fontColor: s
    } = this.data.defaultAppearanceData, i = this.data.defaultAppearanceData.fontSize || sb, n = t.style;
    let a;
    const o = 2, h = /* @__PURE__ */ d((l) => Math.round(10 * l) / 10, "roundToOneDecimal");
    if (this.data.multiLine) {
      const l = Math.abs(this.data.rect[3] - this.data.rect[1] - o), c = Math.round(l / (Yl * i)) || 1, u = l / c;
      a = Math.min(i, h(u / Yl));
    } else {
      const l = Math.abs(this.data.rect[3] - this.data.rect[1] - o);
      a = Math.min(i, h(l / Yl));
    }
    n.fontSize = `calc(${a}px * var(--scale-factor))`, n.color = I.makeHexColor(s[0], s[1], s[2]), this.data.textAlignment !== null && (n.textAlign = e[this.data.textAlignment]);
  }
  _setRequired(t, e) {
    e ? t.setAttribute("required", !0) : t.removeAttribute("required"), t.setAttribute("aria-required", e);
  }
};
d(Uf, "WidgetAnnotationElement");
let Us = Uf;
const zf = class zf extends Us {
  constructor(t) {
    const e = t.renderForms || t.data.hasOwnCanvas || !t.data.hasAppearance && !!t.data.fieldValue;
    super(t, {
      isRenderable: e
    });
  }
  setPropertyOnSiblings(t, e, s, i) {
    const n = this.annotationStorage;
    for (const a of this._getElementsByName(t.name, t.id))
      a.domElement && (a.domElement[e] = s), n.setValue(a.id, {
        [i]: s
      });
  }
  render() {
    var i, n;
    const t = this.annotationStorage, e = this.data.id;
    this.container.classList.add("textWidgetAnnotation");
    let s = null;
    if (this.renderForms) {
      const a = t.getValue(e, {
        value: this.data.fieldValue
      });
      let o = a.value || "";
      const h = t.getValue(e, {
        charLimit: this.data.maxLen
      }).charLimit;
      h && o.length > h && (o = o.slice(0, h));
      let l = a.formattedValue || ((i = this.data.textContent) == null ? void 0 : i.join(`
`)) || null;
      l && this.data.comb && (l = l.replaceAll(/\s+/g, ""));
      const c = {
        userValue: o,
        formattedValue: l,
        lastCommittedValue: null,
        commitKey: 1,
        focused: !1
      };
      this.data.multiLine ? (s = document.createElement("textarea"), s.textContent = l ?? o, this.data.doNotScroll && (s.style.overflowY = "hidden")) : (s = document.createElement("input"), s.type = "text", s.setAttribute("value", l ?? o), this.data.doNotScroll && (s.style.overflowX = "hidden")), this.data.hasOwnCanvas && (s.hidden = !0), Rn.add(s), s.setAttribute("data-element-id", e), s.disabled = this.data.readOnly, s.name = this.data.fieldName, s.tabIndex = Zo, this._setRequired(s, this.data.required), h && (s.maxLength = h), s.addEventListener("input", (p) => {
        t.setValue(e, {
          value: p.target.value
        }), this.setPropertyOnSiblings(s, "value", p.target.value, "value"), c.formattedValue = null;
      }), s.addEventListener("resetform", (p) => {
        const b = this.data.defaultFieldValue ?? "";
        s.value = c.userValue = b, c.formattedValue = null;
      });
      let u = /* @__PURE__ */ d((p) => {
        const {
          formattedValue: b
        } = c;
        b != null && (p.target.value = b), p.target.scrollLeft = 0;
      }, "blurListener");
      if (this.enableScripting && this.hasJSActions) {
        s.addEventListener("focus", (b) => {
          var y;
          if (c.focused)
            return;
          const {
            target: v
          } = b;
          c.userValue && (v.value = c.userValue), c.lastCommittedValue = v.value, c.commitKey = 1, (y = this.data.actions) != null && y.Focus || (c.focused = !0);
        }), s.addEventListener("updatefromsandbox", (b) => {
          this.showElementAndHideCanvas(b.target);
          const v = {
            value(y) {
              c.userValue = y.detail.value ?? "", t.setValue(e, {
                value: c.userValue.toString()
              }), y.target.value = c.userValue;
            },
            formattedValue(y) {
              const {
                formattedValue: _
              } = y.detail;
              c.formattedValue = _, _ != null && y.target !== document.activeElement && (y.target.value = _), t.setValue(e, {
                formattedValue: _
              });
            },
            selRange(y) {
              y.target.setSelectionRange(...y.detail.selRange);
            },
            charLimit: /* @__PURE__ */ d((y) => {
              var S;
              const {
                charLimit: _
              } = y.detail, {
                target: w
              } = y;
              if (_ === 0) {
                w.removeAttribute("maxLength");
                return;
              }
              w.setAttribute("maxLength", _);
              let E = c.userValue;
              !E || E.length <= _ || (E = E.slice(0, _), w.value = c.userValue = E, t.setValue(e, {
                value: E
              }), (S = this.linkService.eventBus) == null || S.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: e,
                  name: "Keystroke",
                  value: E,
                  willCommit: !0,
                  commitKey: 1,
                  selStart: w.selectionStart,
                  selEnd: w.selectionEnd
                }
              }));
            }, "charLimit")
          };
          this._dispatchEventFromSandbox(v, b);
        }), s.addEventListener("keydown", (b) => {
          var _;
          c.commitKey = 1;
          let v = -1;
          if (b.key === "Escape" ? v = 0 : b.key === "Enter" && !this.data.multiLine ? v = 2 : b.key === "Tab" && (c.commitKey = 3), v === -1)
            return;
          const {
            value: y
          } = b.target;
          c.lastCommittedValue !== y && (c.lastCommittedValue = y, c.userValue = y, (_ = this.linkService.eventBus) == null || _.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: e,
              name: "Keystroke",
              value: y,
              willCommit: !0,
              commitKey: v,
              selStart: b.target.selectionStart,
              selEnd: b.target.selectionEnd
            }
          }));
        });
        const p = u;
        u = null, s.addEventListener("blur", (b) => {
          var y, _;
          if (!c.focused || !b.relatedTarget)
            return;
          (y = this.data.actions) != null && y.Blur || (c.focused = !1);
          const {
            value: v
          } = b.target;
          c.userValue = v, c.lastCommittedValue !== v && ((_ = this.linkService.eventBus) == null || _.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: e,
              name: "Keystroke",
              value: v,
              willCommit: !0,
              commitKey: c.commitKey,
              selStart: b.target.selectionStart,
              selEnd: b.target.selectionEnd
            }
          })), p(b);
        }), (n = this.data.actions) != null && n.Keystroke && s.addEventListener("beforeinput", (b) => {
          var T;
          c.lastCommittedValue = null;
          const {
            data: v,
            target: y
          } = b, {
            value: _,
            selectionStart: w,
            selectionEnd: E
          } = y;
          let S = w, C = E;
          switch (b.inputType) {
            case "deleteWordBackward": {
              const x = _.substring(0, w).match(/\w*[^\w]*$/);
              x && (S -= x[0].length);
              break;
            }
            case "deleteWordForward": {
              const x = _.substring(w).match(/^[^\w]*\w*/);
              x && (C += x[0].length);
              break;
            }
            case "deleteContentBackward":
              w === E && (S -= 1);
              break;
            case "deleteContentForward":
              w === E && (C += 1);
              break;
          }
          b.preventDefault(), (T = this.linkService.eventBus) == null || T.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: e,
              name: "Keystroke",
              value: _,
              change: v || "",
              willCommit: !1,
              selStart: S,
              selEnd: C
            }
          });
        }), this._setEventListeners(s, c, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (b) => b.target.value);
      }
      if (u && s.addEventListener("blur", u), this.data.comb) {
        const b = (this.data.rect[2] - this.data.rect[0]) / h;
        s.classList.add("comb"), s.style.letterSpacing = `calc(${b}px * var(--scale-factor) - 1ch)`;
      }
    } else
      s = document.createElement("div"), s.textContent = this.data.fieldValue, s.style.verticalAlign = "middle", s.style.display = "table-cell", this.data.hasOwnCanvas && (s.hidden = !0);
    return this._setTextStyle(s), this._setBackgroundColor(s), this._setDefaultPropertiesFromJS(s), this.container.append(s), this.container;
  }
};
d(zf, "TextWidgetAnnotationElement");
let Cd = zf;
const $f = class $f extends Us {
  constructor(t) {
    super(t, {
      isRenderable: !!t.data.hasOwnCanvas
    });
  }
};
d($f, "SignatureWidgetAnnotationElement");
let xd = $f;
const jf = class jf extends Us {
  constructor(t) {
    super(t, {
      isRenderable: t.renderForms
    });
  }
  render() {
    const t = this.annotationStorage, e = this.data, s = e.id;
    let i = t.getValue(s, {
      value: e.exportValue === e.fieldValue
    }).value;
    typeof i == "string" && (i = i !== "Off", t.setValue(s, {
      value: i
    })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
    const n = document.createElement("input");
    return Rn.add(n), n.setAttribute("data-element-id", s), n.disabled = e.readOnly, this._setRequired(n, this.data.required), n.type = "checkbox", n.name = e.fieldName, i && n.setAttribute("checked", !0), n.setAttribute("exportValue", e.exportValue), n.tabIndex = Zo, n.addEventListener("change", (a) => {
      const {
        name: o,
        checked: h
      } = a.target;
      for (const l of this._getElementsByName(o, s)) {
        const c = h && l.exportValue === e.exportValue;
        l.domElement && (l.domElement.checked = c), t.setValue(l.id, {
          value: c
        });
      }
      t.setValue(s, {
        value: h
      });
    }), n.addEventListener("resetform", (a) => {
      const o = e.defaultFieldValue || "Off";
      a.target.checked = o === e.exportValue;
    }), this.enableScripting && this.hasJSActions && (n.addEventListener("updatefromsandbox", (a) => {
      const o = {
        value(h) {
          h.target.checked = h.detail.value !== "Off", t.setValue(s, {
            value: h.target.checked
          });
        }
      };
      this._dispatchEventFromSandbox(o, a);
    }), this._setEventListeners(n, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (a) => a.target.checked)), this._setBackgroundColor(n), this._setDefaultPropertiesFromJS(n), this.container.append(n), this.container;
  }
};
d(jf, "CheckboxWidgetAnnotationElement");
let Td = jf;
const Wf = class Wf extends Us {
  constructor(t) {
    super(t, {
      isRenderable: t.renderForms
    });
  }
  render() {
    this.container.classList.add("buttonWidgetAnnotation", "radioButton");
    const t = this.annotationStorage, e = this.data, s = e.id;
    let i = t.getValue(s, {
      value: e.fieldValue === e.buttonValue
    }).value;
    if (typeof i == "string" && (i = i !== e.buttonValue, t.setValue(s, {
      value: i
    })), i)
      for (const a of this._getElementsByName(e.fieldName, s))
        t.setValue(a.id, {
          value: !1
        });
    const n = document.createElement("input");
    if (Rn.add(n), n.setAttribute("data-element-id", s), n.disabled = e.readOnly, this._setRequired(n, this.data.required), n.type = "radio", n.name = e.fieldName, i && n.setAttribute("checked", !0), n.tabIndex = Zo, n.addEventListener("change", (a) => {
      const {
        name: o,
        checked: h
      } = a.target;
      for (const l of this._getElementsByName(o, s))
        t.setValue(l.id, {
          value: !1
        });
      t.setValue(s, {
        value: h
      });
    }), n.addEventListener("resetform", (a) => {
      const o = e.defaultFieldValue;
      a.target.checked = o != null && o === e.buttonValue;
    }), this.enableScripting && this.hasJSActions) {
      const a = e.buttonValue;
      n.addEventListener("updatefromsandbox", (o) => {
        const h = {
          value: /* @__PURE__ */ d((l) => {
            const c = a === l.detail.value;
            for (const u of this._getElementsByName(l.target.name)) {
              const p = c && u.id === s;
              u.domElement && (u.domElement.checked = p), t.setValue(u.id, {
                value: p
              });
            }
          }, "value")
        };
        this._dispatchEventFromSandbox(h, o);
      }), this._setEventListeners(n, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (o) => o.target.checked);
    }
    return this._setBackgroundColor(n), this._setDefaultPropertiesFromJS(n), this.container.append(n), this.container;
  }
};
d(Wf, "RadioButtonWidgetAnnotationElement");
let nl = Wf;
const Vf = class Vf extends il {
  constructor(t) {
    super(t, {
      ignoreBorder: t.data.hasAppearance
    });
  }
  render() {
    const t = super.render();
    t.classList.add("buttonWidgetAnnotation", "pushButton");
    const e = t.lastChild;
    return this.enableScripting && this.hasJSActions && e && (this._setDefaultPropertiesFromJS(e), e.addEventListener("updatefromsandbox", (s) => {
      this._dispatchEventFromSandbox({}, s);
    })), t;
  }
};
d(Vf, "PushButtonWidgetAnnotationElement");
let Ld = Vf;
const Gf = class Gf extends Us {
  constructor(t) {
    super(t, {
      isRenderable: t.renderForms
    });
  }
  render() {
    this.container.classList.add("choiceWidgetAnnotation");
    const t = this.annotationStorage, e = this.data.id, s = t.getValue(e, {
      value: this.data.fieldValue
    }), i = document.createElement("select");
    Rn.add(i), i.setAttribute("data-element-id", e), i.disabled = this.data.readOnly, this._setRequired(i, this.data.required), i.name = this.data.fieldName, i.tabIndex = Zo;
    let n = this.data.combo && this.data.options.length > 0;
    this.data.combo || (i.size = this.data.options.length, this.data.multiSelect && (i.multiple = !0)), i.addEventListener("resetform", (c) => {
      const u = this.data.defaultFieldValue;
      for (const p of i.options)
        p.selected = p.value === u;
    });
    for (const c of this.data.options) {
      const u = document.createElement("option");
      u.textContent = c.displayValue, u.value = c.exportValue, s.value.includes(c.exportValue) && (u.setAttribute("selected", !0), n = !1), i.append(u);
    }
    let a = null;
    if (n) {
      const c = document.createElement("option");
      c.value = " ", c.setAttribute("hidden", !0), c.setAttribute("selected", !0), i.prepend(c), a = /* @__PURE__ */ d(() => {
        c.remove(), i.removeEventListener("input", a), a = null;
      }, "removeEmptyEntry"), i.addEventListener("input", a);
    }
    const o = /* @__PURE__ */ d((c) => {
      const u = c ? "value" : "textContent", {
        options: p,
        multiple: b
      } = i;
      return b ? Array.prototype.filter.call(p, (v) => v.selected).map((v) => v[u]) : p.selectedIndex === -1 ? null : p[p.selectedIndex][u];
    }, "getValue");
    let h = o(!1);
    const l = /* @__PURE__ */ d((c) => {
      const u = c.target.options;
      return Array.prototype.map.call(u, (p) => ({
        displayValue: p.textContent,
        exportValue: p.value
      }));
    }, "getItems");
    return this.enableScripting && this.hasJSActions ? (i.addEventListener("updatefromsandbox", (c) => {
      const u = {
        value(p) {
          a == null || a();
          const b = p.detail.value, v = new Set(Array.isArray(b) ? b : [b]);
          for (const y of i.options)
            y.selected = v.has(y.value);
          t.setValue(e, {
            value: o(!0)
          }), h = o(!1);
        },
        multipleSelection(p) {
          i.multiple = !0;
        },
        remove(p) {
          const b = i.options, v = p.detail.remove;
          b[v].selected = !1, i.remove(v), b.length > 0 && Array.prototype.findIndex.call(b, (_) => _.selected) === -1 && (b[0].selected = !0), t.setValue(e, {
            value: o(!0),
            items: l(p)
          }), h = o(!1);
        },
        clear(p) {
          for (; i.length !== 0; )
            i.remove(0);
          t.setValue(e, {
            value: null,
            items: []
          }), h = o(!1);
        },
        insert(p) {
          const {
            index: b,
            displayValue: v,
            exportValue: y
          } = p.detail.insert, _ = i.children[b], w = document.createElement("option");
          w.textContent = v, w.value = y, _ ? _.before(w) : i.append(w), t.setValue(e, {
            value: o(!0),
            items: l(p)
          }), h = o(!1);
        },
        items(p) {
          const {
            items: b
          } = p.detail;
          for (; i.length !== 0; )
            i.remove(0);
          for (const v of b) {
            const {
              displayValue: y,
              exportValue: _
            } = v, w = document.createElement("option");
            w.textContent = y, w.value = _, i.append(w);
          }
          i.options.length > 0 && (i.options[0].selected = !0), t.setValue(e, {
            value: o(!0),
            items: l(p)
          }), h = o(!1);
        },
        indices(p) {
          const b = new Set(p.detail.indices);
          for (const v of p.target.options)
            v.selected = b.has(v.index);
          t.setValue(e, {
            value: o(!0)
          }), h = o(!1);
        },
        editable(p) {
          p.target.disabled = !p.detail.editable;
        }
      };
      this._dispatchEventFromSandbox(u, c);
    }), i.addEventListener("input", (c) => {
      var b;
      const u = o(!0), p = o(!1);
      t.setValue(e, {
        value: u
      }), c.preventDefault(), (b = this.linkService.eventBus) == null || b.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: e,
          name: "Keystroke",
          value: h,
          change: p,
          changeEx: u,
          willCommit: !1,
          commitKey: 1,
          keyDown: !1
        }
      });
    }), this._setEventListeners(i, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (c) => c.target.value)) : i.addEventListener("input", function(c) {
      t.setValue(e, {
        value: o(!0)
      });
    }), this.data.combo && this._setTextStyle(i), this._setBackgroundColor(i), this._setDefaultPropertiesFromJS(i), this.container.append(i), this.container;
  }
};
d(Gf, "ChoiceWidgetAnnotationElement");
let Rd = Gf;
const qf = class qf extends ft {
  constructor(t) {
    const {
      data: e,
      elements: s
    } = t;
    super(t, {
      isRenderable: ft._hasPopupData(e)
    }), this.elements = s, this.popup = null;
  }
  render() {
    this.container.classList.add("popupAnnotation");
    const t = this.popup = new kd({
      container: this.container,
      color: this.data.color,
      titleObj: this.data.titleObj,
      modificationDate: this.data.modificationDate,
      contentsObj: this.data.contentsObj,
      richText: this.data.richText,
      rect: this.data.rect,
      parentRect: this.data.parentRect || null,
      parent: this.parent,
      elements: this.elements,
      open: this.data.open
    }), e = [];
    for (const s of this.elements)
      s.popup = t, e.push(s.data.id), s.addHighlightArea();
    return this.container.setAttribute("aria-controls", e.map((s) => `${Dp}${s}`).join(",")), this.container;
  }
};
d(qf, "PopupAnnotationElement");
let ma = qf;
var gr, Nl, Ol, mr, nn, dt, ws, rn, co, uo, br, _s, ke, Es, fo, Ss, po, an, on, st, yh, Md, wg, _g, Eg, Sg, wh, _h, Id;
const Xf = class Xf {
  constructor({
    container: t,
    color: e,
    elements: s,
    titleObj: i,
    modificationDate: n,
    contentsObj: a,
    richText: o,
    parent: h,
    rect: l,
    parentRect: c,
    open: u
  }) {
    A(this, st);
    A(this, gr, m(this, st, Eg).bind(this));
    A(this, Nl, m(this, st, Id).bind(this));
    A(this, Ol, m(this, st, _h).bind(this));
    A(this, mr, m(this, st, wh).bind(this));
    A(this, nn, null);
    A(this, dt, null);
    A(this, ws, null);
    A(this, rn, null);
    A(this, co, null);
    A(this, uo, null);
    A(this, br, null);
    A(this, _s, !1);
    A(this, ke, null);
    A(this, Es, null);
    A(this, fo, null);
    A(this, Ss, null);
    A(this, po, null);
    A(this, an, null);
    A(this, on, !1);
    var p;
    g(this, dt, t), g(this, po, i), g(this, ws, a), g(this, Ss, o), g(this, uo, h), g(this, nn, e), g(this, fo, l), g(this, br, c), g(this, co, s), g(this, rn, jh.toDateObject(n)), this.trigger = s.flatMap((b) => b.getElementsToTriggerPopup());
    for (const b of this.trigger)
      b.addEventListener("click", r(this, mr)), b.addEventListener("mouseenter", r(this, Ol)), b.addEventListener("mouseleave", r(this, Nl)), b.classList.add("popupTriggerArea");
    for (const b of s)
      (p = b.container) == null || p.addEventListener("keydown", r(this, gr));
    r(this, dt).hidden = !0, u && m(this, st, wh).call(this);
  }
  render() {
    if (r(this, ke))
      return;
    const t = g(this, ke, document.createElement("div"));
    if (t.className = "popup", r(this, nn)) {
      const n = t.style.outlineColor = I.makeHexColor(...r(this, nn));
      CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? t.style.backgroundColor = `color-mix(in srgb, ${n} 30%, white)` : t.style.backgroundColor = I.makeHexColor(...r(this, nn).map((o) => Math.floor(0.7 * (255 - o) + o)));
    }
    const e = document.createElement("span");
    e.className = "header";
    const s = document.createElement("h1");
    if (e.append(s), {
      dir: s.dir,
      str: s.textContent
    } = r(this, po), t.append(e), r(this, rn)) {
      const n = document.createElement("span");
      n.classList.add("popupDate"), n.setAttribute("data-l10n-id", "pdfjs-annotation-date-string"), n.setAttribute("data-l10n-args", JSON.stringify({
        date: r(this, rn).toLocaleDateString(),
        time: r(this, rn).toLocaleTimeString()
      })), e.append(n);
    }
    const i = r(this, st, yh);
    if (i)
      sl.render({
        xfaHtml: i,
        intent: "richText",
        div: t
      }), t.lastChild.classList.add("richText", "popupContent");
    else {
      const n = this._formatContents(r(this, ws));
      t.append(n);
    }
    r(this, dt).append(t);
  }
  _formatContents({
    str: t,
    dir: e
  }) {
    const s = document.createElement("p");
    s.classList.add("popupContent"), s.dir = e;
    const i = t.split(/(?:\r\n?|\n)/);
    for (let n = 0, a = i.length; n < a; ++n) {
      const o = i[n];
      s.append(document.createTextNode(o)), n < a - 1 && s.append(document.createElement("br"));
    }
    return s;
  }
  updateEdited({
    rect: t,
    popupContent: e
  }) {
    var s;
    r(this, an) || g(this, an, {
      contentsObj: r(this, ws),
      richText: r(this, Ss)
    }), t && g(this, Es, null), e && (g(this, Ss, m(this, st, _g).call(this, e)), g(this, ws, null)), (s = r(this, ke)) == null || s.remove(), g(this, ke, null);
  }
  resetEdited() {
    var t;
    r(this, an) && ({
      contentsObj: se(this, ws)._,
      richText: se(this, Ss)._
    } = r(this, an), g(this, an, null), (t = r(this, ke)) == null || t.remove(), g(this, ke, null), g(this, Es, null));
  }
  forceHide() {
    g(this, on, this.isVisible), r(this, on) && (r(this, dt).hidden = !0);
  }
  maybeShow() {
    r(this, on) && (r(this, ke) || m(this, st, _h).call(this), g(this, on, !1), r(this, dt).hidden = !1);
  }
  get isVisible() {
    return r(this, dt).hidden === !1;
  }
};
gr = new WeakMap(), Nl = new WeakMap(), Ol = new WeakMap(), mr = new WeakMap(), nn = new WeakMap(), dt = new WeakMap(), ws = new WeakMap(), rn = new WeakMap(), co = new WeakMap(), uo = new WeakMap(), br = new WeakMap(), _s = new WeakMap(), ke = new WeakMap(), Es = new WeakMap(), fo = new WeakMap(), Ss = new WeakMap(), po = new WeakMap(), an = new WeakMap(), on = new WeakMap(), st = new WeakSet(), yh = /* @__PURE__ */ d(function() {
  const t = r(this, Ss), e = r(this, ws);
  return t != null && t.str && (!(e != null && e.str) || e.str === t.str) && r(this, Ss).html || null;
}, "#html"), Md = /* @__PURE__ */ d(function() {
  var t, e, s;
  return ((s = (e = (t = r(this, st, yh)) == null ? void 0 : t.attributes) == null ? void 0 : e.style) == null ? void 0 : s.fontSize) || 0;
}, "#fontSize"), wg = /* @__PURE__ */ d(function() {
  var t, e, s;
  return ((s = (e = (t = r(this, st, yh)) == null ? void 0 : t.attributes) == null ? void 0 : e.style) == null ? void 0 : s.color) || null;
}, "#fontColor"), _g = /* @__PURE__ */ d(function(t) {
  const e = [], s = {
    str: t,
    html: {
      name: "div",
      attributes: {
        dir: "auto"
      },
      children: [{
        name: "p",
        children: e
      }]
    }
  }, i = {
    style: {
      color: r(this, st, wg),
      fontSize: r(this, st, Md) ? `calc(${r(this, st, Md)}px * var(--scale-factor))` : ""
    }
  };
  for (const n of t.split(`
`))
    e.push({
      name: "span",
      value: n,
      attributes: i
    });
  return s;
}, "#makePopupContent"), Eg = /* @__PURE__ */ d(function(t) {
  t.altKey || t.shiftKey || t.ctrlKey || t.metaKey || (t.key === "Enter" || t.key === "Escape" && r(this, _s)) && m(this, st, wh).call(this);
}, "#keyDown"), Sg = /* @__PURE__ */ d(function() {
  if (r(this, Es) !== null)
    return;
  const {
    page: {
      view: t
    },
    viewport: {
      rawDims: {
        pageWidth: e,
        pageHeight: s,
        pageX: i,
        pageY: n
      }
    }
  } = r(this, uo);
  let a = !!r(this, br), o = a ? r(this, br) : r(this, fo);
  for (const v of r(this, co))
    if (!o || I.intersect(v.data.rect, o) !== null) {
      o = v.data.rect, a = !0;
      break;
    }
  const h = I.normalizeRect([o[0], t[3] - o[1] + t[1], o[2], t[3] - o[3] + t[1]]), c = a ? o[2] - o[0] + 5 : 0, u = h[0] + c, p = h[1];
  g(this, Es, [100 * (u - i) / e, 100 * (p - n) / s]);
  const {
    style: b
  } = r(this, dt);
  b.left = `${r(this, Es)[0]}%`, b.top = `${r(this, Es)[1]}%`;
}, "#setPosition"), wh = /* @__PURE__ */ d(function() {
  g(this, _s, !r(this, _s)), r(this, _s) ? (m(this, st, _h).call(this), r(this, dt).addEventListener("click", r(this, mr)), r(this, dt).addEventListener("keydown", r(this, gr))) : (m(this, st, Id).call(this), r(this, dt).removeEventListener("click", r(this, mr)), r(this, dt).removeEventListener("keydown", r(this, gr)));
}, "#toggle"), _h = /* @__PURE__ */ d(function() {
  r(this, ke) || this.render(), this.isVisible ? r(this, _s) && r(this, dt).classList.add("focused") : (m(this, st, Sg).call(this), r(this, dt).hidden = !1, r(this, dt).style.zIndex = parseInt(r(this, dt).style.zIndex) + 1e3);
}, "#show"), Id = /* @__PURE__ */ d(function() {
  r(this, dt).classList.remove("focused"), !(r(this, _s) || !this.isVisible) && (r(this, dt).hidden = !0, r(this, dt).style.zIndex = parseInt(r(this, dt).style.zIndex) - 1e3);
}, "#hide"), d(Xf, "PopupElement");
let kd = Xf;
const Yf = class Yf extends ft {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    }), this.textContent = t.data.textContent, this.textPosition = t.data.textPosition, this.annotationEditorType = G.FREETEXT;
  }
  render() {
    if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
      const t = document.createElement("div");
      t.classList.add("annotationTextContent"), t.setAttribute("role", "comment");
      for (const e of this.textContent) {
        const s = document.createElement("span");
        s.textContent = e, t.append(s);
      }
      this.container.append(t);
    }
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
  }
};
d(Yf, "FreeTextAnnotationElement");
let rl = Yf;
var go;
const Kf = class Kf extends ft {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    A(this, go, null);
  }
  render() {
    this.container.classList.add("lineAnnotation");
    const e = this.data, {
      width: s,
      height: i
    } = Fs(e.rect), n = this.svgFactory.create(s, i, !0), a = g(this, go, this.svgFactory.createElement("svg:line"));
    return a.setAttribute("x1", e.rect[2] - e.lineCoordinates[0]), a.setAttribute("y1", e.rect[3] - e.lineCoordinates[1]), a.setAttribute("x2", e.rect[2] - e.lineCoordinates[2]), a.setAttribute("y2", e.rect[3] - e.lineCoordinates[3]), a.setAttribute("stroke-width", e.borderStyle.width || 1), a.setAttribute("stroke", "transparent"), a.setAttribute("fill", "transparent"), n.append(a), this.container.append(n), !e.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return r(this, go);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
go = new WeakMap(), d(Kf, "LineAnnotationElement");
let Pd = Kf;
var mo;
const Qf = class Qf extends ft {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    A(this, mo, null);
  }
  render() {
    this.container.classList.add("squareAnnotation");
    const e = this.data, {
      width: s,
      height: i
    } = Fs(e.rect), n = this.svgFactory.create(s, i, !0), a = e.borderStyle.width, o = g(this, mo, this.svgFactory.createElement("svg:rect"));
    return o.setAttribute("x", a / 2), o.setAttribute("y", a / 2), o.setAttribute("width", s - a), o.setAttribute("height", i - a), o.setAttribute("stroke-width", a || 1), o.setAttribute("stroke", "transparent"), o.setAttribute("fill", "transparent"), n.append(o), this.container.append(n), !e.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return r(this, mo);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
mo = new WeakMap(), d(Qf, "SquareAnnotationElement");
let Dd = Qf;
var bo;
const Jf = class Jf extends ft {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    A(this, bo, null);
  }
  render() {
    this.container.classList.add("circleAnnotation");
    const e = this.data, {
      width: s,
      height: i
    } = Fs(e.rect), n = this.svgFactory.create(s, i, !0), a = e.borderStyle.width, o = g(this, bo, this.svgFactory.createElement("svg:ellipse"));
    return o.setAttribute("cx", s / 2), o.setAttribute("cy", i / 2), o.setAttribute("rx", s / 2 - a / 2), o.setAttribute("ry", i / 2 - a / 2), o.setAttribute("stroke-width", a || 1), o.setAttribute("stroke", "transparent"), o.setAttribute("fill", "transparent"), n.append(o), this.container.append(n), !e.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return r(this, bo);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
bo = new WeakMap(), d(Jf, "CircleAnnotationElement");
let Fd = Jf;
var Ao;
const Zf = class Zf extends ft {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    A(this, Ao, null);
    this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect: e,
        vertices: s,
        borderStyle: i,
        popupRef: n
      }
    } = this;
    if (!s)
      return this.container;
    const {
      width: a,
      height: o
    } = Fs(e), h = this.svgFactory.create(a, o, !0);
    let l = [];
    for (let u = 0, p = s.length; u < p; u += 2) {
      const b = s[u] - e[0], v = e[3] - s[u + 1];
      l.push(`${b},${v}`);
    }
    l = l.join(" ");
    const c = g(this, Ao, this.svgFactory.createElement(this.svgElementName));
    return c.setAttribute("points", l), c.setAttribute("stroke-width", i.width || 1), c.setAttribute("stroke", "transparent"), c.setAttribute("fill", "transparent"), h.append(c), this.container.append(h), !n && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return r(this, Ao);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
Ao = new WeakMap(), d(Zf, "PolylineAnnotationElement");
let al = Zf;
const tp = class tp extends al {
  constructor(t) {
    super(t), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
  }
};
d(tp, "PolygonAnnotationElement");
let Nd = tp;
const ep = class ep extends ft {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
  }
  render() {
    return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
};
d(ep, "CaretAnnotationElement");
let Od = ep;
var vo;
const sp = class sp extends ft {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    A(this, vo, []);
    this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = G.INK;
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect: e,
        inkLists: s,
        borderStyle: i,
        popupRef: n
      }
    } = this, {
      width: a,
      height: o
    } = Fs(e), h = this.svgFactory.create(a, o, !0);
    for (const l of s) {
      let c = [];
      for (let p = 0, b = l.length; p < b; p += 2) {
        const v = l[p] - e[0], y = e[3] - l[p + 1];
        c.push(`${v},${y}`);
      }
      c = c.join(" ");
      const u = this.svgFactory.createElement(this.svgElementName);
      r(this, vo).push(u), u.setAttribute("points", c), u.setAttribute("stroke-width", i.width || 1), u.setAttribute("stroke", "transparent"), u.setAttribute("fill", "transparent"), !n && this.hasPopupData && this._createPopup(), h.append(u);
    }
    return this.container.append(h), this.container;
  }
  getElementsToTriggerPopup() {
    return r(this, vo);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
vo = new WeakMap(), d(sp, "InkAnnotationElement");
let ol = sp;
const ip = class ip extends ft {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container;
  }
};
d(ip, "HighlightAnnotationElement");
let Hd = ip;
const np = class np extends ft {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
  }
};
d(np, "UnderlineAnnotationElement");
let Bd = np;
const rp = class rp extends ft {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
  }
};
d(rp, "SquigglyAnnotationElement");
let Ud = rp;
const ap = class ap extends ft {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
  }
};
d(ap, "StrikeOutAnnotationElement");
let zd = ap;
const op = class op extends ft {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
  }
  render() {
    return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
};
d(op, "StampAnnotationElement");
let hl = op;
var yo, wo, jd;
const hp = class hp extends ft {
  constructor(e) {
    var i;
    super(e, {
      isRenderable: !0
    });
    A(this, wo);
    A(this, yo, null);
    const {
      file: s
    } = this.data;
    this.filename = s.filename, this.content = s.content, (i = this.linkService.eventBus) == null || i.dispatch("fileattachmentannotation", {
      source: this,
      ...s
    });
  }
  render() {
    this.container.classList.add("fileAttachmentAnnotation");
    const {
      container: e,
      data: s
    } = this;
    let i;
    s.hasAppearance || s.fillAlpha === 0 ? i = document.createElement("div") : (i = document.createElement("img"), i.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(s.name) ? "paperclip" : "pushpin"}.svg`, s.fillAlpha && s.fillAlpha < 1 && (i.style = `filter: opacity(${Math.round(s.fillAlpha * 100)}%);`)), i.addEventListener("dblclick", m(this, wo, jd).bind(this)), g(this, yo, i);
    const {
      isMac: n
    } = jt.platform;
    return e.addEventListener("keydown", (a) => {
      a.key === "Enter" && (n ? a.metaKey : a.ctrlKey) && m(this, wo, jd).call(this);
    }), !s.popupRef && this.hasPopupData ? this._createPopup() : i.classList.add("popupTriggerArea"), e.append(i), e;
  }
  getElementsToTriggerPopup() {
    return r(this, yo);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
};
yo = new WeakMap(), wo = new WeakSet(), jd = /* @__PURE__ */ d(function() {
  var e;
  (e = this.downloadManager) == null || e.openOrDownloadData(this.content, this.filename);
}, "#download"), d(hp, "FileAttachmentAnnotationElement");
let $d = hp;
var _o, hn, ln, kn, Cg, Vd;
const lp = class lp {
  constructor({
    div: t,
    accessibilityManager: e,
    annotationCanvasMap: s,
    annotationEditorUIManager: i,
    page: n,
    viewport: a
  }) {
    A(this, kn);
    A(this, _o, null);
    A(this, hn, null);
    A(this, ln, /* @__PURE__ */ new Map());
    this.div = t, g(this, _o, e), g(this, hn, s), this.page = n, this.viewport = a, this.zIndex = 0, this._annotationEditorUIManager = i;
  }
  hasEditableAnnotations() {
    return r(this, ln).size > 0;
  }
  async render(t) {
    var a;
    const {
      annotations: e
    } = t, s = this.div;
    xn(s, this.viewport);
    const i = /* @__PURE__ */ new Map(), n = {
      data: null,
      layer: s,
      linkService: t.linkService,
      downloadManager: t.downloadManager,
      imageResourcesPath: t.imageResourcesPath || "",
      renderForms: t.renderForms !== !1,
      svgFactory: new la(),
      annotationStorage: t.annotationStorage || new ua(),
      enableScripting: t.enableScripting === !0,
      hasJSActions: t.hasJSActions,
      fieldObjects: t.fieldObjects,
      parent: this,
      elements: null
    };
    for (const o of e) {
      if (o.noHTML)
        continue;
      const h = o.annotationType === bt.POPUP;
      if (h) {
        const u = i.get(o.id);
        if (!u)
          continue;
        n.elements = u;
      } else {
        const {
          width: u,
          height: p
        } = Fs(o.rect);
        if (u <= 0 || p <= 0)
          continue;
      }
      n.data = o;
      const l = _d.create(n);
      if (!l.isRenderable)
        continue;
      if (!h && o.popupRef) {
        const u = i.get(o.popupRef);
        u ? u.push(l) : i.set(o.popupRef, [l]);
      }
      const c = l.render();
      o.hidden && (c.style.visibility = "hidden"), m(this, kn, Cg).call(this, c, o.id), l._isEditable && (r(this, ln).set(l.data.id, l), (a = this._annotationEditorUIManager) == null || a.renderAnnotationElement(l));
    }
    m(this, kn, Vd).call(this);
  }
  update({
    viewport: t
  }) {
    const e = this.div;
    this.viewport = t, xn(e, {
      rotation: t.rotation
    }), m(this, kn, Vd).call(this), e.hidden = !1;
  }
  getEditableAnnotations() {
    return Array.from(r(this, ln).values());
  }
  getEditableAnnotation(t) {
    return r(this, ln).get(t);
  }
};
_o = new WeakMap(), hn = new WeakMap(), ln = new WeakMap(), kn = new WeakSet(), Cg = /* @__PURE__ */ d(function(t, e) {
  var i;
  const s = t.firstChild || t;
  s.id = `${Dp}${e}`, this.div.append(t), (i = r(this, _o)) == null || i.moveElementInDOM(this.div, t, s, !1);
}, "#appendElement"), Vd = /* @__PURE__ */ d(function() {
  if (!r(this, hn))
    return;
  const t = this.div;
  for (const [e, s] of r(this, hn)) {
    const i = t.querySelector(`[data-annotation-id="${e}"]`);
    if (!i)
      continue;
    s.className = "annotationContent";
    const {
      firstChild: n
    } = i;
    n ? n.nodeName === "CANVAS" ? n.replaceWith(s) : n.classList.contains("annotationContent") ? n.after(s) : n.before(s) : i.append(s);
  }
  r(this, hn).clear();
}, "#setAnnotationCanvasMap"), d(lp, "AnnotationLayer");
let Wd = lp;
const hh = /\r\n?|\n/g;
var Eo, So, Co, xo, To, Me, oe, Lo, he, Ar, gt, xg, Tg, Lg, Eh, Os, Sh, Ch, Rg, qd, kg;
const it = class it extends Q {
  constructor(e) {
    super({
      ...e,
      name: "freeTextEditor"
    });
    A(this, gt);
    A(this, Eo, this.editorDivBlur.bind(this));
    A(this, So, this.editorDivFocus.bind(this));
    A(this, Co, this.editorDivInput.bind(this));
    A(this, xo, this.editorDivKeydown.bind(this));
    A(this, To, this.editorDivPaste.bind(this));
    A(this, Me);
    A(this, oe, "");
    A(this, Lo, `${this.id}-editor`);
    A(this, he);
    A(this, Ar, null);
    g(this, Me, e.color || it._defaultColor || Q._defaultLineColor), g(this, he, e.fontSize || it._defaultFontSize);
  }
  static get _keyboardManager() {
    const e = it.prototype, s = /* @__PURE__ */ d((a) => a.isEmpty(), "arrowChecker"), i = Ln.TRANSLATE_SMALL, n = Ln.TRANSLATE_BIG;
    return X(this, "_keyboardManager", new Tn([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], e.commitOrRemove, {
      bubbles: !0
    }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], e.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], e._translateEmpty, {
      args: [-i, 0],
      checker: s
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e._translateEmpty, {
      args: [-n, 0],
      checker: s
    }], [["ArrowRight", "mac+ArrowRight"], e._translateEmpty, {
      args: [i, 0],
      checker: s
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e._translateEmpty, {
      args: [n, 0],
      checker: s
    }], [["ArrowUp", "mac+ArrowUp"], e._translateEmpty, {
      args: [0, -i],
      checker: s
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e._translateEmpty, {
      args: [0, -n],
      checker: s
    }], [["ArrowDown", "mac+ArrowDown"], e._translateEmpty, {
      args: [0, i],
      checker: s
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e._translateEmpty, {
      args: [0, n],
      checker: s
    }]]));
  }
  static initialize(e, s) {
    Q.initialize(e, s, {
      strings: ["pdfjs-free-text-default-content"]
    });
    const i = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(i.getPropertyValue("--freetext-padding"));
  }
  static updateDefaultParams(e, s) {
    switch (e) {
      case N.FREETEXT_SIZE:
        it._defaultFontSize = s;
        break;
      case N.FREETEXT_COLOR:
        it._defaultColor = s;
        break;
    }
  }
  updateParams(e, s) {
    switch (e) {
      case N.FREETEXT_SIZE:
        m(this, gt, xg).call(this, s);
        break;
      case N.FREETEXT_COLOR:
        m(this, gt, Tg).call(this, s);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[N.FREETEXT_SIZE, it._defaultFontSize], [N.FREETEXT_COLOR, it._defaultColor || Q._defaultLineColor]];
  }
  get propertiesToUpdate() {
    return [[N.FREETEXT_SIZE, r(this, he)], [N.FREETEXT_COLOR, r(this, Me)]];
  }
  _translateEmpty(e, s) {
    this._uiManager.translateSelectedEditors(e, s, !0);
  }
  getInitialTranslation() {
    const e = this.parentScale;
    return [-it._internalPadding * e, -(it._internalPadding + r(this, he)) * e];
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
  }
  enableEditMode() {
    if (this.isInEditMode())
      return;
    this.parent.setEditingState(!1), this.parent.updateToolbar(G.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant");
    const e = this._uiManager._signal;
    this.editorDiv.addEventListener("keydown", r(this, xo), {
      signal: e
    }), this.editorDiv.addEventListener("focus", r(this, So), {
      signal: e
    }), this.editorDiv.addEventListener("blur", r(this, Eo), {
      signal: e
    }), this.editorDiv.addEventListener("input", r(this, Co), {
      signal: e
    }), this.editorDiv.addEventListener("paste", r(this, To), {
      signal: e
    });
  }
  disableEditMode() {
    this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", r(this, Lo)), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", r(this, xo)), this.editorDiv.removeEventListener("focus", r(this, So)), this.editorDiv.removeEventListener("blur", r(this, Eo)), this.editorDiv.removeEventListener("input", r(this, Co)), this.editorDiv.removeEventListener("paste", r(this, To)), this.div.focus({
      preventScroll: !0
    }), this.isEditing = !1, this.parent.div.classList.add("freetextEditing"));
  }
  focusin(e) {
    this._focusEventsAllowed && (super.focusin(e), e.target !== this.editorDiv && this.editorDiv.focus());
  }
  onceAdded() {
    var e;
    this.width || (this.enableEditMode(), this.editorDiv.focus(), (e = this._initialOptions) != null && e.isCentered && this.center(), this._initialOptions = null);
  }
  isEmpty() {
    return !this.editorDiv || this.editorDiv.innerText.trim() === "";
  }
  remove() {
    this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freetextEditing")), super.remove();
  }
  commit() {
    if (!this.isInEditMode())
      return;
    super.commit(), this.disableEditMode();
    const e = r(this, oe), s = g(this, oe, m(this, gt, Lg).call(this).trimEnd());
    if (e === s)
      return;
    const i = /* @__PURE__ */ d((n) => {
      if (g(this, oe, n), !n) {
        this.remove();
        return;
      }
      m(this, gt, Ch).call(this), this._uiManager.rebuild(this), m(this, gt, Eh).call(this);
    }, "setText");
    this.addCommands({
      cmd: /* @__PURE__ */ d(() => {
        i(s);
      }, "cmd"),
      undo: /* @__PURE__ */ d(() => {
        i(e);
      }, "undo"),
      mustExec: !1
    }), m(this, gt, Eh).call(this);
  }
  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }
  enterInEditMode() {
    this.enableEditMode(), this.editorDiv.focus();
  }
  dblclick(e) {
    this.enterInEditMode();
  }
  keydown(e) {
    e.target === this.div && e.key === "Enter" && (this.enterInEditMode(), e.preventDefault());
  }
  editorDivKeydown(e) {
    it._keyboardManager.exec(this, e);
  }
  editorDivFocus(e) {
    this.isEditing = !0;
  }
  editorDivBlur(e) {
    this.isEditing = !1;
  }
  editorDivInput(e) {
    this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
  }
  disableEditing() {
    this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
  }
  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
  }
  render() {
    if (this.div)
      return this.div;
    let e, s;
    this.width && (e = this.x, s = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", r(this, Lo)), this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text"), this.enableEditing(), Q._l10nPromise.get("pdfjs-free-text-default-content").then((n) => {
      var a;
      return (a = this.editorDiv) == null ? void 0 : a.setAttribute("default-content", n);
    }), this.editorDiv.contentEditable = !0;
    const {
      style: i
    } = this.editorDiv;
    if (i.fontSize = `calc(${r(this, he)}px * var(--scale-factor))`, i.color = r(this, Me), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), Wh(this, this.div, ["dblclick", "keydown"]), this.width) {
      const [n, a] = this.parentDimensions;
      if (this.annotationElementId) {
        const {
          position: o
        } = r(this, Ar);
        let [h, l] = this.getInitialTranslation();
        [h, l] = this.pageTranslationToScreen(h, l);
        const [c, u] = this.pageDimensions, [p, b] = this.pageTranslation;
        let v, y;
        switch (this.rotation) {
          case 0:
            v = e + (o[0] - p) / c, y = s + this.height - (o[1] - b) / u;
            break;
          case 90:
            v = e + (o[0] - p) / c, y = s - (o[1] - b) / u, [h, l] = [l, -h];
            break;
          case 180:
            v = e - this.width + (o[0] - p) / c, y = s - (o[1] - b) / u, [h, l] = [-h, -l];
            break;
          case 270:
            v = e + (o[0] - p - this.height * u) / c, y = s + (o[1] - b - this.width * c) / u, [h, l] = [-l, h];
            break;
        }
        this.setAt(v * n, y * a, h, l);
      } else
        this.setAt(e * n, s * a, this.width * n, this.height * a);
      m(this, gt, Ch).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
    } else
      this._isDraggable = !1, this.editorDiv.contentEditable = !0;
    return this.div;
  }
  editorDivPaste(e) {
    var v, y, _;
    const s = e.clipboardData || window.clipboardData, {
      types: i
    } = s;
    if (i.length === 1 && i[0] === "text/plain")
      return;
    e.preventDefault();
    const n = m(v = it, Os, qd).call(v, s.getData("text") || "").replaceAll(hh, `
`);
    if (!n)
      return;
    const a = window.getSelection();
    if (!a.rangeCount)
      return;
    this.editorDiv.normalize(), a.deleteFromDocument();
    const o = a.getRangeAt(0);
    if (!n.includes(`
`)) {
      o.insertNode(document.createTextNode(n)), this.editorDiv.normalize(), a.collapseToStart();
      return;
    }
    const {
      startContainer: h,
      startOffset: l
    } = o, c = [], u = [];
    if (h.nodeType === Node.TEXT_NODE) {
      const w = h.parentElement;
      if (u.push(h.nodeValue.slice(l).replaceAll(hh, "")), w !== this.editorDiv) {
        let E = c;
        for (const S of this.editorDiv.childNodes) {
          if (S === w) {
            E = u;
            continue;
          }
          E.push(m(y = it, Os, Sh).call(y, S));
        }
      }
      c.push(h.nodeValue.slice(0, l).replaceAll(hh, ""));
    } else if (h === this.editorDiv) {
      let w = c, E = 0;
      for (const S of this.editorDiv.childNodes)
        E++ === l && (w = u), w.push(m(_ = it, Os, Sh).call(_, S));
    }
    g(this, oe, `${c.join(`
`)}${n}${u.join(`
`)}`), m(this, gt, Ch).call(this);
    const p = new Range();
    let b = c.reduce((w, E) => w + E.length, 0);
    for (const {
      firstChild: w
    } of this.editorDiv.childNodes)
      if (w.nodeType === Node.TEXT_NODE) {
        const E = w.nodeValue.length;
        if (b <= E) {
          p.setStart(w, b), p.setEnd(w, b);
          break;
        }
        b -= E;
      }
    a.removeAllRanges(), a.addRange(p);
  }
  get contentDiv() {
    return this.editorDiv;
  }
  static deserialize(e, s, i) {
    var o;
    let n = null;
    if (e instanceof rl) {
      const {
        data: {
          defaultAppearanceData: {
            fontSize: h,
            fontColor: l
          },
          rect: c,
          rotation: u,
          id: p
        },
        textContent: b,
        textPosition: v,
        parent: {
          page: {
            pageNumber: y
          }
        }
      } = e;
      if (!b || b.length === 0)
        return null;
      n = e = {
        annotationType: G.FREETEXT,
        color: Array.from(l),
        fontSize: h,
        value: b.join(`
`),
        position: v,
        pageIndex: y - 1,
        rect: c.slice(0),
        rotation: u,
        id: p,
        deleted: !1
      };
    }
    const a = super.deserialize(e, s, i);
    return g(a, he, e.fontSize), g(a, Me, I.makeHexColor(...e.color)), g(a, oe, m(o = it, Os, qd).call(o, e.value)), a.annotationElementId = e.id || null, g(a, Ar, n), a;
  }
  serialize(e = !1) {
    if (this.isEmpty())
      return null;
    if (this.deleted)
      return {
        pageIndex: this.pageIndex,
        id: this.annotationElementId,
        deleted: !0
      };
    const s = it._internalPadding * this.parentScale, i = this.getRect(s, s), n = Q._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : r(this, Me)), a = {
      annotationType: G.FREETEXT,
      color: n,
      fontSize: r(this, he),
      value: m(this, gt, Rg).call(this),
      pageIndex: this.pageIndex,
      rect: i,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
    return e ? a : this.annotationElementId && !m(this, gt, kg).call(this, a) ? null : (a.id = this.annotationElementId, a);
  }
  renderAnnotationElement(e) {
    const s = super.renderAnnotationElement(e);
    if (this.deleted)
      return s;
    const {
      style: i
    } = s;
    i.fontSize = `calc(${r(this, he)}px * var(--scale-factor))`, i.color = r(this, Me), s.replaceChildren();
    for (const a of r(this, oe).split(`
`)) {
      const o = document.createElement("div");
      o.append(a ? document.createTextNode(a) : document.createElement("br")), s.append(o);
    }
    const n = it._internalPadding * this.parentScale;
    return e.updateEdited({
      rect: this.getRect(n, n),
      popupContent: r(this, oe)
    }), s;
  }
  resetAnnotationElement(e) {
    super.resetAnnotationElement(e), e.resetEdited();
  }
};
Eo = new WeakMap(), So = new WeakMap(), Co = new WeakMap(), xo = new WeakMap(), To = new WeakMap(), Me = new WeakMap(), oe = new WeakMap(), Lo = new WeakMap(), he = new WeakMap(), Ar = new WeakMap(), gt = new WeakSet(), xg = /* @__PURE__ */ d(function(e) {
  const s = /* @__PURE__ */ d((n) => {
    this.editorDiv.style.fontSize = `calc(${n}px * var(--scale-factor))`, this.translate(0, -(n - r(this, he)) * this.parentScale), g(this, he, n), m(this, gt, Eh).call(this);
  }, "setFontsize"), i = r(this, he);
  this.addCommands({
    cmd: s.bind(this, e),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: N.FREETEXT_SIZE,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, "#updateFontSize"), Tg = /* @__PURE__ */ d(function(e) {
  const s = /* @__PURE__ */ d((n) => {
    g(this, Me, this.editorDiv.style.color = n);
  }, "setColor"), i = r(this, Me);
  this.addCommands({
    cmd: s.bind(this, e),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: N.FREETEXT_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, "#updateColor"), Lg = /* @__PURE__ */ d(function() {
  var s;
  const e = [];
  this.editorDiv.normalize();
  for (const i of this.editorDiv.childNodes)
    e.push(m(s = it, Os, Sh).call(s, i));
  return e.join(`
`);
}, "#extractText"), Eh = /* @__PURE__ */ d(function() {
  const [e, s] = this.parentDimensions;
  let i;
  if (this.isAttachedToDOM)
    i = this.div.getBoundingClientRect();
  else {
    const {
      currentLayer: n,
      div: a
    } = this, o = a.style.display, h = a.classList.contains("hidden");
    a.classList.remove("hidden"), a.style.display = "hidden", n.div.append(this.div), i = a.getBoundingClientRect(), a.remove(), a.style.display = o, a.classList.toggle("hidden", h);
  }
  this.rotation % 180 === this.parentRotation % 180 ? (this.width = i.width / e, this.height = i.height / s) : (this.width = i.height / e, this.height = i.width / s), this.fixAndSetPosition();
}, "#setEditorDimensions"), Os = new WeakSet(), Sh = /* @__PURE__ */ d(function(e) {
  return (e.nodeType === Node.TEXT_NODE ? e.nodeValue : e.innerText).replaceAll(hh, "");
}, "#getNodeContent"), Ch = /* @__PURE__ */ d(function() {
  if (this.editorDiv.replaceChildren(), !!r(this, oe))
    for (const e of r(this, oe).split(`
`)) {
      const s = document.createElement("div");
      s.append(e ? document.createTextNode(e) : document.createElement("br")), this.editorDiv.append(s);
    }
}, "#setContent"), Rg = /* @__PURE__ */ d(function() {
  return r(this, oe).replaceAll(" ", " ");
}, "#serializeContent"), qd = /* @__PURE__ */ d(function(e) {
  return e.replaceAll(" ", " ");
}, "#deserializeContent"), kg = /* @__PURE__ */ d(function(e) {
  const {
    value: s,
    fontSize: i,
    color: n,
    pageIndex: a
  } = r(this, Ar);
  return this._hasBeenMoved || e.value !== s || e.fontSize !== i || e.color.some((o, h) => o !== n[h]) || e.pageIndex !== a;
}, "#hasElementChanged"), A(it, Os), d(it, "FreeTextEditor"), U(it, "_freeTextDefaultContent", ""), U(it, "_internalPadding", 0), U(it, "_defaultColor", null), U(it, "_defaultFontSize", 10), U(it, "_type", "freetext"), U(it, "_editorType", G.FREETEXT);
let Gd = it;
var Ro, hi, Ie, Yt, Mg, xh, Ig, Pg, Xd;
const cp = class cp {
  constructor(t, e = 0, s = 0, i = !0) {
    A(this, Yt);
    A(this, Ro);
    A(this, hi, []);
    A(this, Ie, []);
    let n = 1 / 0, a = -1 / 0, o = 1 / 0, h = -1 / 0;
    const c = 10 ** -4;
    for (const {
      x: w,
      y: E,
      width: S,
      height: C
    } of t) {
      const T = Math.floor((w - e) / c) * c, x = Math.ceil((w + S + e) / c) * c, k = Math.floor((E - e) / c) * c, P = Math.ceil((E + C + e) / c) * c, O = [T, k, P, !0], q = [x, k, P, !1];
      r(this, hi).push(O, q), n = Math.min(n, T), a = Math.max(a, x), o = Math.min(o, k), h = Math.max(h, P);
    }
    const u = a - n + 2 * s, p = h - o + 2 * s, b = n - s, v = o - s, y = r(this, hi).at(i ? -1 : -2), _ = [y[0], y[2]];
    for (const w of r(this, hi)) {
      const [E, S, C] = w;
      w[0] = (E - b) / u, w[1] = (S - v) / p, w[2] = (C - v) / p;
    }
    g(this, Ro, {
      x: b,
      y: v,
      width: u,
      height: p,
      lastPoint: _
    });
  }
  getOutlines() {
    r(this, hi).sort((e, s) => e[0] - s[0] || e[1] - s[1] || e[2] - s[2]);
    const t = [];
    for (const e of r(this, hi))
      e[3] ? (t.push(...m(this, Yt, Xd).call(this, e)), m(this, Yt, Ig).call(this, e)) : (m(this, Yt, Pg).call(this, e), t.push(...m(this, Yt, Xd).call(this, e)));
    return m(this, Yt, Mg).call(this, t);
  }
};
Ro = new WeakMap(), hi = new WeakMap(), Ie = new WeakMap(), Yt = new WeakSet(), Mg = /* @__PURE__ */ d(function(t) {
  const e = [], s = /* @__PURE__ */ new Set();
  for (const a of t) {
    const [o, h, l] = a;
    e.push([o, h, a], [o, l, a]);
  }
  e.sort((a, o) => a[1] - o[1] || a[0] - o[0]);
  for (let a = 0, o = e.length; a < o; a += 2) {
    const h = e[a][2], l = e[a + 1][2];
    h.push(l), l.push(h), s.add(h), s.add(l);
  }
  const i = [];
  let n;
  for (; s.size > 0; ) {
    const a = s.values().next().value;
    let [o, h, l, c, u] = a;
    s.delete(a);
    let p = o, b = h;
    for (n = [o, l], i.push(n); ; ) {
      let v;
      if (s.has(c))
        v = c;
      else if (s.has(u))
        v = u;
      else
        break;
      s.delete(v), [o, h, l, c, u] = v, p !== o && (n.push(p, b, o, b === h ? h : l), p = o), b = b === h ? l : h;
    }
    n.push(p, b);
  }
  return new Yd(i, r(this, Ro));
}, "#getOutlines"), xh = /* @__PURE__ */ d(function(t) {
  const e = r(this, Ie);
  let s = 0, i = e.length - 1;
  for (; s <= i; ) {
    const n = s + i >> 1, a = e[n][0];
    if (a === t)
      return n;
    a < t ? s = n + 1 : i = n - 1;
  }
  return i + 1;
}, "#binarySearch"), Ig = /* @__PURE__ */ d(function([, t, e]) {
  const s = m(this, Yt, xh).call(this, t);
  r(this, Ie).splice(s, 0, [t, e]);
}, "#insert"), Pg = /* @__PURE__ */ d(function([, t, e]) {
  const s = m(this, Yt, xh).call(this, t);
  for (let i = s; i < r(this, Ie).length; i++) {
    const [n, a] = r(this, Ie)[i];
    if (n !== t)
      break;
    if (n === t && a === e) {
      r(this, Ie).splice(i, 1);
      return;
    }
  }
  for (let i = s - 1; i >= 0; i--) {
    const [n, a] = r(this, Ie)[i];
    if (n !== t)
      break;
    if (n === t && a === e) {
      r(this, Ie).splice(i, 1);
      return;
    }
  }
}, "#remove"), Xd = /* @__PURE__ */ d(function(t) {
  const [e, s, i] = t, n = [[e, s, i]], a = m(this, Yt, xh).call(this, i);
  for (let o = 0; o < a; o++) {
    const [h, l] = r(this, Ie)[o];
    for (let c = 0, u = n.length; c < u; c++) {
      const [, p, b] = n[c];
      if (!(l <= p || b <= h)) {
        if (p >= h) {
          if (b > l)
            n[c][1] = l;
          else {
            if (u === 1)
              return [];
            n.splice(c, 1), c--, u--;
          }
          continue;
        }
        n[c][2] = h, b > l && n.push([e, l, b]);
      }
    }
  }
  return n;
}, "#breakEdge"), d(cp, "Outliner");
let ll = cp;
const dp = class dp {
  toSVGPath() {
    throw new Error("Abstract method `toSVGPath` must be implemented.");
  }
  get box() {
    throw new Error("Abstract getter `box` must be implemented.");
  }
  serialize(t, e) {
    throw new Error("Abstract method `serialize` must be implemented.");
  }
  get free() {
    return this instanceof ba;
  }
};
d(dp, "Outline");
let cl = dp;
var ko, vr;
const up = class up extends cl {
  constructor(e, s) {
    super();
    A(this, ko);
    A(this, vr);
    g(this, vr, e), g(this, ko, s);
  }
  toSVGPath() {
    const e = [];
    for (const s of r(this, vr)) {
      let [i, n] = s;
      e.push(`M${i} ${n}`);
      for (let a = 2; a < s.length; a += 2) {
        const o = s[a], h = s[a + 1];
        o === i ? (e.push(`V${h}`), n = h) : h === n && (e.push(`H${o}`), i = o);
      }
      e.push("Z");
    }
    return e.join(" ");
  }
  serialize([e, s, i, n], a) {
    const o = [], h = i - e, l = n - s;
    for (const c of r(this, vr)) {
      const u = new Array(c.length);
      for (let p = 0; p < c.length; p += 2)
        u[p] = e + c[p] * h, u[p + 1] = n - c[p + 1] * l;
      o.push(u);
    }
    return o;
  }
  get box() {
    return r(this, ko);
  }
};
ko = new WeakMap(), vr = new WeakMap(), d(up, "HighlightOutline");
let Yd = up;
var Ye, Cs, yr, wr, Ke, V, cn, dn, Mo, Io, _r, Er, li, Po, Hl, Bl, Do, Kd;
const Be = class Be {
  constructor({
    x: t,
    y: e
  }, s, i, n, a, o = 0) {
    A(this, Do);
    A(this, Ye);
    A(this, Cs, []);
    A(this, yr);
    A(this, wr);
    A(this, Ke, []);
    A(this, V, new Float64Array(18));
    A(this, cn);
    A(this, dn);
    A(this, Mo);
    A(this, Io);
    A(this, _r);
    A(this, Er);
    A(this, li, []);
    g(this, Ye, s), g(this, Er, n * i), g(this, wr, a), r(this, V).set([NaN, NaN, NaN, NaN, t, e], 6), g(this, yr, o), g(this, Io, r(Be, Po) * i), g(this, Mo, r(Be, Bl) * i), g(this, _r, i), r(this, li).push(t, e);
  }
  get free() {
    return !0;
  }
  isEmpty() {
    return isNaN(r(this, V)[8]);
  }
  add({
    x: t,
    y: e
  }) {
    var O;
    g(this, cn, t), g(this, dn, e);
    const [s, i, n, a] = r(this, Ye);
    let [o, h, l, c] = r(this, V).subarray(8, 12);
    const u = t - l, p = e - c, b = Math.hypot(u, p);
    if (b < r(this, Mo))
      return !1;
    const v = b - r(this, Io), y = v / b, _ = y * u, w = y * p;
    let E = o, S = h;
    o = l, h = c, l += _, c += w, (O = r(this, li)) == null || O.push(t, e);
    const C = -w / v, T = _ / v, x = C * r(this, Er), k = T * r(this, Er);
    return r(this, V).set(r(this, V).subarray(2, 8), 0), r(this, V).set([l + x, c + k], 4), r(this, V).set(r(this, V).subarray(14, 18), 12), r(this, V).set([l - x, c - k], 16), isNaN(r(this, V)[6]) ? (r(this, Ke).length === 0 && (r(this, V).set([o + x, h + k], 2), r(this, Ke).push(NaN, NaN, NaN, NaN, (o + x - s) / n, (h + k - i) / a), r(this, V).set([o - x, h - k], 14), r(this, Cs).push(NaN, NaN, NaN, NaN, (o - x - s) / n, (h - k - i) / a)), r(this, V).set([E, S, o, h, l, c], 6), !this.isEmpty()) : (r(this, V).set([E, S, o, h, l, c], 6), Math.abs(Math.atan2(S - h, E - o) - Math.atan2(w, _)) < Math.PI / 2 ? ([o, h, l, c] = r(this, V).subarray(2, 6), r(this, Ke).push(NaN, NaN, NaN, NaN, ((o + l) / 2 - s) / n, ((h + c) / 2 - i) / a), [o, h, E, S] = r(this, V).subarray(14, 18), r(this, Cs).push(NaN, NaN, NaN, NaN, ((E + o) / 2 - s) / n, ((S + h) / 2 - i) / a), !0) : ([E, S, o, h, l, c] = r(this, V).subarray(0, 6), r(this, Ke).push(((E + 5 * o) / 6 - s) / n, ((S + 5 * h) / 6 - i) / a, ((5 * o + l) / 6 - s) / n, ((5 * h + c) / 6 - i) / a, ((o + l) / 2 - s) / n, ((h + c) / 2 - i) / a), [l, c, o, h, E, S] = r(this, V).subarray(12, 18), r(this, Cs).push(((E + 5 * o) / 6 - s) / n, ((S + 5 * h) / 6 - i) / a, ((5 * o + l) / 6 - s) / n, ((5 * h + c) / 6 - i) / a, ((o + l) / 2 - s) / n, ((h + c) / 2 - i) / a), !0));
  }
  toSVGPath() {
    if (this.isEmpty())
      return "";
    const t = r(this, Ke), e = r(this, Cs), s = r(this, V).subarray(4, 6), i = r(this, V).subarray(16, 18), [n, a, o, h] = r(this, Ye), [l, c, u, p] = m(this, Do, Kd).call(this);
    if (isNaN(r(this, V)[6]) && !this.isEmpty())
      return `M${(r(this, V)[2] - n) / o} ${(r(this, V)[3] - a) / h} L${(r(this, V)[4] - n) / o} ${(r(this, V)[5] - a) / h} L${l} ${c} L${u} ${p} L${(r(this, V)[16] - n) / o} ${(r(this, V)[17] - a) / h} L${(r(this, V)[14] - n) / o} ${(r(this, V)[15] - a) / h} Z`;
    const b = [];
    b.push(`M${t[4]} ${t[5]}`);
    for (let v = 6; v < t.length; v += 6)
      isNaN(t[v]) ? b.push(`L${t[v + 4]} ${t[v + 5]}`) : b.push(`C${t[v]} ${t[v + 1]} ${t[v + 2]} ${t[v + 3]} ${t[v + 4]} ${t[v + 5]}`);
    b.push(`L${(s[0] - n) / o} ${(s[1] - a) / h} L${l} ${c} L${u} ${p} L${(i[0] - n) / o} ${(i[1] - a) / h}`);
    for (let v = e.length - 6; v >= 6; v -= 6)
      isNaN(e[v]) ? b.push(`L${e[v + 4]} ${e[v + 5]}`) : b.push(`C${e[v]} ${e[v + 1]} ${e[v + 2]} ${e[v + 3]} ${e[v + 4]} ${e[v + 5]}`);
    return b.push(`L${e[4]} ${e[5]} Z`), b.join(" ");
  }
  getOutlines() {
    var w;
    const t = r(this, Ke), e = r(this, Cs), s = r(this, V), i = s.subarray(4, 6), n = s.subarray(16, 18), [a, o, h, l] = r(this, Ye), c = new Float64Array((((w = r(this, li)) == null ? void 0 : w.length) ?? 0) + 2);
    for (let E = 0, S = c.length - 2; E < S; E += 2)
      c[E] = (r(this, li)[E] - a) / h, c[E + 1] = (r(this, li)[E + 1] - o) / l;
    c[c.length - 2] = (r(this, cn) - a) / h, c[c.length - 1] = (r(this, dn) - o) / l;
    const [u, p, b, v] = m(this, Do, Kd).call(this);
    if (isNaN(s[6]) && !this.isEmpty()) {
      const E = new Float64Array(36);
      return E.set([NaN, NaN, NaN, NaN, (s[2] - a) / h, (s[3] - o) / l, NaN, NaN, NaN, NaN, (s[4] - a) / h, (s[5] - o) / l, NaN, NaN, NaN, NaN, u, p, NaN, NaN, NaN, NaN, b, v, NaN, NaN, NaN, NaN, (s[16] - a) / h, (s[17] - o) / l, NaN, NaN, NaN, NaN, (s[14] - a) / h, (s[15] - o) / l], 0), new ba(E, c, r(this, Ye), r(this, _r), r(this, yr), r(this, wr));
    }
    const y = new Float64Array(r(this, Ke).length + 24 + r(this, Cs).length);
    let _ = t.length;
    for (let E = 0; E < _; E += 2) {
      if (isNaN(t[E])) {
        y[E] = y[E + 1] = NaN;
        continue;
      }
      y[E] = t[E], y[E + 1] = t[E + 1];
    }
    y.set([NaN, NaN, NaN, NaN, (i[0] - a) / h, (i[1] - o) / l, NaN, NaN, NaN, NaN, u, p, NaN, NaN, NaN, NaN, b, v, NaN, NaN, NaN, NaN, (n[0] - a) / h, (n[1] - o) / l], _), _ += 24;
    for (let E = e.length - 6; E >= 6; E -= 6)
      for (let S = 0; S < 6; S += 2) {
        if (isNaN(e[E + S])) {
          y[_] = y[_ + 1] = NaN, _ += 2;
          continue;
        }
        y[_] = e[E + S], y[_ + 1] = e[E + S + 1], _ += 2;
      }
    return y.set([NaN, NaN, NaN, NaN, e[4], e[5]], _), new ba(y, c, r(this, Ye), r(this, _r), r(this, yr), r(this, wr));
  }
};
Ye = new WeakMap(), Cs = new WeakMap(), yr = new WeakMap(), wr = new WeakMap(), Ke = new WeakMap(), V = new WeakMap(), cn = new WeakMap(), dn = new WeakMap(), Mo = new WeakMap(), Io = new WeakMap(), _r = new WeakMap(), Er = new WeakMap(), li = new WeakMap(), Po = new WeakMap(), Hl = new WeakMap(), Bl = new WeakMap(), Do = new WeakSet(), Kd = /* @__PURE__ */ d(function() {
  const t = r(this, V).subarray(4, 6), e = r(this, V).subarray(16, 18), [s, i, n, a] = r(this, Ye);
  return [(r(this, cn) + (t[0] - e[0]) / 2 - s) / n, (r(this, dn) + (t[1] - e[1]) / 2 - i) / a, (r(this, cn) + (e[0] - t[0]) / 2 - s) / n, (r(this, dn) + (e[1] - t[1]) / 2 - i) / a];
}, "#getLastCoords"), d(Be, "FreeOutliner"), A(Be, Po, 8), A(Be, Hl, 2), A(Be, Bl, r(Be, Po) + r(Be, Hl));
let dl = Be;
var Sr, un, xs, Fo, le, No, ut, te, qr, Xr, Dg;
const fp = class fp extends cl {
  constructor(e, s, i, n, a, o) {
    super();
    A(this, te);
    A(this, Sr);
    A(this, un, null);
    A(this, xs);
    A(this, Fo);
    A(this, le);
    A(this, No);
    A(this, ut);
    g(this, ut, e), g(this, le, s), g(this, Sr, i), g(this, No, n), g(this, xs, a), g(this, Fo, o), m(this, te, Dg).call(this, o);
    const {
      x: h,
      y: l,
      width: c,
      height: u
    } = r(this, un);
    for (let p = 0, b = e.length; p < b; p += 2)
      e[p] = (e[p] - h) / c, e[p + 1] = (e[p + 1] - l) / u;
    for (let p = 0, b = s.length; p < b; p += 2)
      s[p] = (s[p] - h) / c, s[p + 1] = (s[p + 1] - l) / u;
  }
  toSVGPath() {
    const e = [`M${r(this, ut)[4]} ${r(this, ut)[5]}`];
    for (let s = 6, i = r(this, ut).length; s < i; s += 6) {
      if (isNaN(r(this, ut)[s])) {
        e.push(`L${r(this, ut)[s + 4]} ${r(this, ut)[s + 5]}`);
        continue;
      }
      e.push(`C${r(this, ut)[s]} ${r(this, ut)[s + 1]} ${r(this, ut)[s + 2]} ${r(this, ut)[s + 3]} ${r(this, ut)[s + 4]} ${r(this, ut)[s + 5]}`);
    }
    return e.push("Z"), e.join(" ");
  }
  serialize([e, s, i, n], a) {
    const o = i - e, h = n - s;
    let l, c;
    switch (a) {
      case 0:
        l = m(this, te, qr).call(this, r(this, ut), e, n, o, -h), c = m(this, te, qr).call(this, r(this, le), e, n, o, -h);
        break;
      case 90:
        l = m(this, te, Xr).call(this, r(this, ut), e, s, o, h), c = m(this, te, Xr).call(this, r(this, le), e, s, o, h);
        break;
      case 180:
        l = m(this, te, qr).call(this, r(this, ut), i, s, -o, h), c = m(this, te, qr).call(this, r(this, le), i, s, -o, h);
        break;
      case 270:
        l = m(this, te, Xr).call(this, r(this, ut), i, n, -o, -h), c = m(this, te, Xr).call(this, r(this, le), i, n, -o, -h);
        break;
    }
    return {
      outline: Array.from(l),
      points: [Array.from(c)]
    };
  }
  get box() {
    return r(this, un);
  }
  getNewOutline(e, s) {
    const {
      x: i,
      y: n,
      width: a,
      height: o
    } = r(this, un), [h, l, c, u] = r(this, Sr), p = a * c, b = o * u, v = i * c + h, y = n * u + l, _ = new dl({
      x: r(this, le)[0] * p + v,
      y: r(this, le)[1] * b + y
    }, r(this, Sr), r(this, No), e, r(this, Fo), s ?? r(this, xs));
    for (let w = 2; w < r(this, le).length; w += 2)
      _.add({
        x: r(this, le)[w] * p + v,
        y: r(this, le)[w + 1] * b + y
      });
    return _.getOutlines();
  }
};
Sr = new WeakMap(), un = new WeakMap(), xs = new WeakMap(), Fo = new WeakMap(), le = new WeakMap(), No = new WeakMap(), ut = new WeakMap(), te = new WeakSet(), qr = /* @__PURE__ */ d(function(e, s, i, n, a) {
  const o = new Float64Array(e.length);
  for (let h = 0, l = e.length; h < l; h += 2)
    o[h] = s + e[h] * n, o[h + 1] = i + e[h + 1] * a;
  return o;
}, "#rescale"), Xr = /* @__PURE__ */ d(function(e, s, i, n, a) {
  const o = new Float64Array(e.length);
  for (let h = 0, l = e.length; h < l; h += 2)
    o[h] = s + e[h + 1] * n, o[h + 1] = i + e[h] * a;
  return o;
}, "#rescaleAndSwap"), Dg = /* @__PURE__ */ d(function(e) {
  const s = r(this, ut);
  let i = s[4], n = s[5], a = i, o = n, h = i, l = n, c = i, u = n;
  const p = e ? Math.max : Math.min;
  for (let w = 6, E = s.length; w < E; w += 6) {
    if (isNaN(s[w]))
      a = Math.min(a, s[w + 4]), o = Math.min(o, s[w + 5]), h = Math.max(h, s[w + 4]), l = Math.max(l, s[w + 5]), u < s[w + 5] ? (c = s[w + 4], u = s[w + 5]) : u === s[w + 5] && (c = p(c, s[w + 4]));
    else {
      const S = I.bezierBoundingBox(i, n, ...s.slice(w, w + 6));
      a = Math.min(a, S[0]), o = Math.min(o, S[1]), h = Math.max(h, S[2]), l = Math.max(l, S[3]), u < S[3] ? (c = S[2], u = S[3]) : u === S[3] && (c = p(c, S[2]));
    }
    i = s[w + 4], n = s[w + 5];
  }
  const b = a - r(this, xs), v = o - r(this, xs), y = h - a + 2 * r(this, xs), _ = l - o + 2 * r(this, xs);
  g(this, un, {
    x: b,
    y: v,
    width: y,
    height: _,
    lastPoint: [c, u]
  });
}, "#computeMinMax"), d(fp, "FreeHighlightOutline");
let ba = fp;
var Oo, Ho, Pe, fn, Cr, vt, Bo, xr, Uo, zo, De, Tr, nt, Qd, Jd, Fg, Ei, Ng, Gs;
const Ue = class Ue {
  constructor({
    editor: t = null,
    uiManager: e = null
  }) {
    A(this, nt);
    A(this, Oo, m(this, nt, Fg).bind(this));
    A(this, Ho, m(this, nt, Ng).bind(this));
    A(this, Pe, null);
    A(this, fn, null);
    A(this, Cr);
    A(this, vt, null);
    A(this, Bo, !1);
    A(this, xr, !1);
    A(this, Uo, null);
    A(this, zo);
    A(this, De, null);
    A(this, Tr);
    var s;
    t ? (g(this, xr, !1), g(this, Tr, N.HIGHLIGHT_COLOR), g(this, Uo, t)) : (g(this, xr, !0), g(this, Tr, N.HIGHLIGHT_DEFAULT_COLOR)), g(this, De, (t == null ? void 0 : t._uiManager) || e), g(this, zo, r(this, De)._eventBus), g(this, Cr, (t == null ? void 0 : t.color) || ((s = r(this, De)) == null ? void 0 : s.highlightColors.values().next().value) || "#FFFF98");
  }
  static get _keyboardManager() {
    return X(this, "_keyboardManager", new Tn([[["Escape", "mac+Escape"], Ue.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], Ue.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], Ue.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], Ue.prototype._moveToPrevious], [["Home", "mac+Home"], Ue.prototype._moveToBeginning], [["End", "mac+End"], Ue.prototype._moveToEnd]]));
  }
  renderButton() {
    const t = g(this, Pe, document.createElement("button"));
    t.className = "colorPicker", t.tabIndex = "0", t.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button"), t.setAttribute("aria-haspopup", !0);
    const e = r(this, De)._signal;
    t.addEventListener("click", m(this, nt, Ei).bind(this), {
      signal: e
    }), t.addEventListener("keydown", r(this, Oo), {
      signal: e
    });
    const s = g(this, fn, document.createElement("span"));
    return s.className = "swatch", s.setAttribute("aria-hidden", !0), s.style.backgroundColor = r(this, Cr), t.append(s), t;
  }
  renderMainDropdown() {
    const t = g(this, vt, m(this, nt, Qd).call(this));
    return t.setAttribute("aria-orientation", "horizontal"), t.setAttribute("aria-labelledby", "highlightColorPickerLabel"), t;
  }
  _colorSelectFromKeyboard(t) {
    if (t.target === r(this, Pe)) {
      m(this, nt, Ei).call(this, t);
      return;
    }
    const e = t.target.getAttribute("data-color");
    e && m(this, nt, Jd).call(this, e, t);
  }
  _moveToNext(t) {
    var e, s;
    if (!r(this, nt, Gs)) {
      m(this, nt, Ei).call(this, t);
      return;
    }
    if (t.target === r(this, Pe)) {
      (e = r(this, vt).firstChild) == null || e.focus();
      return;
    }
    (s = t.target.nextSibling) == null || s.focus();
  }
  _moveToPrevious(t) {
    var e, s;
    if (t.target === ((e = r(this, vt)) == null ? void 0 : e.firstChild) || t.target === r(this, Pe)) {
      r(this, nt, Gs) && this._hideDropdownFromKeyboard();
      return;
    }
    r(this, nt, Gs) || m(this, nt, Ei).call(this, t), (s = t.target.previousSibling) == null || s.focus();
  }
  _moveToBeginning(t) {
    var e;
    if (!r(this, nt, Gs)) {
      m(this, nt, Ei).call(this, t);
      return;
    }
    (e = r(this, vt).firstChild) == null || e.focus();
  }
  _moveToEnd(t) {
    var e;
    if (!r(this, nt, Gs)) {
      m(this, nt, Ei).call(this, t);
      return;
    }
    (e = r(this, vt).lastChild) == null || e.focus();
  }
  hideDropdown() {
    var t;
    (t = r(this, vt)) == null || t.classList.add("hidden"), window.removeEventListener("pointerdown", r(this, Ho));
  }
  _hideDropdownFromKeyboard() {
    var t;
    if (!r(this, xr)) {
      if (!r(this, nt, Gs)) {
        (t = r(this, Uo)) == null || t.unselect();
        return;
      }
      this.hideDropdown(), r(this, Pe).focus({
        preventScroll: !0,
        focusVisible: r(this, Bo)
      });
    }
  }
  updateColor(t) {
    if (r(this, fn) && (r(this, fn).style.backgroundColor = t), !r(this, vt))
      return;
    const e = r(this, De).highlightColors.values();
    for (const s of r(this, vt).children)
      s.setAttribute("aria-selected", e.next().value === t);
  }
  destroy() {
    var t, e;
    (t = r(this, Pe)) == null || t.remove(), g(this, Pe, null), g(this, fn, null), (e = r(this, vt)) == null || e.remove(), g(this, vt, null);
  }
};
Oo = new WeakMap(), Ho = new WeakMap(), Pe = new WeakMap(), fn = new WeakMap(), Cr = new WeakMap(), vt = new WeakMap(), Bo = new WeakMap(), xr = new WeakMap(), Uo = new WeakMap(), zo = new WeakMap(), De = new WeakMap(), Tr = new WeakMap(), nt = new WeakSet(), Qd = /* @__PURE__ */ d(function() {
  const t = document.createElement("div"), e = r(this, De)._signal;
  t.addEventListener("contextmenu", ee, {
    signal: e
  }), t.className = "dropdown", t.role = "listbox", t.setAttribute("aria-multiselectable", !1), t.setAttribute("aria-orientation", "vertical"), t.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
  for (const [s, i] of r(this, De).highlightColors) {
    const n = document.createElement("button");
    n.tabIndex = "0", n.role = "option", n.setAttribute("data-color", i), n.title = s, n.setAttribute("data-l10n-id", `pdfjs-editor-colorpicker-${s}`);
    const a = document.createElement("span");
    n.append(a), a.className = "swatch", a.style.backgroundColor = i, n.setAttribute("aria-selected", i === r(this, Cr)), n.addEventListener("click", m(this, nt, Jd).bind(this, i), {
      signal: e
    }), t.append(n);
  }
  return t.addEventListener("keydown", r(this, Oo), {
    signal: e
  }), t;
}, "#getDropdownRoot"), Jd = /* @__PURE__ */ d(function(t, e) {
  e.stopPropagation(), r(this, zo).dispatch("switchannotationeditorparams", {
    source: this,
    type: r(this, Tr),
    value: t
  });
}, "#colorSelect"), Fg = /* @__PURE__ */ d(function(t) {
  Ue._keyboardManager.exec(this, t);
}, "#keyDown"), Ei = /* @__PURE__ */ d(function(t) {
  if (r(this, nt, Gs)) {
    this.hideDropdown();
    return;
  }
  if (g(this, Bo, t.detail === 0), window.addEventListener("pointerdown", r(this, Ho), {
    signal: r(this, De)._signal
  }), r(this, vt)) {
    r(this, vt).classList.remove("hidden");
    return;
  }
  const e = g(this, vt, m(this, nt, Qd).call(this));
  r(this, Pe).append(e);
}, "#openDropdown"), Ng = /* @__PURE__ */ d(function(t) {
  var e;
  (e = r(this, vt)) != null && e.contains(t.target) || this.hideDropdown();
}, "#pointerDown"), Gs = /* @__PURE__ */ d(function() {
  return r(this, vt) && !r(this, vt).classList.contains("hidden");
}, "#isDropdownVisible"), d(Ue, "ColorPicker");
let ul = Ue;
var Lr, $o, ci, pn, Rr, Ae, jo, Wo, gn, Fe, Gt, ce, Ul, kr, mn, yt, Mr, Qe, Vo, W, Zd, tu, Og, Hg, Bg, eu, Yr, we, On, Ug, Th, Kr, zg, $g, jg, Wg;
const K = class K extends Q {
  constructor(e) {
    super({
      ...e,
      name: "highlightEditor"
    });
    A(this, W);
    A(this, Lr, null);
    A(this, $o, 0);
    A(this, ci);
    A(this, pn, null);
    A(this, Rr, null);
    A(this, Ae, null);
    A(this, jo, null);
    A(this, Wo, 0);
    A(this, gn, null);
    A(this, Fe, null);
    A(this, Gt, null);
    A(this, ce, !1);
    A(this, Ul, m(this, W, Ug).bind(this));
    A(this, kr, null);
    A(this, mn);
    A(this, yt, null);
    A(this, Mr, "");
    A(this, Qe);
    A(this, Vo, "");
    this.color = e.color || K._defaultColor, g(this, Qe, e.thickness || K._defaultThickness), g(this, mn, e.opacity || K._defaultOpacity), g(this, ci, e.boxes || null), g(this, Vo, e.methodOfCreation || ""), g(this, Mr, e.text || ""), this._isDraggable = !1, e.highlightId > -1 ? (g(this, ce, !0), m(this, W, tu).call(this, e), m(this, W, Yr).call(this)) : (g(this, Lr, e.anchorNode), g(this, $o, e.anchorOffset), g(this, jo, e.focusNode), g(this, Wo, e.focusOffset), m(this, W, Zd).call(this), m(this, W, Yr).call(this), this.rotate(this.rotation));
  }
  static get _keyboardManager() {
    const e = K.prototype;
    return X(this, "_keyboardManager", new Tn([[["ArrowLeft", "mac+ArrowLeft"], e._moveCaret, {
      args: [0]
    }], [["ArrowRight", "mac+ArrowRight"], e._moveCaret, {
      args: [1]
    }], [["ArrowUp", "mac+ArrowUp"], e._moveCaret, {
      args: [2]
    }], [["ArrowDown", "mac+ArrowDown"], e._moveCaret, {
      args: [3]
    }]]));
  }
  get telemetryInitialData() {
    return {
      action: "added",
      type: r(this, ce) ? "free_highlight" : "highlight",
      color: this._uiManager.highlightColorNames.get(this.color),
      thickness: r(this, Qe),
      methodOfCreation: r(this, Vo)
    };
  }
  get telemetryFinalData() {
    return {
      type: "highlight",
      color: this._uiManager.highlightColorNames.get(this.color)
    };
  }
  static computeTelemetryFinalData(e) {
    return {
      numberOfColors: e.get("color").size
    };
  }
  static initialize(e, s) {
    var i;
    Q.initialize(e, s), K._defaultColor || (K._defaultColor = ((i = s.highlightColors) == null ? void 0 : i.values().next().value) || "#fff066");
  }
  static updateDefaultParams(e, s) {
    switch (e) {
      case N.HIGHLIGHT_DEFAULT_COLOR:
        K._defaultColor = s;
        break;
      case N.HIGHLIGHT_THICKNESS:
        K._defaultThickness = s;
        break;
    }
  }
  translateInPage(e, s) {
  }
  get toolbarPosition() {
    return r(this, kr);
  }
  updateParams(e, s) {
    switch (e) {
      case N.HIGHLIGHT_COLOR:
        m(this, W, Og).call(this, s);
        break;
      case N.HIGHLIGHT_THICKNESS:
        m(this, W, Hg).call(this, s);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[N.HIGHLIGHT_DEFAULT_COLOR, K._defaultColor], [N.HIGHLIGHT_THICKNESS, K._defaultThickness]];
  }
  get propertiesToUpdate() {
    return [[N.HIGHLIGHT_COLOR, this.color || K._defaultColor], [N.HIGHLIGHT_THICKNESS, r(this, Qe) || K._defaultThickness], [N.HIGHLIGHT_FREE, r(this, ce)]];
  }
  async addEditToolbar() {
    const e = await super.addEditToolbar();
    return e ? (this._uiManager.highlightColors && (g(this, Rr, new ul({
      editor: this
    })), e.addColorPicker(r(this, Rr))), e) : null;
  }
  disableEditing() {
    super.disableEditing(), this.div.classList.toggle("disabled", !0);
  }
  enableEditing() {
    super.enableEditing(), this.div.classList.toggle("disabled", !1);
  }
  fixAndSetPosition() {
    return super.fixAndSetPosition(m(this, W, Kr).call(this));
  }
  getBaseTranslation() {
    return [0, 0];
  }
  getRect(e, s) {
    return super.getRect(e, s, m(this, W, Kr).call(this));
  }
  onceAdded() {
    this.parent.addUndoableEditor(this), this.div.focus();
  }
  remove() {
    m(this, W, eu).call(this), this._reportTelemetry({
      action: "deleted"
    }), super.remove();
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (m(this, W, Yr).call(this), this.isAttachedToDOM || this.parent.add(this)));
  }
  setParent(e) {
    var i;
    let s = !1;
    this.parent && !e ? m(this, W, eu).call(this) : e && (m(this, W, Yr).call(this, e), s = !this.parent && ((i = this.div) == null ? void 0 : i.classList.contains("selectedEditor"))), super.setParent(e), this.show(this._isVisible), s && this.select();
  }
  rotate(e) {
    var n, a, o;
    const {
      drawLayer: s
    } = this.parent;
    let i;
    r(this, ce) ? (e = (e - this.rotation + 360) % 360, i = m(n = K, we, On).call(n, r(this, Fe).box, e)) : i = m(a = K, we, On).call(a, this, e), s.rotate(r(this, Gt), e), s.rotate(r(this, yt), e), s.updateBox(r(this, Gt), i), s.updateBox(r(this, yt), m(o = K, we, On).call(o, r(this, Ae).box, e));
  }
  render() {
    if (this.div)
      return this.div;
    const e = super.render();
    r(this, Mr) && (e.setAttribute("aria-label", r(this, Mr)), e.setAttribute("role", "mark")), r(this, ce) ? e.classList.add("free") : this.div.addEventListener("keydown", r(this, Ul), {
      signal: this._uiManager._signal
    });
    const s = g(this, gn, document.createElement("div"));
    e.append(s), s.setAttribute("aria-hidden", "true"), s.className = "internal", s.style.clipPath = r(this, pn);
    const [i, n] = this.parentDimensions;
    return this.setDims(this.width * i, this.height * n), Wh(this, r(this, gn), ["pointerover", "pointerleave"]), this.enableEditing(), e;
  }
  pointerover() {
    this.parent.drawLayer.addClass(r(this, yt), "hovered");
  }
  pointerleave() {
    this.parent.drawLayer.removeClass(r(this, yt), "hovered");
  }
  _moveCaret(e) {
    switch (this.parent.unselect(this), e) {
      case 0:
      case 2:
        m(this, W, Th).call(this, !0);
        break;
      case 1:
      case 3:
        m(this, W, Th).call(this, !1);
        break;
    }
  }
  select() {
    var e, s;
    super.select(), r(this, yt) && ((e = this.parent) == null || e.drawLayer.removeClass(r(this, yt), "hovered"), (s = this.parent) == null || s.drawLayer.addClass(r(this, yt), "selected"));
  }
  unselect() {
    var e;
    super.unselect(), r(this, yt) && ((e = this.parent) == null || e.drawLayer.removeClass(r(this, yt), "selected"), r(this, ce) || m(this, W, Th).call(this, !1));
  }
  get _mustFixPosition() {
    return !r(this, ce);
  }
  show(e = this._isVisible) {
    super.show(e), this.parent && (this.parent.drawLayer.show(r(this, Gt), e), this.parent.drawLayer.show(r(this, yt), e));
  }
  static startHighlighting(e, s, {
    target: i,
    x: n,
    y: a
  }) {
    const {
      x: o,
      y: h,
      width: l,
      height: c
    } = i.getBoundingClientRect(), u = /* @__PURE__ */ d((_) => {
      m(this, we, jg).call(this, e, _);
    }, "pointerMove"), p = e._signal, b = {
      capture: !0,
      passive: !1,
      signal: p
    }, v = /* @__PURE__ */ d((_) => {
      _.preventDefault(), _.stopPropagation();
    }, "pointerDown"), y = /* @__PURE__ */ d((_) => {
      i.removeEventListener("pointermove", u), window.removeEventListener("blur", y), window.removeEventListener("pointerup", y), window.removeEventListener("pointerdown", v, b), window.removeEventListener("contextmenu", ee), m(this, we, Wg).call(this, e, _);
    }, "pointerUpCallback");
    window.addEventListener("blur", y, {
      signal: p
    }), window.addEventListener("pointerup", y, {
      signal: p
    }), window.addEventListener("pointerdown", v, b), window.addEventListener("contextmenu", ee, {
      signal: p
    }), i.addEventListener("pointermove", u, {
      signal: p
    }), this._freeHighlight = new dl({
      x: n,
      y: a
    }, [o, h, l, c], e.scale, this._defaultThickness / 2, s, 1e-3), {
      id: this._freeHighlightId,
      clipPathId: this._freeHighlightClipId
    } = e.drawLayer.highlight(this._freeHighlight, this._defaultColor, this._defaultOpacity, !0);
  }
  static deserialize(e, s, i) {
    var y;
    const n = super.deserialize(e, s, i), {
      rect: [a, o, h, l],
      color: c,
      quadPoints: u
    } = e;
    n.color = I.makeHexColor(...c), g(n, mn, e.opacity);
    const [p, b] = n.pageDimensions;
    n.width = (h - a) / p, n.height = (l - o) / b;
    const v = g(n, ci, []);
    for (let _ = 0; _ < u.length; _ += 8)
      v.push({
        x: (u[4] - h) / p,
        y: (l - (1 - u[_ + 5])) / b,
        width: (u[_ + 2] - u[_]) / p,
        height: (u[_ + 5] - u[_ + 1]) / b
      });
    return m(y = n, W, Zd).call(y), n;
  }
  serialize(e = !1) {
    if (this.isEmpty() || e)
      return null;
    const s = this.getRect(0, 0), i = Q._colorManager.convert(this.color);
    return {
      annotationType: G.HIGHLIGHT,
      color: i,
      opacity: r(this, mn),
      thickness: r(this, Qe),
      quadPoints: m(this, W, zg).call(this),
      outlines: m(this, W, $g).call(this, s),
      pageIndex: this.pageIndex,
      rect: s,
      rotation: m(this, W, Kr).call(this),
      structTreeParentId: this._structTreeParentId
    };
  }
  static canCreateNewEmptyEditor() {
    return !1;
  }
};
Lr = new WeakMap(), $o = new WeakMap(), ci = new WeakMap(), pn = new WeakMap(), Rr = new WeakMap(), Ae = new WeakMap(), jo = new WeakMap(), Wo = new WeakMap(), gn = new WeakMap(), Fe = new WeakMap(), Gt = new WeakMap(), ce = new WeakMap(), Ul = new WeakMap(), kr = new WeakMap(), mn = new WeakMap(), yt = new WeakMap(), Mr = new WeakMap(), Qe = new WeakMap(), Vo = new WeakMap(), W = new WeakSet(), Zd = /* @__PURE__ */ d(function() {
  const e = new ll(r(this, ci), 1e-3);
  g(this, Fe, e.getOutlines()), {
    x: this.x,
    y: this.y,
    width: this.width,
    height: this.height
  } = r(this, Fe).box;
  const s = new ll(r(this, ci), 25e-4, 1e-3, this._uiManager.direction === "ltr");
  g(this, Ae, s.getOutlines());
  const {
    lastPoint: i
  } = r(this, Ae).box;
  g(this, kr, [(i[0] - this.x) / this.width, (i[1] - this.y) / this.height]);
}, "#createOutlines"), tu = /* @__PURE__ */ d(function({
  highlightOutlines: e,
  highlightId: s,
  clipPathId: i
}) {
  var u, p;
  if (g(this, Fe, e), g(this, Ae, e.getNewOutline(r(this, Qe) / 2 + 1.5, 25e-4)), s >= 0)
    g(this, Gt, s), g(this, pn, i), this.parent.drawLayer.finalizeLine(s, e), g(this, yt, this.parent.drawLayer.highlightOutline(r(this, Ae)));
  else if (this.parent) {
    const b = this.parent.viewport.rotation;
    this.parent.drawLayer.updateLine(r(this, Gt), e), this.parent.drawLayer.updateBox(r(this, Gt), m(u = K, we, On).call(u, r(this, Fe).box, (b - this.rotation + 360) % 360)), this.parent.drawLayer.updateLine(r(this, yt), r(this, Ae)), this.parent.drawLayer.updateBox(r(this, yt), m(p = K, we, On).call(p, r(this, Ae).box, b));
  }
  const {
    x: a,
    y: o,
    width: h,
    height: l
  } = e.box;
  switch (this.rotation) {
    case 0:
      this.x = a, this.y = o, this.width = h, this.height = l;
      break;
    case 90: {
      const [b, v] = this.parentDimensions;
      this.x = o, this.y = 1 - a, this.width = h * v / b, this.height = l * b / v;
      break;
    }
    case 180:
      this.x = 1 - a, this.y = 1 - o, this.width = h, this.height = l;
      break;
    case 270: {
      const [b, v] = this.parentDimensions;
      this.x = 1 - o, this.y = a, this.width = h * v / b, this.height = l * b / v;
      break;
    }
  }
  const {
    lastPoint: c
  } = r(this, Ae).box;
  g(this, kr, [(c[0] - a) / h, (c[1] - o) / l]);
}, "#createFreeOutlines"), Og = /* @__PURE__ */ d(function(e) {
  const s = /* @__PURE__ */ d((n) => {
    var a, o;
    this.color = n, (a = this.parent) == null || a.drawLayer.changeColor(r(this, Gt), n), (o = r(this, Rr)) == null || o.updateColor(n);
  }, "setColor"), i = this.color;
  this.addCommands({
    cmd: s.bind(this, e),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: N.HIGHLIGHT_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  }), this._reportTelemetry({
    action: "color_changed",
    color: this._uiManager.highlightColorNames.get(e)
  }, !0);
}, "#updateColor"), Hg = /* @__PURE__ */ d(function(e) {
  const s = r(this, Qe), i = /* @__PURE__ */ d((n) => {
    g(this, Qe, n), m(this, W, Bg).call(this, n);
  }, "setThickness");
  this.addCommands({
    cmd: i.bind(this, e),
    undo: i.bind(this, s),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: N.INK_THICKNESS,
    overwriteIfSameType: !0,
    keepUndo: !0
  }), this._reportTelemetry({
    action: "thickness_changed",
    thickness: e
  }, !0);
}, "#updateThickness"), Bg = /* @__PURE__ */ d(function(e) {
  if (!r(this, ce))
    return;
  m(this, W, tu).call(this, {
    highlightOutlines: r(this, Fe).getNewOutline(e / 2)
  }), this.fixAndSetPosition();
  const [s, i] = this.parentDimensions;
  this.setDims(this.width * s, this.height * i);
}, "#changeThickness"), eu = /* @__PURE__ */ d(function() {
  r(this, Gt) === null || !this.parent || (this.parent.drawLayer.remove(r(this, Gt)), g(this, Gt, null), this.parent.drawLayer.remove(r(this, yt)), g(this, yt, null));
}, "#cleanDrawLayer"), Yr = /* @__PURE__ */ d(function(e = this.parent) {
  r(this, Gt) === null && ({
    id: se(this, Gt)._,
    clipPathId: se(this, pn)._
  } = e.drawLayer.highlight(r(this, Fe), this.color, r(this, mn)), g(this, yt, e.drawLayer.highlightOutline(r(this, Ae))), r(this, gn) && (r(this, gn).style.clipPath = r(this, pn)));
}, "#addToDrawLayer"), we = new WeakSet(), On = /* @__PURE__ */ d(function({
  x: e,
  y: s,
  width: i,
  height: n
}, a) {
  switch (a) {
    case 90:
      return {
        x: 1 - s - n,
        y: e,
        width: n,
        height: i
      };
    case 180:
      return {
        x: 1 - e - i,
        y: 1 - s - n,
        width: i,
        height: n
      };
    case 270:
      return {
        x: s,
        y: 1 - e - i,
        width: n,
        height: i
      };
  }
  return {
    x: e,
    y: s,
    width: i,
    height: n
  };
}, "#rotateBbox"), Ug = /* @__PURE__ */ d(function(e) {
  K._keyboardManager.exec(this, e);
}, "#keydown"), Th = /* @__PURE__ */ d(function(e) {
  if (!r(this, Lr))
    return;
  const s = window.getSelection();
  e ? s.setPosition(r(this, Lr), r(this, $o)) : s.setPosition(r(this, jo), r(this, Wo));
}, "#setCaret"), Kr = /* @__PURE__ */ d(function() {
  return r(this, ce) ? this.rotation : 0;
}, "#getRotation"), zg = /* @__PURE__ */ d(function() {
  if (r(this, ce))
    return null;
  const [e, s] = this.pageDimensions, [i, n] = this.pageTranslation, a = r(this, ci), o = new Float32Array(a.length * 8);
  let h = 0;
  for (const {
    x: l,
    y: c,
    width: u,
    height: p
  } of a) {
    const b = l * e + i, v = (1 - c - p) * s + n;
    o[h] = o[h + 4] = b, o[h + 1] = o[h + 3] = v, o[h + 2] = o[h + 6] = b + u * e, o[h + 5] = o[h + 7] = v + p * s, h += 8;
  }
  return o;
}, "#serializeBoxes"), $g = /* @__PURE__ */ d(function(e) {
  return r(this, Fe).serialize(e, m(this, W, Kr).call(this));
}, "#serializeOutlines"), jg = /* @__PURE__ */ d(function(e, s) {
  this._freeHighlight.add(s) && e.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
}, "#highlightMove"), Wg = /* @__PURE__ */ d(function(e, s) {
  this._freeHighlight.isEmpty() ? e.drawLayer.removeFreeHighlight(this._freeHighlightId) : e.createAndAddNewEditor(s, !1, {
    highlightId: this._freeHighlightId,
    highlightOutlines: this._freeHighlight.getOutlines(),
    clipPathId: this._freeHighlightClipId,
    methodOfCreation: "main_toolbar"
  }), this._freeHighlightId = -1, this._freeHighlight = null, this._freeHighlightClipId = "";
}, "#endHighlight"), A(K, we), d(K, "HighlightEditor"), U(K, "_defaultColor", null), U(K, "_defaultOpacity", 1), U(K, "_defaultThickness", 12), U(K, "_l10nPromise"), U(K, "_type", "highlight"), U(K, "_editorType", G.HIGHLIGHT), U(K, "_freeHighlightId", -1), U(K, "_freeHighlight", null), U(K, "_freeHighlightClipId", "");
let fl = K;
var bn, An, Go, qo, Xo, vn, Je, Ts, ve, yn, wn, Ls, _n, En, di, R, Vg, Gg, qg, Xg, iu, Yg, nu, Kg, Qg, Jg, Zg, tm, Si, ru, Lh, Rh, Hn, au, kh, $s, em, ou, sm, im, hu, Mh, Qr;
const ot = class ot extends Q {
  constructor(e) {
    super({
      ...e,
      name: "inkEditor"
    });
    A(this, R);
    A(this, bn, 0);
    A(this, An, 0);
    A(this, Go, this.canvasPointermove.bind(this));
    A(this, qo, this.canvasPointerleave.bind(this));
    A(this, Xo, this.canvasPointerup.bind(this));
    A(this, vn, this.canvasPointerdown.bind(this));
    A(this, Je, null);
    A(this, Ts, new Path2D());
    A(this, ve, !1);
    A(this, yn, !1);
    A(this, wn, !1);
    A(this, Ls, null);
    A(this, _n, 0);
    A(this, En, 0);
    A(this, di, null);
    this.color = e.color || null, this.thickness = e.thickness || null, this.opacity = e.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
  }
  static initialize(e, s) {
    Q.initialize(e, s);
  }
  static updateDefaultParams(e, s) {
    switch (e) {
      case N.INK_THICKNESS:
        ot._defaultThickness = s;
        break;
      case N.INK_COLOR:
        ot._defaultColor = s;
        break;
      case N.INK_OPACITY:
        ot._defaultOpacity = s / 100;
        break;
    }
  }
  updateParams(e, s) {
    switch (e) {
      case N.INK_THICKNESS:
        m(this, R, Vg).call(this, s);
        break;
      case N.INK_COLOR:
        m(this, R, Gg).call(this, s);
        break;
      case N.INK_OPACITY:
        m(this, R, qg).call(this, s);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[N.INK_THICKNESS, ot._defaultThickness], [N.INK_COLOR, ot._defaultColor || Q._defaultLineColor], [N.INK_OPACITY, Math.round(ot._defaultOpacity * 100)]];
  }
  get propertiesToUpdate() {
    return [[N.INK_THICKNESS, this.thickness || ot._defaultThickness], [N.INK_COLOR, this.color || ot._defaultColor || Q._defaultLineColor], [N.INK_OPACITY, Math.round(100 * (this.opacity ?? ot._defaultOpacity))]];
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (this.canvas || (m(this, R, Lh).call(this), m(this, R, Rh).call(this)), this.isAttachedToDOM || (this.parent.add(this), m(this, R, Hn).call(this)), m(this, R, Qr).call(this)));
  }
  remove() {
    var e;
    this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, r(this, Je) && (clearTimeout(r(this, Je)), g(this, Je, null)), (e = r(this, Ls)) == null || e.disconnect(), g(this, Ls, null), super.remove());
  }
  setParent(e) {
    !this.parent && e ? this._uiManager.removeShouldRescale(this) : this.parent && e === null && this._uiManager.addShouldRescale(this), super.setParent(e);
  }
  onScaleChanging() {
    const [e, s] = this.parentDimensions, i = this.width * e, n = this.height * s;
    this.setDimensions(i, n);
  }
  enableEditMode() {
    r(this, ve) || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, this.canvas.addEventListener("pointerdown", r(this, vn), {
      signal: this._uiManager._signal
    }));
  }
  disableEditMode() {
    !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", r(this, vn)));
  }
  onceAdded() {
    this._isDraggable = !this.isEmpty();
  }
  isEmpty() {
    return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
  }
  commit() {
    r(this, ve) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), g(this, ve, !0), this.div.classList.add("disabled"), m(this, R, Qr).call(this, !0), this.select(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({
      preventScroll: !0
    }));
  }
  focusin(e) {
    this._focusEventsAllowed && (super.focusin(e), this.enableEditMode());
  }
  canvasPointerdown(e) {
    e.button !== 0 || !this.isInEditMode() || r(this, ve) || (this.setInForeground(), e.preventDefault(), this.div.contains(document.activeElement) || this.div.focus({
      preventScroll: !0
    }), m(this, R, Yg).call(this, e.offsetX, e.offsetY));
  }
  canvasPointermove(e) {
    e.preventDefault(), m(this, R, nu).call(this, e.offsetX, e.offsetY);
  }
  canvasPointerup(e) {
    e.preventDefault(), m(this, R, ru).call(this, e);
  }
  canvasPointerleave(e) {
    m(this, R, ru).call(this, e);
  }
  get isResizable() {
    return !this.isEmpty() && r(this, ve);
  }
  render() {
    if (this.div)
      return this.div;
    let e, s;
    this.width && (e = this.x, s = this.y), super.render(), this.div.setAttribute("data-l10n-id", "pdfjs-ink");
    const [i, n, a, o] = m(this, R, Xg).call(this);
    if (this.setAt(i, n, 0, 0), this.setDims(a, o), m(this, R, Lh).call(this), this.width) {
      const [h, l] = this.parentDimensions;
      this.setAspectRatio(this.width * h, this.height * l), this.setAt(e * h, s * l, this.width * h, this.height * l), g(this, wn, !0), m(this, R, Hn).call(this), this.setDims(this.width * h, this.height * l), m(this, R, Si).call(this), this.div.classList.add("disabled");
    } else
      this.div.classList.add("editing"), this.enableEditMode();
    return m(this, R, Rh).call(this), this.div;
  }
  setDimensions(e, s) {
    const i = Math.round(e), n = Math.round(s);
    if (r(this, _n) === i && r(this, En) === n)
      return;
    g(this, _n, i), g(this, En, n), this.canvas.style.visibility = "hidden";
    const [a, o] = this.parentDimensions;
    this.width = e / a, this.height = s / o, this.fixAndSetPosition(), r(this, ve) && m(this, R, au).call(this, e, s), m(this, R, Hn).call(this), m(this, R, Si).call(this), this.canvas.style.visibility = "visible", this.fixDims();
  }
  static deserialize(e, s, i) {
    var _, w, E;
    if (e instanceof ol)
      return null;
    const n = super.deserialize(e, s, i);
    n.thickness = e.thickness, n.color = I.makeHexColor(...e.color), n.opacity = e.opacity;
    const [a, o] = n.pageDimensions, h = n.width * a, l = n.height * o, c = n.parentScale, u = e.thickness / 2;
    g(n, ve, !0), g(n, _n, Math.round(h)), g(n, En, Math.round(l));
    const {
      paths: p,
      rect: b,
      rotation: v
    } = e;
    for (let {
      bezier: S
    } of p) {
      S = m(_ = ot, $s, sm).call(_, S, b, v);
      const C = [];
      n.paths.push(C);
      let T = c * (S[0] - u), x = c * (S[1] - u);
      for (let P = 2, O = S.length; P < O; P += 6) {
        const q = c * (S[P] - u), F = c * (S[P + 1] - u), ht = c * (S[P + 2] - u), rt = c * (S[P + 3] - u), at = c * (S[P + 4] - u), lt = c * (S[P + 5] - u);
        C.push([[T, x], [q, F], [ht, rt], [at, lt]]), T = at, x = lt;
      }
      const k = m(this, $s, em).call(this, C);
      n.bezierPath2D.push(k);
    }
    const y = m(w = n, R, hu).call(w);
    return g(n, An, Math.max(Q.MIN_SIZE, y[2] - y[0])), g(n, bn, Math.max(Q.MIN_SIZE, y[3] - y[1])), m(E = n, R, au).call(E, h, l), n;
  }
  serialize() {
    if (this.isEmpty())
      return null;
    const e = this.getRect(0, 0), s = Q._colorManager.convert(this.ctx.strokeStyle);
    return {
      annotationType: G.INK,
      color: s,
      thickness: this.thickness,
      opacity: this.opacity,
      paths: m(this, R, im).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, e),
      pageIndex: this.pageIndex,
      rect: e,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
  }
};
bn = new WeakMap(), An = new WeakMap(), Go = new WeakMap(), qo = new WeakMap(), Xo = new WeakMap(), vn = new WeakMap(), Je = new WeakMap(), Ts = new WeakMap(), ve = new WeakMap(), yn = new WeakMap(), wn = new WeakMap(), Ls = new WeakMap(), _n = new WeakMap(), En = new WeakMap(), di = new WeakMap(), R = new WeakSet(), Vg = /* @__PURE__ */ d(function(e) {
  const s = /* @__PURE__ */ d((n) => {
    this.thickness = n, m(this, R, Qr).call(this);
  }, "setThickness"), i = this.thickness;
  this.addCommands({
    cmd: s.bind(this, e),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: N.INK_THICKNESS,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, "#updateThickness"), Gg = /* @__PURE__ */ d(function(e) {
  const s = /* @__PURE__ */ d((n) => {
    this.color = n, m(this, R, Si).call(this);
  }, "setColor"), i = this.color;
  this.addCommands({
    cmd: s.bind(this, e),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: N.INK_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, "#updateColor"), qg = /* @__PURE__ */ d(function(e) {
  const s = /* @__PURE__ */ d((n) => {
    this.opacity = n, m(this, R, Si).call(this);
  }, "setOpacity");
  e /= 100;
  const i = this.opacity;
  this.addCommands({
    cmd: s.bind(this, e),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: N.INK_OPACITY,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, "#updateOpacity"), Xg = /* @__PURE__ */ d(function() {
  const {
    parentRotation: e,
    parentDimensions: [s, i]
  } = this;
  switch (e) {
    case 90:
      return [0, i, i, s];
    case 180:
      return [s, i, s, i];
    case 270:
      return [s, 0, i, s];
    default:
      return [0, 0, s, i];
  }
}, "#getInitialBBox"), iu = /* @__PURE__ */ d(function() {
  const {
    ctx: e,
    color: s,
    opacity: i,
    thickness: n,
    parentScale: a,
    scaleFactor: o
  } = this;
  e.lineWidth = n * a / o, e.lineCap = "round", e.lineJoin = "round", e.miterLimit = 10, e.strokeStyle = `${s}${Rm(i)}`;
}, "#setStroke"), Yg = /* @__PURE__ */ d(function(e, s) {
  const i = this._uiManager._signal;
  this.canvas.addEventListener("contextmenu", ee, {
    signal: i
  }), this.canvas.addEventListener("pointerleave", r(this, qo), {
    signal: i
  }), this.canvas.addEventListener("pointermove", r(this, Go), {
    signal: i
  }), this.canvas.addEventListener("pointerup", r(this, Xo), {
    signal: i
  }), this.canvas.removeEventListener("pointerdown", r(this, vn)), this.isEditing = !0, r(this, wn) || (g(this, wn, !0), m(this, R, Hn).call(this), this.thickness || (this.thickness = ot._defaultThickness), this.color || (this.color = ot._defaultColor || Q._defaultLineColor), this.opacity ?? (this.opacity = ot._defaultOpacity)), this.currentPath.push([e, s]), g(this, yn, !1), m(this, R, iu).call(this), g(this, di, () => {
    m(this, R, Jg).call(this), r(this, di) && window.requestAnimationFrame(r(this, di));
  }), window.requestAnimationFrame(r(this, di));
}, "#startDrawing"), nu = /* @__PURE__ */ d(function(e, s) {
  const [i, n] = this.currentPath.at(-1);
  if (this.currentPath.length > 1 && e === i && s === n)
    return;
  const a = this.currentPath;
  let o = r(this, Ts);
  if (a.push([e, s]), g(this, yn, !0), a.length <= 2) {
    o.moveTo(...a[0]), o.lineTo(e, s);
    return;
  }
  a.length === 3 && (g(this, Ts, o = new Path2D()), o.moveTo(...a[0])), m(this, R, Zg).call(this, o, ...a.at(-3), ...a.at(-2), e, s);
}, "#draw"), Kg = /* @__PURE__ */ d(function() {
  if (this.currentPath.length === 0)
    return;
  const e = this.currentPath.at(-1);
  r(this, Ts).lineTo(...e);
}, "#endPath"), Qg = /* @__PURE__ */ d(function(e, s) {
  g(this, di, null), e = Math.min(Math.max(e, 0), this.canvas.width), s = Math.min(Math.max(s, 0), this.canvas.height), m(this, R, nu).call(this, e, s), m(this, R, Kg).call(this);
  let i;
  if (this.currentPath.length !== 1)
    i = m(this, R, tm).call(this);
  else {
    const l = [e, s];
    i = [[l, l.slice(), l.slice(), l]];
  }
  const n = r(this, Ts), a = this.currentPath;
  this.currentPath = [], g(this, Ts, new Path2D());
  const o = /* @__PURE__ */ d(() => {
    this.allRawPaths.push(a), this.paths.push(i), this.bezierPath2D.push(n), this._uiManager.rebuild(this);
  }, "cmd"), h = /* @__PURE__ */ d(() => {
    this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (m(this, R, Lh).call(this), m(this, R, Rh).call(this)), m(this, R, Qr).call(this));
  }, "undo");
  this.addCommands({
    cmd: o,
    undo: h,
    mustExec: !0
  });
}, "#stopDrawing"), Jg = /* @__PURE__ */ d(function() {
  if (!r(this, yn))
    return;
  g(this, yn, !1);
  const e = Math.ceil(this.thickness * this.parentScale), s = this.currentPath.slice(-3), i = s.map((o) => o[0]), n = s.map((o) => o[1]);
  Math.min(...i) - e, Math.max(...i) + e, Math.min(...n) - e, Math.max(...n) + e;
  const {
    ctx: a
  } = this;
  a.save(), a.clearRect(0, 0, this.canvas.width, this.canvas.height);
  for (const o of this.bezierPath2D)
    a.stroke(o);
  a.stroke(r(this, Ts)), a.restore();
}, "#drawPoints"), Zg = /* @__PURE__ */ d(function(e, s, i, n, a, o, h) {
  const l = (s + n) / 2, c = (i + a) / 2, u = (n + o) / 2, p = (a + h) / 2;
  e.bezierCurveTo(l + 2 * (n - l) / 3, c + 2 * (a - c) / 3, u + 2 * (n - u) / 3, p + 2 * (a - p) / 3, u, p);
}, "#makeBezierCurve"), tm = /* @__PURE__ */ d(function() {
  const e = this.currentPath;
  if (e.length <= 2)
    return [[e[0], e[0], e.at(-1), e.at(-1)]];
  const s = [];
  let i, [n, a] = e[0];
  for (i = 1; i < e.length - 2; i++) {
    const [b, v] = e[i], [y, _] = e[i + 1], w = (b + y) / 2, E = (v + _) / 2, S = [n + 2 * (b - n) / 3, a + 2 * (v - a) / 3], C = [w + 2 * (b - w) / 3, E + 2 * (v - E) / 3];
    s.push([[n, a], S, C, [w, E]]), [n, a] = [w, E];
  }
  const [o, h] = e[i], [l, c] = e[i + 1], u = [n + 2 * (o - n) / 3, a + 2 * (h - a) / 3], p = [l + 2 * (o - l) / 3, c + 2 * (h - c) / 3];
  return s.push([[n, a], u, p, [l, c]]), s;
}, "#generateBezierPoints"), Si = /* @__PURE__ */ d(function() {
  if (this.isEmpty()) {
    m(this, R, kh).call(this);
    return;
  }
  m(this, R, iu).call(this);
  const {
    canvas: e,
    ctx: s
  } = this;
  s.setTransform(1, 0, 0, 1, 0, 0), s.clearRect(0, 0, e.width, e.height), m(this, R, kh).call(this);
  for (const i of this.bezierPath2D)
    s.stroke(i);
}, "#redraw"), ru = /* @__PURE__ */ d(function(e) {
  this.canvas.removeEventListener("pointerleave", r(this, qo)), this.canvas.removeEventListener("pointermove", r(this, Go)), this.canvas.removeEventListener("pointerup", r(this, Xo)), this.canvas.addEventListener("pointerdown", r(this, vn), {
    signal: this._uiManager._signal
  }), r(this, Je) && clearTimeout(r(this, Je)), g(this, Je, setTimeout(() => {
    g(this, Je, null), this.canvas.removeEventListener("contextmenu", ee);
  }, 10)), m(this, R, Qg).call(this, e.offsetX, e.offsetY), this.addToAnnotationStorage(), this.setInBackground();
}, "#endDrawing"), Lh = /* @__PURE__ */ d(function() {
  this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", this.canvas.setAttribute("data-l10n-id", "pdfjs-ink-canvas"), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
}, "#createCanvas"), Rh = /* @__PURE__ */ d(function() {
  g(this, Ls, new ResizeObserver((e) => {
    const s = e[0].contentRect;
    s.width && s.height && this.setDimensions(s.width, s.height);
  })), r(this, Ls).observe(this.div), this._uiManager._signal.addEventListener("abort", () => {
    var e;
    (e = r(this, Ls)) == null || e.disconnect(), g(this, Ls, null);
  }, {
    once: !0
  });
}, "#createObserver"), Hn = /* @__PURE__ */ d(function() {
  if (!r(this, wn))
    return;
  const [e, s] = this.parentDimensions;
  this.canvas.width = Math.ceil(this.width * e), this.canvas.height = Math.ceil(this.height * s), m(this, R, kh).call(this);
}, "#setCanvasDims"), au = /* @__PURE__ */ d(function(e, s) {
  const i = m(this, R, Mh).call(this), n = (e - i) / r(this, An), a = (s - i) / r(this, bn);
  this.scaleFactor = Math.min(n, a);
}, "#setScaleFactor"), kh = /* @__PURE__ */ d(function() {
  const e = m(this, R, Mh).call(this) / 2;
  this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + e, this.translationY * this.scaleFactor + e);
}, "#updateTransform"), $s = new WeakSet(), em = /* @__PURE__ */ d(function(e) {
  const s = new Path2D();
  for (let i = 0, n = e.length; i < n; i++) {
    const [a, o, h, l] = e[i];
    i === 0 && s.moveTo(...a), s.bezierCurveTo(o[0], o[1], h[0], h[1], l[0], l[1]);
  }
  return s;
}, "#buildPath2D"), ou = /* @__PURE__ */ d(function(e, s, i) {
  const [n, a, o, h] = s;
  switch (i) {
    case 0:
      for (let l = 0, c = e.length; l < c; l += 2)
        e[l] += n, e[l + 1] = h - e[l + 1];
      break;
    case 90:
      for (let l = 0, c = e.length; l < c; l += 2) {
        const u = e[l];
        e[l] = e[l + 1] + n, e[l + 1] = u + a;
      }
      break;
    case 180:
      for (let l = 0, c = e.length; l < c; l += 2)
        e[l] = o - e[l], e[l + 1] += a;
      break;
    case 270:
      for (let l = 0, c = e.length; l < c; l += 2) {
        const u = e[l];
        e[l] = o - e[l + 1], e[l + 1] = h - u;
      }
      break;
    default:
      throw new Error("Invalid rotation");
  }
  return e;
}, "#toPDFCoordinates"), sm = /* @__PURE__ */ d(function(e, s, i) {
  const [n, a, o, h] = s;
  switch (i) {
    case 0:
      for (let l = 0, c = e.length; l < c; l += 2)
        e[l] -= n, e[l + 1] = h - e[l + 1];
      break;
    case 90:
      for (let l = 0, c = e.length; l < c; l += 2) {
        const u = e[l];
        e[l] = e[l + 1] - a, e[l + 1] = u - n;
      }
      break;
    case 180:
      for (let l = 0, c = e.length; l < c; l += 2)
        e[l] = o - e[l], e[l + 1] -= a;
      break;
    case 270:
      for (let l = 0, c = e.length; l < c; l += 2) {
        const u = e[l];
        e[l] = h - e[l + 1], e[l + 1] = o - u;
      }
      break;
    default:
      throw new Error("Invalid rotation");
  }
  return e;
}, "#fromPDFCoordinates"), im = /* @__PURE__ */ d(function(e, s, i, n) {
  var c, u;
  const a = [], o = this.thickness / 2, h = e * s + o, l = e * i + o;
  for (const p of this.paths) {
    const b = [], v = [];
    for (let y = 0, _ = p.length; y < _; y++) {
      const [w, E, S, C] = p[y];
      if (w[0] === C[0] && w[1] === C[1] && _ === 1) {
        const rt = e * w[0] + h, at = e * w[1] + l;
        b.push(rt, at), v.push(rt, at);
        break;
      }
      const T = e * w[0] + h, x = e * w[1] + l, k = e * E[0] + h, P = e * E[1] + l, O = e * S[0] + h, q = e * S[1] + l, F = e * C[0] + h, ht = e * C[1] + l;
      y === 0 && (b.push(T, x), v.push(T, x)), b.push(k, P, O, q, F, ht), v.push(k, P), y === _ - 1 && v.push(F, ht);
    }
    a.push({
      bezier: m(c = ot, $s, ou).call(c, b, n, this.rotation),
      points: m(u = ot, $s, ou).call(u, v, n, this.rotation)
    });
  }
  return a;
}, "#serializePaths"), hu = /* @__PURE__ */ d(function() {
  let e = 1 / 0, s = -1 / 0, i = 1 / 0, n = -1 / 0;
  for (const a of this.paths)
    for (const [o, h, l, c] of a) {
      const u = I.bezierBoundingBox(...o, ...h, ...l, ...c);
      e = Math.min(e, u[0]), i = Math.min(i, u[1]), s = Math.max(s, u[2]), n = Math.max(n, u[3]);
    }
  return [e, i, s, n];
}, "#getBbox"), Mh = /* @__PURE__ */ d(function() {
  return r(this, ve) ? Math.ceil(this.thickness * this.parentScale) : 0;
}, "#getPadding"), Qr = /* @__PURE__ */ d(function(e = !1) {
  if (this.isEmpty())
    return;
  if (!r(this, ve)) {
    m(this, R, Si).call(this);
    return;
  }
  const s = m(this, R, hu).call(this), i = m(this, R, Mh).call(this);
  g(this, An, Math.max(Q.MIN_SIZE, s[2] - s[0])), g(this, bn, Math.max(Q.MIN_SIZE, s[3] - s[1]));
  const n = Math.ceil(i + r(this, An) * this.scaleFactor), a = Math.ceil(i + r(this, bn) * this.scaleFactor), [o, h] = this.parentDimensions;
  this.width = n / o, this.height = a / h, this.setAspectRatio(n, a);
  const l = this.translationX, c = this.translationY;
  this.translationX = -s[0], this.translationY = -s[1], m(this, R, Hn).call(this), m(this, R, Si).call(this), g(this, _n, n), g(this, En, a), this.setDims(n, a);
  const u = e ? i / this.scaleFactor / 2 : 0;
  this.translate(l - this.translationX - u, c - this.translationY - u);
}, "#fitToContent"), A(ot, $s), d(ot, "InkEditor"), U(ot, "_defaultColor", null), U(ot, "_defaultOpacity", 1), U(ot, "_defaultThickness", 1), U(ot, "_type", "ink"), U(ot, "_editorType", G.INK);
let su = ot;
var It, Pt, ui, Rs, fi, Ir, Ze, Yo, ks, ts, Ne, Ko, Y, Jr, Zr, Ih, cu, nm, rm, am, du, Ph, om;
const Bn = class Bn extends Q {
  constructor(e) {
    super({
      ...e,
      name: "stampEditor"
    });
    A(this, Y);
    A(this, It, null);
    A(this, Pt, null);
    A(this, ui, null);
    A(this, Rs, null);
    A(this, fi, null);
    A(this, Ir, "");
    A(this, Ze, null);
    A(this, Yo, !1);
    A(this, ks, null);
    A(this, ts, null);
    A(this, Ne, !1);
    A(this, Ko, !1);
    g(this, Rs, e.bitmapUrl), g(this, fi, e.bitmapFile);
  }
  static initialize(e, s) {
    Q.initialize(e, s);
  }
  static get supportedTypes() {
    return X(this, "supportedTypes", ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"].map((s) => `image/${s}`));
  }
  static get supportedTypesStr() {
    return X(this, "supportedTypesStr", this.supportedTypes.join(","));
  }
  static isHandlingMimeForPasting(e) {
    return this.supportedTypes.includes(e);
  }
  static paste(e, s) {
    s.pasteEditor(G.STAMP, {
      bitmapFile: e.getAsFile()
    });
  }
  remove() {
    var e, s;
    r(this, Pt) && (g(this, It, null), this._uiManager.imageManager.deleteId(r(this, Pt)), (e = r(this, Ze)) == null || e.remove(), g(this, Ze, null), (s = r(this, ks)) == null || s.disconnect(), g(this, ks, null), r(this, ts) && (clearTimeout(r(this, ts)), g(this, ts, null))), super.remove();
  }
  rebuild() {
    if (!this.parent) {
      r(this, Pt) && m(this, Y, Ih).call(this);
      return;
    }
    super.rebuild(), this.div !== null && (r(this, Pt) && r(this, Ze) === null && m(this, Y, Ih).call(this), this.isAttachedToDOM || this.parent.add(this));
  }
  onceAdded() {
    this._isDraggable = !0, this.div.focus();
  }
  isEmpty() {
    return !(r(this, ui) || r(this, It) || r(this, Rs) || r(this, fi) || r(this, Pt));
  }
  get isResizable() {
    return !0;
  }
  render() {
    if (this.div)
      return this.div;
    let e, s;
    if (this.width && (e = this.x, s = this.y), super.render(), this.div.hidden = !0, this.addAltTextButton(), r(this, It) ? m(this, Y, cu).call(this) : m(this, Y, Ih).call(this), this.width) {
      const [i, n] = this.parentDimensions;
      this.setAt(e * i, s * n, this.width * i, this.height * n);
    }
    return this.div;
  }
  getImageForAltText() {
    return r(this, Ze);
  }
  static deserialize(e, s, i) {
    if (e instanceof hl)
      return null;
    const n = super.deserialize(e, s, i), {
      rect: a,
      bitmapUrl: o,
      bitmapId: h,
      isSvg: l,
      accessibilityData: c
    } = e;
    h && i.imageManager.isValidId(h) ? g(n, Pt, h) : g(n, Rs, o), g(n, Ne, l);
    const [u, p] = n.pageDimensions;
    return n.width = (a[2] - a[0]) / u, n.height = (a[3] - a[1]) / p, c && (n.altTextData = c), n;
  }
  serialize(e = !1, s = null) {
    if (this.isEmpty())
      return null;
    const i = {
      annotationType: G.STAMP,
      bitmapId: r(this, Pt),
      pageIndex: this.pageIndex,
      rect: this.getRect(0, 0),
      rotation: this.rotation,
      isSvg: r(this, Ne),
      structTreeParentId: this._structTreeParentId
    };
    if (e)
      return i.bitmapUrl = m(this, Y, Ph).call(this, !0), i.accessibilityData = this.altTextData, i;
    const {
      decorative: n,
      altText: a
    } = this.altTextData;
    if (!n && a && (i.accessibilityData = {
      type: "Figure",
      alt: a
    }), s === null)
      return i;
    s.stamps || (s.stamps = /* @__PURE__ */ new Map());
    const o = r(this, Ne) ? (i.rect[2] - i.rect[0]) * (i.rect[3] - i.rect[1]) : null;
    if (!s.stamps.has(r(this, Pt)))
      s.stamps.set(r(this, Pt), {
        area: o,
        serialized: i
      }), i.bitmap = m(this, Y, Ph).call(this, !1);
    else if (r(this, Ne)) {
      const h = s.stamps.get(r(this, Pt));
      o > h.area && (h.area = o, h.serialized.bitmap.close(), h.serialized.bitmap = m(this, Y, Ph).call(this, !1));
    }
    return i;
  }
};
It = new WeakMap(), Pt = new WeakMap(), ui = new WeakMap(), Rs = new WeakMap(), fi = new WeakMap(), Ir = new WeakMap(), Ze = new WeakMap(), Yo = new WeakMap(), ks = new WeakMap(), ts = new WeakMap(), Ne = new WeakMap(), Ko = new WeakMap(), Y = new WeakSet(), Jr = /* @__PURE__ */ d(function(e, s = !1) {
  if (!e) {
    this.remove();
    return;
  }
  g(this, It, e.bitmap), s || (g(this, Pt, e.id), g(this, Ne, e.isSvg)), e.file && g(this, Ir, e.file.name), m(this, Y, cu).call(this);
}, "#getBitmapFetched"), Zr = /* @__PURE__ */ d(function() {
  g(this, ui, null), this._uiManager.enableWaiting(!1), r(this, Ze) && this.div.focus();
}, "#getBitmapDone"), Ih = /* @__PURE__ */ d(function() {
  if (r(this, Pt)) {
    this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(r(this, Pt)).then((i) => m(this, Y, Jr).call(this, i, !0)).finally(() => m(this, Y, Zr).call(this));
    return;
  }
  if (r(this, Rs)) {
    const i = r(this, Rs);
    g(this, Rs, null), this._uiManager.enableWaiting(!0), g(this, ui, this._uiManager.imageManager.getFromUrl(i).then((n) => m(this, Y, Jr).call(this, n)).finally(() => m(this, Y, Zr).call(this)));
    return;
  }
  if (r(this, fi)) {
    const i = r(this, fi);
    g(this, fi, null), this._uiManager.enableWaiting(!0), g(this, ui, this._uiManager.imageManager.getFromFile(i).then((n) => m(this, Y, Jr).call(this, n)).finally(() => m(this, Y, Zr).call(this)));
    return;
  }
  const e = document.createElement("input");
  e.type = "file", e.accept = Bn.supportedTypesStr;
  const s = this._uiManager._signal;
  g(this, ui, new Promise((i) => {
    e.addEventListener("change", async () => {
      if (!e.files || e.files.length === 0)
        this.remove();
      else {
        this._uiManager.enableWaiting(!0);
        const n = await this._uiManager.imageManager.getFromFile(e.files[0]);
        m(this, Y, Jr).call(this, n);
      }
      i();
    }, {
      signal: s
    }), e.addEventListener("cancel", () => {
      this.remove(), i();
    }, {
      signal: s
    });
  }).finally(() => m(this, Y, Zr).call(this))), e.click();
}, "#getBitmap"), cu = /* @__PURE__ */ d(function() {
  const {
    div: e
  } = this;
  let {
    width: s,
    height: i
  } = r(this, It);
  const [n, a] = this.pageDimensions, o = 0.75;
  if (this.width)
    s = this.width * n, i = this.height * a;
  else if (s > o * n || i > o * a) {
    const u = Math.min(o * n / s, o * a / i);
    s *= u, i *= u;
  }
  const [h, l] = this.parentDimensions;
  this.setDims(s * h / n, i * l / a), this._uiManager.enableWaiting(!1);
  const c = g(this, Ze, document.createElement("canvas"));
  e.append(c), e.hidden = !1, m(this, Y, du).call(this, s, i), m(this, Y, om).call(this), r(this, Ko) || (this.parent.addUndoableEditor(this), g(this, Ko, !0)), this._reportTelemetry({
    action: "inserted_image"
  }), r(this, Ir) && c.setAttribute("aria-label", r(this, Ir));
}, "#createCanvas"), nm = /* @__PURE__ */ d(function(e, s) {
  var o;
  const [i, n] = this.parentDimensions;
  this.width = e / i, this.height = s / n, this.setDims(e, s), (o = this._initialOptions) != null && o.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, r(this, ts) !== null && clearTimeout(r(this, ts)), g(this, ts, setTimeout(() => {
    g(this, ts, null), m(this, Y, du).call(this, e, s);
  }, 200));
}, "#setDimensions"), rm = /* @__PURE__ */ d(function(e, s) {
  const {
    width: i,
    height: n
  } = r(this, It);
  let a = i, o = n, h = r(this, It);
  for (; a > 2 * e || o > 2 * s; ) {
    const l = a, c = o;
    a > 2 * e && (a = a >= 16384 ? Math.floor(a / 2) - 1 : Math.ceil(a / 2)), o > 2 * s && (o = o >= 16384 ? Math.floor(o / 2) - 1 : Math.ceil(o / 2));
    const u = new OffscreenCanvas(a, o);
    u.getContext("2d").drawImage(h, 0, 0, l, c, 0, 0, a, o), h = u.transferToImageBitmap();
  }
  return h;
}, "#scaleBitmap"), am = /* @__PURE__ */ d(async function(e, s, i) {
  if (r(this, Yo) || (g(this, Yo, !0), !await this._uiManager.isMLEnabledFor("altText") || this.hasAltText()))
    return;
  const o = new OffscreenCanvas(s, i).getContext("2d", {
    willReadFrequently: !0
  });
  o.drawImage(e, 0, 0, e.width, e.height, 0, 0, s, i);
  const h = await this._uiManager.mlGuess({
    service: "moz-image-to-text",
    request: {
      data: o.getImageData(0, 0, s, i).data,
      width: s,
      height: i,
      channels: 4
    }
  }), l = (h == null ? void 0 : h.output) || "";
  this.parent && l && !this.hasAltText() && (this.altTextData = {
    altText: l,
    decorative: !1
  });
}, "#mlGuessAltText"), du = /* @__PURE__ */ d(function(e, s) {
  e = Math.ceil(e), s = Math.ceil(s);
  const i = r(this, Ze);
  if (!i || i.width === e && i.height === s)
    return;
  i.width = e, i.height = s;
  const n = r(this, Ne) ? r(this, It) : m(this, Y, rm).call(this, e, s);
  m(this, Y, am).call(this, n, e, s);
  const a = i.getContext("2d");
  a.filter = this._uiManager.hcmFilter, a.drawImage(n, 0, 0, n.width, n.height, 0, 0, e, s);
}, "#drawBitmap"), Ph = /* @__PURE__ */ d(function(e) {
  if (e) {
    if (r(this, Ne)) {
      const n = this._uiManager.imageManager.getSvgUrl(r(this, Pt));
      if (n)
        return n;
    }
    const s = document.createElement("canvas");
    return {
      width: s.width,
      height: s.height
    } = r(this, It), s.getContext("2d").drawImage(r(this, It), 0, 0), s.toDataURL();
  }
  if (r(this, Ne)) {
    const [s, i] = this.pageDimensions, n = Math.round(this.width * s * bi.PDF_TO_CSS_UNITS), a = Math.round(this.height * i * bi.PDF_TO_CSS_UNITS), o = new OffscreenCanvas(n, a);
    return o.getContext("2d").drawImage(r(this, It), 0, 0, r(this, It).width, r(this, It).height, 0, 0, n, a), o.transferToImageBitmap();
  }
  return structuredClone(r(this, It));
}, "#serializeBitmap"), om = /* @__PURE__ */ d(function() {
  this._uiManager._signal && (g(this, ks, new ResizeObserver((e) => {
    const s = e[0].contentRect;
    s.width && s.height && m(this, Y, nm).call(this, s.width, s.height);
  })), r(this, ks).observe(this.div), this._uiManager._signal.addEventListener("abort", () => {
    var e;
    (e = r(this, ks)) == null || e.disconnect(), g(this, ks, null);
  }, {
    once: !0
  }));
}, "#createObserver"), d(Bn, "StampEditor"), U(Bn, "_type", "stamp"), U(Bn, "_editorType", G.STAMP);
let lu = Bn;
var Sn, Pr, es, Cn, Ms, Is, Ps, de, pi, Dr, Fr, zt, D, gi, Dt, hm, fu, pu, gu, Dh;
const ge = class ge {
  constructor({
    uiManager: t,
    pageIndex: e,
    div: s,
    accessibilityManager: i,
    annotationLayer: n,
    drawLayer: a,
    textLayer: o,
    viewport: h,
    l10n: l
  }) {
    A(this, Dt);
    A(this, Sn);
    A(this, Pr, !1);
    A(this, es, null);
    A(this, Cn, null);
    A(this, Ms, null);
    A(this, Is, null);
    A(this, Ps, null);
    A(this, de, /* @__PURE__ */ new Map());
    A(this, pi, !1);
    A(this, Dr, !1);
    A(this, Fr, !1);
    A(this, zt, null);
    A(this, D);
    const c = [...r(ge, gi).values()];
    if (!ge._initialized) {
      ge._initialized = !0;
      for (const u of c)
        u.initialize(l, t);
    }
    t.registerEditorTypes(c), g(this, D, t), this.pageIndex = e, this.div = s, g(this, Sn, i), g(this, es, n), this.viewport = h, g(this, zt, o), this.drawLayer = a, r(this, D).addLayer(this);
  }
  get isEmpty() {
    return r(this, de).size === 0;
  }
  get isInvisible() {
    return this.isEmpty && r(this, D).getMode() === G.NONE;
  }
  updateToolbar(t) {
    r(this, D).updateToolbar(t);
  }
  updateMode(t = r(this, D).getMode()) {
    switch (m(this, Dt, Dh).call(this), t) {
      case G.NONE:
        this.disableTextSelection(), this.togglePointerEvents(!1), this.toggleAnnotationLayerPointerEvents(!0), this.disableClick();
        return;
      case G.INK:
        this.addInkEditorIfNeeded(!1), this.disableTextSelection(), this.togglePointerEvents(!0), this.disableClick();
        break;
      case G.HIGHLIGHT:
        this.enableTextSelection(), this.togglePointerEvents(!1), this.disableClick();
        break;
      default:
        this.disableTextSelection(), this.togglePointerEvents(!0), this.enableClick();
    }
    this.toggleAnnotationLayerPointerEvents(!1);
    const {
      classList: e
    } = this.div;
    for (const s of r(ge, gi).values())
      e.toggle(`${s._type}Editing`, t === s._editorType);
    this.div.hidden = !1;
  }
  hasTextLayer(t) {
    var e;
    return t === ((e = r(this, zt)) == null ? void 0 : e.div);
  }
  addInkEditorIfNeeded(t) {
    if (r(this, D).getMode() !== G.INK)
      return;
    if (!t) {
      for (const s of r(this, de).values())
        if (s.isEmpty()) {
          s.setInBackground();
          return;
        }
    }
    this.createAndAddNewEditor({
      offsetX: 0,
      offsetY: 0
    }, !1).setInBackground();
  }
  setEditingState(t) {
    r(this, D).setEditingState(t);
  }
  addCommands(t) {
    r(this, D).addCommands(t);
  }
  toggleDrawing(t = !1) {
    this.div.classList.toggle("drawing", !t);
  }
  togglePointerEvents(t = !1) {
    this.div.classList.toggle("disabled", !t);
  }
  toggleAnnotationLayerPointerEvents(t = !1) {
    var e;
    (e = r(this, es)) == null || e.div.classList.toggle("disabled", !t);
  }
  enable() {
    this.div.tabIndex = 0, this.togglePointerEvents(!0);
    const t = /* @__PURE__ */ new Set();
    for (const s of r(this, de).values())
      s.enableEditing(), s.show(!0), s.annotationElementId && (r(this, D).removeChangedExistingAnnotation(s), t.add(s.annotationElementId));
    if (!r(this, es))
      return;
    const e = r(this, es).getEditableAnnotations();
    for (const s of e) {
      if (s.hide(), r(this, D).isDeletedAnnotationElement(s.data.id) || t.has(s.data.id))
        continue;
      const i = this.deserialize(s);
      i && (this.addOrRebuild(i), i.enableEditing());
    }
  }
  disable() {
    var i;
    g(this, Fr, !0), this.div.tabIndex = -1, this.togglePointerEvents(!1);
    const t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map();
    for (const n of r(this, de).values())
      if (n.disableEditing(), !!n.annotationElementId) {
        if (n.serialize() !== null) {
          t.set(n.annotationElementId, n);
          continue;
        } else
          e.set(n.annotationElementId, n);
        (i = this.getEditableAnnotation(n.annotationElementId)) == null || i.show(), n.remove();
      }
    if (r(this, es)) {
      const n = r(this, es).getEditableAnnotations();
      for (const a of n) {
        const {
          id: o
        } = a.data;
        if (r(this, D).isDeletedAnnotationElement(o))
          continue;
        let h = e.get(o);
        if (h) {
          h.resetAnnotationElement(a), h.show(!1), a.show();
          continue;
        }
        h = t.get(o), h && (r(this, D).addChangedExistingAnnotation(h), h.renderAnnotationElement(a), h.show(!1)), a.show();
      }
    }
    m(this, Dt, Dh).call(this), this.isEmpty && (this.div.hidden = !0);
    const {
      classList: s
    } = this.div;
    for (const n of r(ge, gi).values())
      s.remove(`${n._type}Editing`);
    this.disableTextSelection(), this.toggleAnnotationLayerPointerEvents(!0), g(this, Fr, !1);
  }
  getEditableAnnotation(t) {
    var e;
    return ((e = r(this, es)) == null ? void 0 : e.getEditableAnnotation(t)) || null;
  }
  setActiveEditor(t) {
    r(this, D).getActive() !== t && r(this, D).setActiveEditor(t);
  }
  enableTextSelection() {
    var t;
    this.div.tabIndex = -1, (t = r(this, zt)) != null && t.div && !r(this, Is) && (g(this, Is, m(this, Dt, hm).bind(this)), r(this, zt).div.addEventListener("pointerdown", r(this, Is), {
      signal: r(this, D)._signal
    }), r(this, zt).div.classList.add("highlighting"));
  }
  disableTextSelection() {
    var t;
    this.div.tabIndex = 0, (t = r(this, zt)) != null && t.div && r(this, Is) && (r(this, zt).div.removeEventListener("pointerdown", r(this, Is)), g(this, Is, null), r(this, zt).div.classList.remove("highlighting"));
  }
  enableClick() {
    if (r(this, Ms))
      return;
    const t = r(this, D)._signal;
    g(this, Ms, this.pointerdown.bind(this)), g(this, Cn, this.pointerup.bind(this)), this.div.addEventListener("pointerdown", r(this, Ms), {
      signal: t
    }), this.div.addEventListener("pointerup", r(this, Cn), {
      signal: t
    });
  }
  disableClick() {
    r(this, Ms) && (this.div.removeEventListener("pointerdown", r(this, Ms)), this.div.removeEventListener("pointerup", r(this, Cn)), g(this, Ms, null), g(this, Cn, null));
  }
  attach(t) {
    r(this, de).set(t.id, t);
    const {
      annotationElementId: e
    } = t;
    e && r(this, D).isDeletedAnnotationElement(e) && r(this, D).removeDeletedAnnotationElement(t);
  }
  detach(t) {
    var e;
    r(this, de).delete(t.id), (e = r(this, Sn)) == null || e.removePointerInTextLayer(t.contentDiv), !r(this, Fr) && t.annotationElementId && r(this, D).addDeletedAnnotationElement(t);
  }
  remove(t) {
    this.detach(t), r(this, D).removeEditor(t), t.div.remove(), t.isAttachedToDOM = !1, r(this, Dr) || this.addInkEditorIfNeeded(!1);
  }
  changeParent(t) {
    var e;
    t.parent !== this && (t.parent && t.annotationElementId && (r(this, D).addDeletedAnnotationElement(t.annotationElementId), Q.deleteAnnotationElement(t), t.annotationElementId = null), this.attach(t), (e = t.parent) == null || e.detach(t), t.setParent(this), t.div && t.isAttachedToDOM && (t.div.remove(), this.div.append(t.div)));
  }
  add(t) {
    if (!(t.parent === this && t.isAttachedToDOM)) {
      if (this.changeParent(t), r(this, D).addEditor(t), this.attach(t), !t.isAttachedToDOM) {
        const e = t.render();
        this.div.append(e), t.isAttachedToDOM = !0;
      }
      t.fixAndSetPosition(), t.onceAdded(), r(this, D).addToAnnotationStorage(t), t._reportTelemetry(t.telemetryInitialData);
    }
  }
  moveEditorInDOM(t) {
    var s;
    if (!t.isAttachedToDOM)
      return;
    const {
      activeElement: e
    } = document;
    t.div.contains(e) && !r(this, Ps) && (t._focusEventsAllowed = !1, g(this, Ps, setTimeout(() => {
      g(this, Ps, null), t.div.contains(document.activeElement) ? t._focusEventsAllowed = !0 : (t.div.addEventListener("focusin", () => {
        t._focusEventsAllowed = !0;
      }, {
        once: !0,
        signal: r(this, D)._signal
      }), e.focus());
    }, 0))), t._structTreeParentId = (s = r(this, Sn)) == null ? void 0 : s.moveElementInDOM(this.div, t.div, t.contentDiv, !0);
  }
  addOrRebuild(t) {
    t.needsToBeRebuilt() ? (t.parent || (t.parent = this), t.rebuild(), t.show()) : this.add(t);
  }
  addUndoableEditor(t) {
    const e = /* @__PURE__ */ d(() => t._uiManager.rebuild(t), "cmd"), s = /* @__PURE__ */ d(() => {
      t.remove();
    }, "undo");
    this.addCommands({
      cmd: e,
      undo: s,
      mustExec: !1
    });
  }
  getNextId() {
    return r(this, D).getId();
  }
  get _signal() {
    return r(this, D)._signal;
  }
  canCreateNewEmptyEditor() {
    var t;
    return (t = r(this, Dt, fu)) == null ? void 0 : t.canCreateNewEmptyEditor();
  }
  pasteEditor(t, e) {
    r(this, D).updateToolbar(t), r(this, D).updateMode(t);
    const {
      offsetX: s,
      offsetY: i
    } = m(this, Dt, gu).call(this), n = this.getNextId(), a = m(this, Dt, pu).call(this, {
      parent: this,
      id: n,
      x: s,
      y: i,
      uiManager: r(this, D),
      isCentered: !0,
      ...e
    });
    a && this.add(a);
  }
  deserialize(t) {
    var e;
    return ((e = r(ge, gi).get(t.annotationType ?? t.annotationEditorType)) == null ? void 0 : e.deserialize(t, this, r(this, D))) || null;
  }
  createAndAddNewEditor(t, e, s = {}) {
    const i = this.getNextId(), n = m(this, Dt, pu).call(this, {
      parent: this,
      id: i,
      x: t.offsetX,
      y: t.offsetY,
      uiManager: r(this, D),
      isCentered: e,
      ...s
    });
    return n && this.add(n), n;
  }
  addNewEditor() {
    this.createAndAddNewEditor(m(this, Dt, gu).call(this), !0);
  }
  setSelected(t) {
    r(this, D).setSelected(t);
  }
  toggleSelected(t) {
    r(this, D).toggleSelected(t);
  }
  isSelected(t) {
    return r(this, D).isSelected(t);
  }
  unselect(t) {
    r(this, D).unselect(t);
  }
  pointerup(t) {
    const {
      isMac: e
    } = jt.platform;
    if (!(t.button !== 0 || t.ctrlKey && e) && t.target === this.div && r(this, pi)) {
      if (g(this, pi, !1), !r(this, Pr)) {
        g(this, Pr, !0);
        return;
      }
      if (r(this, D).getMode() === G.STAMP) {
        r(this, D).unselectAll();
        return;
      }
      this.createAndAddNewEditor(t, !1);
    }
  }
  pointerdown(t) {
    if (r(this, D).getMode() === G.HIGHLIGHT && this.enableTextSelection(), r(this, pi)) {
      g(this, pi, !1);
      return;
    }
    const {
      isMac: e
    } = jt.platform;
    if (t.button !== 0 || t.ctrlKey && e || t.target !== this.div)
      return;
    g(this, pi, !0);
    const s = r(this, D).getActive();
    g(this, Pr, !s || s.isEmpty());
  }
  findNewParent(t, e, s) {
    const i = r(this, D).findParent(e, s);
    return i === null || i === this ? !1 : (i.changeParent(t), !0);
  }
  destroy() {
    var t, e;
    ((t = r(this, D).getActive()) == null ? void 0 : t.parent) === this && (r(this, D).commitOrRemove(), r(this, D).setActiveEditor(null)), r(this, Ps) && (clearTimeout(r(this, Ps)), g(this, Ps, null));
    for (const s of r(this, de).values())
      (e = r(this, Sn)) == null || e.removePointerInTextLayer(s.contentDiv), s.setParent(null), s.isAttachedToDOM = !1, s.div.remove();
    this.div = null, r(this, de).clear(), r(this, D).removeLayer(this);
  }
  render({
    viewport: t
  }) {
    this.viewport = t, xn(this.div, t);
    for (const e of r(this, D).getEditors(this.pageIndex))
      this.add(e), e.rebuild();
    this.updateMode();
  }
  update({
    viewport: t
  }) {
    r(this, D).commitOrRemove(), m(this, Dt, Dh).call(this);
    const e = this.viewport.rotation, s = t.rotation;
    if (this.viewport = t, xn(this.div, {
      rotation: s
    }), e !== s)
      for (const i of r(this, de).values())
        i.rotate(s);
    this.addInkEditorIfNeeded(!1);
  }
  get pageDimensions() {
    const {
      pageWidth: t,
      pageHeight: e
    } = this.viewport.rawDims;
    return [t, e];
  }
  get scale() {
    return r(this, D).viewParameters.realScale;
  }
};
Sn = new WeakMap(), Pr = new WeakMap(), es = new WeakMap(), Cn = new WeakMap(), Ms = new WeakMap(), Is = new WeakMap(), Ps = new WeakMap(), de = new WeakMap(), pi = new WeakMap(), Dr = new WeakMap(), Fr = new WeakMap(), zt = new WeakMap(), D = new WeakMap(), gi = new WeakMap(), Dt = new WeakSet(), hm = /* @__PURE__ */ d(function(t) {
  r(this, D).unselectAll();
  const {
    target: e
  } = t;
  if (e === r(this, zt).div || e.classList.contains("endOfContent") && r(this, zt).div.contains(e)) {
    const {
      isMac: s
    } = jt.platform;
    if (t.button !== 0 || t.ctrlKey && s)
      return;
    r(this, D).showAllEditors("highlight", !0, !0), r(this, zt).div.classList.add("free"), this.toggleDrawing(), fl.startHighlighting(this, r(this, D).direction === "ltr", t), r(this, zt).div.addEventListener("pointerup", () => {
      r(this, zt).div.classList.remove("free"), this.toggleDrawing(!0);
    }, {
      once: !0,
      signal: r(this, D)._signal
    }), t.preventDefault();
  }
}, "#textLayerPointerDown"), fu = /* @__PURE__ */ d(function() {
  return r(ge, gi).get(r(this, D).getMode());
}, "#currentEditorType"), pu = /* @__PURE__ */ d(function(t) {
  const e = r(this, Dt, fu);
  return e ? new e.prototype.constructor(t) : null;
}, "#createNewEditor"), gu = /* @__PURE__ */ d(function() {
  const {
    x: t,
    y: e,
    width: s,
    height: i
  } = this.div.getBoundingClientRect(), n = Math.max(0, t), a = Math.max(0, e), o = Math.min(window.innerWidth, t + s), h = Math.min(window.innerHeight, e + i), l = (n + o) / 2 - t, c = (a + h) / 2 - e, [u, p] = this.viewport.rotation % 180 === 0 ? [l, c] : [c, l];
  return {
    offsetX: u,
    offsetY: p
  };
}, "#getCenterPoint"), Dh = /* @__PURE__ */ d(function() {
  g(this, Dr, !0);
  for (const t of r(this, de).values())
    t.isEmpty() && t.remove();
  g(this, Dr, !1);
}, "#cleanup"), d(ge, "AnnotationEditorLayer"), U(ge, "_initialized", !1), A(ge, gi, new Map([Gd, su, lu, fl].map((t) => [t._editorType, t])));
let uu = ge;
var ss, Qo, wt, mi, Jo, bu, Mn, Au, lm;
const Et = class Et {
  constructor({
    pageIndex: t
  }) {
    A(this, Mn);
    A(this, ss, null);
    A(this, Qo, 0);
    A(this, wt, /* @__PURE__ */ new Map());
    A(this, mi, /* @__PURE__ */ new Map());
    this.pageIndex = t;
  }
  setParent(t) {
    if (!r(this, ss)) {
      g(this, ss, t);
      return;
    }
    if (r(this, ss) !== t) {
      if (r(this, wt).size > 0)
        for (const e of r(this, wt).values())
          e.remove(), t.append(e);
      g(this, ss, t);
    }
  }
  static get _svgFactory() {
    return X(this, "_svgFactory", new la());
  }
  highlight(t, e, s, i = !1) {
    const n = se(this, Qo)._++, a = m(this, Mn, Au).call(this, t.box);
    a.classList.add("highlight"), t.free && a.classList.add("free");
    const o = Et._svgFactory.createElement("defs");
    a.append(o);
    const h = Et._svgFactory.createElement("path");
    o.append(h);
    const l = `path_p${this.pageIndex}_${n}`;
    h.setAttribute("id", l), h.setAttribute("d", t.toSVGPath()), i && r(this, mi).set(n, h);
    const c = m(this, Mn, lm).call(this, o, l), u = Et._svgFactory.createElement("use");
    return a.append(u), a.setAttribute("fill", e), a.setAttribute("fill-opacity", s), u.setAttribute("href", `#${l}`), r(this, wt).set(n, a), {
      id: n,
      clipPathId: `url(#${c})`
    };
  }
  highlightOutline(t) {
    const e = se(this, Qo)._++, s = m(this, Mn, Au).call(this, t.box);
    s.classList.add("highlightOutline");
    const i = Et._svgFactory.createElement("defs");
    s.append(i);
    const n = Et._svgFactory.createElement("path");
    i.append(n);
    const a = `path_p${this.pageIndex}_${e}`;
    n.setAttribute("id", a), n.setAttribute("d", t.toSVGPath()), n.setAttribute("vector-effect", "non-scaling-stroke");
    let o;
    if (t.free) {
      s.classList.add("free");
      const c = Et._svgFactory.createElement("mask");
      i.append(c), o = `mask_p${this.pageIndex}_${e}`, c.setAttribute("id", o), c.setAttribute("maskUnits", "objectBoundingBox");
      const u = Et._svgFactory.createElement("rect");
      c.append(u), u.setAttribute("width", "1"), u.setAttribute("height", "1"), u.setAttribute("fill", "white");
      const p = Et._svgFactory.createElement("use");
      c.append(p), p.setAttribute("href", `#${a}`), p.setAttribute("stroke", "none"), p.setAttribute("fill", "black"), p.setAttribute("fill-rule", "nonzero"), p.classList.add("mask");
    }
    const h = Et._svgFactory.createElement("use");
    s.append(h), h.setAttribute("href", `#${a}`), o && h.setAttribute("mask", `url(#${o})`);
    const l = h.cloneNode();
    return s.append(l), h.classList.add("mainOutline"), l.classList.add("secondaryOutline"), r(this, wt).set(e, s), e;
  }
  finalizeLine(t, e) {
    const s = r(this, mi).get(t);
    r(this, mi).delete(t), this.updateBox(t, e.box), s.setAttribute("d", e.toSVGPath());
  }
  updateLine(t, e) {
    r(this, wt).get(t).firstChild.firstChild.setAttribute("d", e.toSVGPath());
  }
  removeFreeHighlight(t) {
    this.remove(t), r(this, mi).delete(t);
  }
  updatePath(t, e) {
    r(this, mi).get(t).setAttribute("d", e.toSVGPath());
  }
  updateBox(t, e) {
    var s;
    m(s = Et, Jo, bu).call(s, r(this, wt).get(t), e);
  }
  show(t, e) {
    r(this, wt).get(t).classList.toggle("hidden", !e);
  }
  rotate(t, e) {
    r(this, wt).get(t).setAttribute("data-main-rotation", e);
  }
  changeColor(t, e) {
    r(this, wt).get(t).setAttribute("fill", e);
  }
  changeOpacity(t, e) {
    r(this, wt).get(t).setAttribute("fill-opacity", e);
  }
  addClass(t, e) {
    r(this, wt).get(t).classList.add(e);
  }
  removeClass(t, e) {
    r(this, wt).get(t).classList.remove(e);
  }
  remove(t) {
    r(this, ss) !== null && (r(this, wt).get(t).remove(), r(this, wt).delete(t));
  }
  destroy() {
    g(this, ss, null);
    for (const t of r(this, wt).values())
      t.remove();
    r(this, wt).clear();
  }
};
ss = new WeakMap(), Qo = new WeakMap(), wt = new WeakMap(), mi = new WeakMap(), Jo = new WeakSet(), bu = /* @__PURE__ */ d(function(t, {
  x: e = 0,
  y: s = 0,
  width: i = 1,
  height: n = 1
} = {}) {
  const {
    style: a
  } = t;
  a.top = `${100 * s}%`, a.left = `${100 * e}%`, a.width = `${100 * i}%`, a.height = `${100 * n}%`;
}, "#setBox"), Mn = new WeakSet(), Au = /* @__PURE__ */ d(function(t) {
  var s;
  const e = Et._svgFactory.create(1, 1, !0);
  return r(this, ss).append(e), e.setAttribute("aria-hidden", !0), m(s = Et, Jo, bu).call(s, e, t), e;
}, "#createSVG"), lm = /* @__PURE__ */ d(function(t, e) {
  const s = Et._svgFactory.createElement("clipPath");
  t.append(s);
  const i = `clip_${e}`;
  s.setAttribute("id", i), s.setAttribute("clipPathUnits", "objectBoundingBox");
  const n = Et._svgFactory.createElement("use");
  return s.append(n), n.setAttribute("href", `#${e}`), n.classList.add("clip"), i;
}, "#createClipPath"), A(Et, Jo), d(Et, "DrawLayer");
let mu = Et;
B.AbortException;
B.AnnotationEditorLayer;
B.AnnotationEditorParamsType;
var nb = B.AnnotationEditorType;
B.AnnotationEditorUIManager;
B.AnnotationLayer;
B.AnnotationMode;
B.CMapCompressionType;
B.ColorPicker;
B.DOMSVGFactory;
B.DrawLayer;
B.FeatureTest;
var rb = B.GlobalWorkerOptions;
B.ImageKind;
var ab = B.InvalidPDFException, ob = B.MissingPDFException;
B.OPS;
B.PDFDataRangeTransport;
B.PDFDateString;
B.PDFWorker;
B.PasswordResponses;
B.PermissionFlag;
B.PixelsPerInch;
B.RenderingCancelledException;
B.TextLayer;
var hb = B.UnexpectedResponseException;
B.Util;
B.VerbosityLevel;
B.XfaLayer;
var lb = B.build;
B.createValidAbsoluteUrl;
B.fetchData;
var cb = B.getDocument;
B.getFilenameFromUrl;
B.getPdfFilenameFromUrl;
B.getXfaPageViewport;
B.isDataScheme;
B.isPdfFile;
B.noContextMenu;
B.normalizeUnicode;
B.setLayerDimensions;
B.shadow;
var db = B.version;
export {
  nb as __webpack_exports__AnnotationEditorType,
  rb as __webpack_exports__GlobalWorkerOptions,
  ab as __webpack_exports__InvalidPDFException,
  ob as __webpack_exports__MissingPDFException,
  hb as __webpack_exports__UnexpectedResponseException,
  lb as __webpack_exports__build,
  cb as __webpack_exports__getDocument,
  db as __webpack_exports__version
};
