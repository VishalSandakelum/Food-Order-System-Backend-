import { LitElement, ReactiveController, ReactiveControllerHost } from 'lit';
import { QueryClient, MutationObserverResult, MutationObserverOptions, MutationObserver, MutateOptions } from '@tanstack/query-core';
import { ContextConsumer } from '@lit/context';
import { WeavyContextType } from '../contexts/weavy-context';
export declare class MutationController<TData, TError, TVariables, TContext> implements ReactiveController {
    host: ReactiveControllerHost;
    context?: ContextConsumer<{
        __context__: WeavyContextType;
    }, LitElement>;
    whenContext: Promise<void>;
    resolveContext?: (value: void | PromiseLike<void>) => void;
    whenObserver: Promise<MutationObserver<TData, TError, TVariables, TContext>>;
    resolveObserver?: (value: MutationObserver<TData, TError, TVariables, TContext> | PromiseLike<MutationObserver<TData, TError, TVariables, TContext>>) => void;
    observer?: MutationObserver<TData, TError, TVariables, TContext>;
    result?: MutationObserverResult<TData, TError, TVariables, TContext>;
    private observerUnsubscribe?;
    constructor(host: ReactiveControllerHost);
    setContext(): Promise<void>;
    hostUpdate(): void;
    trackMutation(options: MutationObserverOptions<TData, TError, TVariables, TContext>, queryClient?: QueryClient): Promise<MutationObserver<TData, TError, TVariables, TContext>>;
    observerSubscribe(): void;
    untrackMutation(): void;
    mutate(variables: TVariables, options?: MutateOptions<TData, TError, TVariables, TContext>): Promise<TData>;
    hostConnected(): void;
    hostDisconnected(): void;
}
//# sourceMappingURL=mutation-controller.d.ts.map